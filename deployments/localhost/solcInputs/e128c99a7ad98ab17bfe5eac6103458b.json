{
  "language": "Solidity",
  "sources": {
    "contracts/mocks/MockGenericAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../release/extensions/integration-manager/integrations/utils/AdapterBase.sol\";\n\n/// @title IMockGenericIntegratee Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IMockGenericIntegratee {\n    function swap(\n        address[] calldata,\n        uint256[] calldata,\n        address[] calldata,\n        uint256[] calldata\n    ) external payable;\n\n    function swapOnBehalf(\n        address payable,\n        address[] calldata,\n        uint256[] calldata,\n        address[] calldata,\n        uint256[] calldata\n    ) external payable;\n}\n\n/// @title MockGenericAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Provides a generic adapter that:\n/// 1. Provides swapping functions that use various `SpendAssetsTransferType` values\n/// 2. Directly parses the _actual_ values to swap from provided call data (e.g., `actualIncomingAssetAmounts`)\n/// 3. Directly parses values needed by the IntegrationManager from provided call data (e.g., `minIncomingAssetAmounts`)\ncontract MockGenericAdapter is AdapterBase {\n    address public immutable INTEGRATEE;\n\n    modifier fundAssetsTransferHandler(\n        address _vaultProxy,\n        bytes memory _assetData,\n        IIntegrationManager.SpendAssetsHandleType _handleType\n    ) {\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n\n        // Take custody of spend assets (if necessary)\n        if (_handleType == IIntegrationManager.SpendAssetsHandleType.Approve) {\n            for (uint256 i; i < spendAssets.length; i++) {\n                ERC20(spendAssets[i]).safeTransferFrom(\n                    _vaultProxy,\n                    address(this),\n                    spendAssetAmounts[i]\n                );\n            }\n        }\n\n        // Execute call\n        _;\n\n        // Transfer remaining assets back to the fund's VaultProxy\n        __pushFullAssetBalances(_vaultProxy, incomingAssets);\n        __pushFullAssetBalances(_vaultProxy, spendAssets);\n    }\n\n    // No need to specify the IntegrationManager\n    constructor(address _integratee) public AdapterBase(address(0)) {\n        INTEGRATEE = _integratee;\n    }\n\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _callArgs\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory maxSpendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            spendAssets_,\n            maxSpendAssetAmounts_,\n            ,\n            incomingAssets_,\n            minIncomingAssetAmounts_,\n\n        ) = __decodeCallArgs(_callArgs);\n\n        return (\n            __getSpendAssetsHandleTypeForSelector(_selector),\n            spendAssets_,\n            maxSpendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Assumes SpendAssetsHandleType.Transfer unless otherwise specified\n    function __getSpendAssetsHandleTypeForSelector(bytes4 _selector)\n        private\n        pure\n        returns (IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_)\n    {\n        if (_selector == bytes4(keccak256(\"swapDirectFromVault(address,bytes,bytes)\"))) {\n            return IIntegrationManager.SpendAssetsHandleType.None;\n        }\n        if (_selector == bytes4(keccak256(\"swapViaApproval(address,bytes,bytes)\"))) {\n            return IIntegrationManager.SpendAssetsHandleType.Approve;\n        }\n        return IIntegrationManager.SpendAssetsHandleType.Transfer;\n    }\n\n    function removeOnly(\n        address,\n        bytes calldata,\n        bytes calldata\n    ) external {}\n\n    function swapA(\n        address _vaultProxy,\n        bytes calldata _callArgs,\n        bytes calldata _assetTransferArgs\n    )\n        external\n        fundAssetsTransferHandler(\n            _vaultProxy,\n            _assetTransferArgs,\n            __getSpendAssetsHandleTypeForSelector(bytes4(keccak256(\"swapA(address,bytes,bytes)\")))\n        )\n    {\n        __decodeCallArgsAndSwap(_callArgs);\n    }\n\n    function swapB(\n        address _vaultProxy,\n        bytes calldata _callArgs,\n        bytes calldata _assetTransferArgs\n    )\n        external\n        fundAssetsTransferHandler(\n            _vaultProxy,\n            _assetTransferArgs,\n            __getSpendAssetsHandleTypeForSelector(bytes4(keccak256(\"swapB(address,bytes,bytes)\")))\n        )\n    {\n        __decodeCallArgsAndSwap(_callArgs);\n    }\n\n    function swapDirectFromVault(\n        address _vaultProxy,\n        bytes calldata _callArgs,\n        bytes calldata\n    ) external {\n        (\n            address[] memory spendAssets,\n            ,\n            uint256[] memory actualSpendAssetAmounts,\n            address[] memory incomingAssets,\n            ,\n            uint256[] memory actualIncomingAssetAmounts\n        ) = __decodeCallArgs(_callArgs);\n\n        IMockGenericIntegratee(INTEGRATEE).swapOnBehalf(\n            payable(_vaultProxy),\n            spendAssets,\n            actualSpendAssetAmounts,\n            incomingAssets,\n            actualIncomingAssetAmounts\n        );\n    }\n\n    function swapViaApproval(\n        address _vaultProxy,\n        bytes calldata _callArgs,\n        bytes calldata _assetTransferArgs\n    )\n        external\n        fundAssetsTransferHandler(\n            _vaultProxy,\n            _assetTransferArgs,\n            __getSpendAssetsHandleTypeForSelector(\n                bytes4(keccak256(\"swapViaApproval(address,bytes,bytes)\"))\n            )\n        )\n    {\n        __decodeCallArgsAndSwap(_callArgs);\n    }\n\n    function __decodeCallArgs(bytes memory _callArgs)\n        internal\n        pure\n        returns (\n            address[] memory spendAssets_,\n            uint256[] memory maxSpendAssetAmounts_,\n            uint256[] memory actualSpendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_,\n            uint256[] memory actualIncomingAssetAmounts_\n        )\n    {\n        return\n            abi.decode(\n                _callArgs,\n                (address[], uint256[], uint256[], address[], uint256[], uint256[])\n            );\n    }\n\n    function __decodeCallArgsAndSwap(bytes memory _callArgs) internal {\n        (\n            address[] memory spendAssets,\n            ,\n            uint256[] memory actualSpendAssetAmounts,\n            address[] memory incomingAssets,\n            ,\n            uint256[] memory actualIncomingAssetAmounts\n        ) = __decodeCallArgs(_callArgs);\n\n        for (uint256 i; i < spendAssets.length; i++) {\n            ERC20(spendAssets[i]).safeApprove(INTEGRATEE, actualSpendAssetAmounts[i]);\n        }\n        IMockGenericIntegratee(INTEGRATEE).swap(\n            spendAssets,\n            actualSpendAssetAmounts,\n            incomingAssets,\n            actualIncomingAssetAmounts\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name_, string memory symbol_) public {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal virtual {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/AdapterBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../utils/AssetHelpers.sol\";\nimport \"../IIntegrationAdapter.sol\";\nimport \"./IntegrationSelectors.sol\";\n\n/// @title AdapterBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A base contract for integration adapters\nabstract contract AdapterBase is IIntegrationAdapter, IntegrationSelectors, AssetHelpers {\n    using SafeERC20 for ERC20;\n\n    address internal immutable INTEGRATION_MANAGER;\n\n    /// @dev Provides a standard implementation for transferring incoming assets\n    /// from an adapter to a VaultProxy at the end of an adapter action\n    modifier postActionIncomingAssetsTransferHandler(\n        address _vaultProxy,\n        bytes memory _assetData\n    ) {\n        _;\n\n        (, , address[] memory incomingAssets) = __decodeAssetData(_assetData);\n\n        __pushFullAssetBalances(_vaultProxy, incomingAssets);\n    }\n\n    /// @dev Provides a standard implementation for transferring unspent spend assets\n    /// from an adapter to a VaultProxy at the end of an adapter action\n    modifier postActionSpendAssetsTransferHandler(address _vaultProxy, bytes memory _assetData) {\n        _;\n\n        (address[] memory spendAssets, , ) = __decodeAssetData(_assetData);\n\n        __pushFullAssetBalances(_vaultProxy, spendAssets);\n    }\n\n    modifier onlyIntegrationManager {\n        require(\n            msg.sender == INTEGRATION_MANAGER,\n            \"Only the IntegrationManager can call this function\"\n        );\n        _;\n    }\n\n    constructor(address _integrationManager) public {\n        INTEGRATION_MANAGER = _integrationManager;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Helper to decode the _assetData param passed to adapter call\n    function __decodeAssetData(bytes memory _assetData)\n        internal\n        pure\n        returns (\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_\n        )\n    {\n        return abi.decode(_assetData, (address[], uint256[], address[]));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `INTEGRATION_MANAGER` variable\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\n    function getIntegrationManager() external view returns (address integrationManager_) {\n        return INTEGRATION_MANAGER;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        uint256 c = a + b;\n        if (c < a) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b > a) return (false, 0);\n        return (true, a - b);\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) return (true, 0);\n        uint256 c = a * b;\n        if (c / a != b) return (false, 0);\n        return (true, c);\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a / b);\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        if (b == 0) return (false, 0);\n        return (true, a % b);\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) return 0;\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: division by zero\");\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b > 0, \"SafeMath: modulo by zero\");\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \"SafeERC20: decreased allowance below zero\");\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) { // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "contracts/release/utils/AssetHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title AssetHelpers Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A util contract for common token actions\nabstract contract AssetHelpers {\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    /// @dev Helper to approve a target account with the max amount of an asset.\n    /// This is helpful for fully trusted contracts, such as adapters that\n    /// interact with external protocol like Uniswap, Compound, etc.\n    function __approveAssetMaxAsNeeded(\n        address _asset,\n        address _target,\n        uint256 _neededAmount\n    ) internal {\n        uint256 allowance = ERC20(_asset).allowance(address(this), _target);\n        console.log(\"__approveAssetMaxAsNeeded:allowance:%d\", allowance);\n\n        if (allowance < _neededAmount) {\n            console.log(\"__approveAssetMaxAsNeeded:before approve\");\n            if (allowance > 0) {\n                ERC20(_asset).approve(_target, 0);\n                console.log(\"__approveAssetMaxAsNeeded:approved 1\");\n            }\n            ERC20(_asset).approve(_target, type(uint256).max);\n            console.log(\"__approveAssetMaxAsNeeded:approved 2\");\n        }\n        console.log(\"__approveAssetMaxAsNeeded:approved 3\");\n    }\n\n    /// @dev Helper to transfer full asset balances from the current contract to a target\n    function __pushFullAssetBalances(address _target, address[] memory _assets)\n        internal\n        returns (uint256[] memory amountsTransferred_)\n    {\n        amountsTransferred_ = new uint256[](_assets.length);\n        for (uint256 i; i < _assets.length; i++) {\n            ERC20 assetContract = ERC20(_assets[i]);\n            amountsTransferred_[i] = assetContract.balanceOf(address(this));\n            if (amountsTransferred_[i] > 0) {\n                assetContract.safeTransfer(_target, amountsTransferred_[i]);\n            }\n        }\n\n        return amountsTransferred_;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/IIntegrationAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../IIntegrationManager.sol\";\n\n/// @title Integration Adapter interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all integration adapters\ninterface IIntegrationAdapter {\n    function parseAssetsForAction(\n        address _vaultProxy,\n        bytes4 _selector,\n        bytes calldata _encodedCallArgs\n    )\n        external\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        );\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/IntegrationSelectors.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IntegrationSelectors Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Selectors for integration actions\n/// @dev Selectors are created from their signatures rather than hardcoded for easy verification\nabstract contract IntegrationSelectors {\n    // Trading\n    bytes4 public constant TAKE_ORDER_SELECTOR = bytes4(\n        keccak256(\"takeOrder(address,bytes,bytes)\")\n    );\n\n    // Lending\n    bytes4 public constant LEND_SELECTOR = bytes4(keccak256(\"lend(address,bytes,bytes)\"));\n    bytes4 public constant REDEEM_SELECTOR = bytes4(keccak256(\"redeem(address,bytes,bytes)\"));\n\n    // Staking\n    bytes4 public constant STAKE_SELECTOR = bytes4(keccak256(\"stake(address,bytes,bytes)\"));\n    bytes4 public constant UNSTAKE_SELECTOR = bytes4(keccak256(\"unstake(address,bytes,bytes)\"));\n\n    // Rewards\n    bytes4 public constant CLAIM_REWARDS_SELECTOR = bytes4(\n        keccak256(\"claimRewards(address,bytes,bytes)\")\n    );\n\n    // Combined\n    bytes4 public constant LEND_AND_STAKE_SELECTOR = bytes4(\n        keccak256(\"lendAndStake(address,bytes,bytes)\")\n    );\n    bytes4 public constant UNSTAKE_AND_REDEEM_SELECTOR = bytes4(\n        keccak256(\"unstakeAndRedeem(address,bytes,bytes)\")\n    );\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2 <0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { size := extcodesize(account) }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n      return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/release/extensions/integration-manager/IIntegrationManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IIntegrationManager interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the IntegrationManager\ninterface IIntegrationManager {\n    enum SpendAssetsHandleType {None, Approve, Transfer}\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/ZeroExV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../utils/actions/ZeroExV2ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title ZeroExV2Adapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter to 0xV2 Exchange Contract\ncontract ZeroExV2Adapter is AdapterBase, FundDeployerOwnerMixin, ZeroExV2ActionsMixin {\n    event AllowedMakerAdded(address indexed account);\n\n    event AllowedMakerRemoved(address indexed account);\n\n    mapping(address => bool) private makerToIsAllowed;\n\n    // Gas could be optimized for the end-user by also storing an immutable ZRX_ASSET_DATA,\n    // for example, but in the narrow OTC use-case of this adapter, taker fees are unlikely.\n    constructor(\n        address _integrationManager,\n        address _exchange,\n        address _fundDeployer,\n        address[] memory _allowedMakers\n    )\n        public\n        AdapterBase(_integrationManager)\n        FundDeployerOwnerMixin(_fundDeployer)\n        ZeroExV2ActionsMixin(_exchange)\n    {\n        if (_allowedMakers.length > 0) {\n            __addAllowedMakers(_allowedMakers);\n        }\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Take an order on 0x\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            bytes memory encodedZeroExOrderArgs,\n            uint256 takerAssetFillAmount\n        ) = __decodeTakeOrderCallArgs(_actionData);\n\n        IZeroExV2.Order memory order = __constructOrderStruct(encodedZeroExOrderArgs);\n        (, , , bytes memory signature) = __decodeZeroExOrderArgs(encodedZeroExOrderArgs);\n\n        __zeroExV2TakeOrder(order, takerAssetFillAmount, signature);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        (\n            bytes memory encodedZeroExOrderArgs,\n            uint256 takerAssetFillAmount\n        ) = __decodeTakeOrderCallArgs(_actionData);\n        IZeroExV2.Order memory order = __constructOrderStruct(encodedZeroExOrderArgs);\n\n        require(\n            isAllowedMaker(order.makerAddress),\n            \"parseAssetsForAction: Order maker is not allowed\"\n        );\n        require(\n            takerAssetFillAmount <= order.takerAssetAmount,\n            \"parseAssetsForAction: Taker asset fill amount greater than available\"\n        );\n\n        address makerAsset = __getAssetAddress(order.makerAssetData);\n        address takerAsset = __getAssetAddress(order.takerAssetData);\n\n        // Format incoming assets\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = makerAsset;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = __calcRelativeQuantity(\n            order.takerAssetAmount,\n            order.makerAssetAmount,\n            takerAssetFillAmount\n        );\n\n        if (order.takerFee > 0) {\n            address takerFeeAsset = __getAssetAddress(\n                IZeroExV2(getZeroExV2Exchange()).ZRX_ASSET_DATA()\n            );\n            uint256 takerFeeFillAmount = __calcRelativeQuantity(\n                order.takerAssetAmount,\n                order.takerFee,\n                takerAssetFillAmount\n            ); // fee calculated relative to taker fill amount\n\n            if (takerFeeAsset == makerAsset) {\n                require(\n                    order.takerFee < order.makerAssetAmount,\n                    \"parseAssetsForAction: Fee greater than makerAssetAmount\"\n                );\n\n                spendAssets_ = new address[](1);\n                spendAssets_[0] = takerAsset;\n\n                spendAssetAmounts_ = new uint256[](1);\n                spendAssetAmounts_[0] = takerAssetFillAmount;\n\n                minIncomingAssetAmounts_[0] = minIncomingAssetAmounts_[0].sub(takerFeeFillAmount);\n            } else if (takerFeeAsset == takerAsset) {\n                spendAssets_ = new address[](1);\n                spendAssets_[0] = takerAsset;\n\n                spendAssetAmounts_ = new uint256[](1);\n                spendAssetAmounts_[0] = takerAssetFillAmount.add(takerFeeFillAmount);\n            } else {\n                spendAssets_ = new address[](2);\n                spendAssets_[0] = takerAsset;\n                spendAssets_[1] = takerFeeAsset;\n\n                spendAssetAmounts_ = new uint256[](2);\n                spendAssetAmounts_[0] = takerAssetFillAmount;\n                spendAssetAmounts_[1] = takerFeeFillAmount;\n            }\n        } else {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = takerAsset;\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = takerAssetFillAmount;\n        }\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Decode the parameters of a takeOrder call\n    /// @param _actionData Encoded parameters passed from client side\n    /// @return encodedZeroExOrderArgs_ Encoded args of the 0x order\n    /// @return takerAssetFillAmount_ Amount of taker asset to fill\n    function __decodeTakeOrderCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (bytes memory encodedZeroExOrderArgs_, uint256 takerAssetFillAmount_)\n    {\n        return abi.decode(_actionData, (bytes, uint256));\n    }\n\n    /////////////////////////////\n    // ALLOWED MAKERS REGISTRY //\n    /////////////////////////////\n\n    /// @notice Adds accounts to the list of allowed 0x order makers\n    /// @param _accountsToAdd Accounts to add\n    function addAllowedMakers(address[] calldata _accountsToAdd) external onlyFundDeployerOwner {\n        __addAllowedMakers(_accountsToAdd);\n    }\n\n    /// @notice Removes accounts from the list of allowed 0x order makers\n    /// @param _accountsToRemove Accounts to remove\n    function removeAllowedMakers(address[] calldata _accountsToRemove)\n        external\n        onlyFundDeployerOwner\n    {\n        require(_accountsToRemove.length > 0, \"removeAllowedMakers: Empty _accountsToRemove\");\n\n        for (uint256 i; i < _accountsToRemove.length; i++) {\n            require(\n                isAllowedMaker(_accountsToRemove[i]),\n                \"removeAllowedMakers: Account is not an allowed maker\"\n            );\n\n            makerToIsAllowed[_accountsToRemove[i]] = false;\n\n            emit AllowedMakerRemoved(_accountsToRemove[i]);\n        }\n    }\n\n    /// @dev Helper to add accounts to the list of allowed makers\n    function __addAllowedMakers(address[] memory _accountsToAdd) private {\n        require(_accountsToAdd.length > 0, \"__addAllowedMakers: Empty _accountsToAdd\");\n\n        for (uint256 i; i < _accountsToAdd.length; i++) {\n            require(!isAllowedMaker(_accountsToAdd[i]), \"__addAllowedMakers: Value already set\");\n\n            makerToIsAllowed[_accountsToAdd[i]] = true;\n\n            emit AllowedMakerAdded(_accountsToAdd[i]);\n        }\n    }\n\n    /// @dev Parses user inputs into a ZeroExV2.Order format\n    function __constructOrderStruct(bytes memory _encodedOrderArgs)\n        private\n        pure\n        returns (IZeroExV2.Order memory order_)\n    {\n        (\n            address[4] memory orderAddresses,\n            uint256[6] memory orderValues,\n            bytes[2] memory orderData,\n\n        ) = __decodeZeroExOrderArgs(_encodedOrderArgs);\n\n        return\n            IZeroExV2.Order({\n                makerAddress: orderAddresses[0],\n                takerAddress: orderAddresses[1],\n                feeRecipientAddress: orderAddresses[2],\n                senderAddress: orderAddresses[3],\n                makerAssetAmount: orderValues[0],\n                takerAssetAmount: orderValues[1],\n                makerFee: orderValues[2],\n                takerFee: orderValues[3],\n                expirationTimeSeconds: orderValues[4],\n                salt: orderValues[5],\n                makerAssetData: orderData[0],\n                takerAssetData: orderData[1]\n            });\n    }\n\n    /// @dev Decode the parameters of a 0x order\n    /// @param _encodedZeroExOrderArgs Encoded parameters of the 0x order\n    /// @return orderAddresses_ Addresses used in the order\n    /// - [0] 0x Order param: makerAddress\n    /// - [1] 0x Order param: takerAddress\n    /// - [2] 0x Order param: feeRecipientAddress\n    /// - [3] 0x Order param: senderAddress\n    /// @return orderValues_ Values used in the order\n    /// - [0] 0x Order param: makerAssetAmount\n    /// - [1] 0x Order param: takerAssetAmount\n    /// - [2] 0x Order param: makerFee\n    /// - [3] 0x Order param: takerFee\n    /// - [4] 0x Order param: expirationTimeSeconds\n    /// - [5] 0x Order param: salt\n    /// @return orderData_ Bytes data used in the order\n    /// - [0] 0x Order param: makerAssetData\n    /// - [1] 0x Order param: takerAssetData\n    /// @return signature_ Signature of the order\n    function __decodeZeroExOrderArgs(bytes memory _encodedZeroExOrderArgs)\n        private\n        pure\n        returns (\n            address[4] memory orderAddresses_,\n            uint256[6] memory orderValues_,\n            bytes[2] memory orderData_,\n            bytes memory signature_\n        )\n    {\n        return abi.decode(_encodedZeroExOrderArgs, (address[4], uint256[6], bytes[2], bytes));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Checks whether an account is an allowed maker of 0x orders\n    /// @param _who The account to check\n    /// @return isAllowedMaker_ True if _who is an allowed maker\n    function isAllowedMaker(address _who) public view returns (bool isAllowedMaker_) {\n        return makerToIsAllowed[_who];\n    }\n}\n"
    },
    "contracts/release/utils/FundDeployerOwnerMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../core/fund-deployer/IFundDeployer.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title FundDeployerOwnerMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\nabstract contract FundDeployerOwnerMixin {\n    address internal immutable FUND_DEPLOYER;\n\n    modifier onlyFundDeployerOwner() {\n        require(\n            msg.sender == getOwner(),\n            \"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\"\n        );\n        _;\n    }\n\n    constructor(address _fundDeployer) public {\n        FUND_DEPLOYER = _fundDeployer;\n    }\n\n    /// @notice Gets the owner of this contract\n    /// @return owner_ The owner\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\n    function getOwner() public view returns (address owner_) {\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FUND_DEPLOYER` variable\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\n    function getFundDeployer() public view returns (address fundDeployer_) {\n        console.log(\"FundDeployerOwnerMixin:getFundDeployer:%s\", FUND_DEPLOYER);\n        return FUND_DEPLOYER;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/ZeroExV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../../interfaces/IZeroExV2.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\nimport \"../../../../../utils/MathHelpers.sol\";\n\n/// @title ZeroExV2ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the ZeroExV2 exchange functions\nabstract contract ZeroExV2ActionsMixin is AssetHelpers, MathHelpers {\n    address private immutable ZERO_EX_V2_EXCHANGE;\n\n    constructor(address _exchange) public {\n        ZERO_EX_V2_EXCHANGE = _exchange;\n    }\n\n    /// @dev Helper to execute takeOrder\n    function __zeroExV2TakeOrder(\n        IZeroExV2.Order memory _order,\n        uint256 _takerAssetFillAmount,\n        bytes memory _signature\n    ) internal {\n        // Approve spend assets as needed\n        __approveAssetMaxAsNeeded(\n            __getAssetAddress(_order.takerAssetData),\n            __getAssetProxy(_order.takerAssetData),\n            _takerAssetFillAmount\n        );\n        // Ignores whether makerAsset or takerAsset overlap with the takerFee asset for simplicity\n        if (_order.takerFee > 0) {\n            bytes memory zrxData = IZeroExV2(ZERO_EX_V2_EXCHANGE).ZRX_ASSET_DATA();\n            __approveAssetMaxAsNeeded(\n                __getAssetAddress(zrxData),\n                __getAssetProxy(zrxData),\n                __calcRelativeQuantity(\n                    _order.takerAssetAmount,\n                    _order.takerFee,\n                    _takerAssetFillAmount\n                ) // fee calculated relative to taker fill amount\n            );\n        }\n\n        // Execute order\n        IZeroExV2(ZERO_EX_V2_EXCHANGE).fillOrder(_order, _takerAssetFillAmount, _signature);\n    }\n\n    /// @dev Parses the asset address from 0x assetData\n    function __getAssetAddress(bytes memory _assetData)\n        internal\n        pure\n        returns (address assetAddress_)\n    {\n        assembly {\n            assetAddress_ := mload(add(_assetData, 36))\n        }\n    }\n\n    /// @dev Gets the 0x assetProxy address for an ERC20 token\n    function __getAssetProxy(bytes memory _assetData) internal view returns (address assetProxy_) {\n        bytes4 assetProxyId;\n\n        assembly {\n            assetProxyId := and(\n                mload(add(_assetData, 32)),\n                0xFFFFFFFF00000000000000000000000000000000000000000000000000000000\n            )\n        }\n        assetProxy_ = IZeroExV2(getZeroExV2Exchange()).getAssetProxy(assetProxyId);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ZERO_EX_V2_EXCHANGE` variable value\n    /// @return zeroExV2Exchange_ The `ZERO_EX_V2_EXCHANGE` variable value\n    function getZeroExV2Exchange() public view returns (address zeroExV2Exchange_) {\n        return ZERO_EX_V2_EXCHANGE;\n    }\n}\n"
    },
    "contracts/release/core/fund-deployer/IFundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IFundDeployer Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IFundDeployer {\n    function getOwner() external view returns (address);\n\n    function hasReconfigurationRequest(address) external view returns (bool);\n\n    function isAllowedBuySharesOnBehalfCaller(address) external view returns (bool);\n\n    function isAllowedVaultCall(\n        address,\n        bytes4,\n        bytes32\n    ) external view returns (bool);\n\n    function createNewFund(\n        address _fundOwner,\n        string calldata _fundName,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external returns (address, address);\n\n    function getVaultLib() external view returns (address);\n\n    function getComptrollerLib() external view returns (address comptrollerLib_);\n}\n"
    },
    "contracts/release/interfaces/IZeroExV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @dev Minimal interface for our interactions with the ZeroEx Exchange contract\ninterface IZeroExV2 {\n    struct Order {\n        address makerAddress;\n        address takerAddress;\n        address feeRecipientAddress;\n        address senderAddress;\n        uint256 makerAssetAmount;\n        uint256 takerAssetAmount;\n        uint256 makerFee;\n        uint256 takerFee;\n        uint256 expirationTimeSeconds;\n        uint256 salt;\n        bytes makerAssetData;\n        bytes takerAssetData;\n    }\n\n    struct OrderInfo {\n        uint8 orderStatus;\n        bytes32 orderHash;\n        uint256 orderTakerAssetFilledAmount;\n    }\n\n    struct FillResults {\n        uint256 makerAssetFilledAmount;\n        uint256 takerAssetFilledAmount;\n        uint256 makerFeePaid;\n        uint256 takerFeePaid;\n    }\n\n    function ZRX_ASSET_DATA() external view returns (bytes memory);\n\n    function filled(bytes32) external view returns (uint256);\n\n    function cancelled(bytes32) external view returns (bool);\n\n    function getOrderInfo(Order calldata) external view returns (OrderInfo memory);\n\n    function getAssetProxy(bytes4) external view returns (address);\n\n    function isValidSignature(\n        bytes32,\n        address,\n        bytes calldata\n    ) external view returns (bool);\n\n    function preSign(\n        bytes32,\n        address,\n        bytes calldata\n    ) external;\n\n    function cancelOrder(Order calldata) external;\n\n    function fillOrder(\n        Order calldata,\n        uint256,\n        bytes calldata\n    ) external returns (FillResults memory);\n}\n"
    },
    "contracts/release/utils/MathHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n/// @title MathHelpers Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Helper functions for common math operations\nabstract contract MathHelpers {\n    using SafeMath for uint256;\n\n    /// @dev Calculates a proportional value relative to a known ratio.\n    /// Caller is responsible as-necessary for:\n    /// 1. validating _quantity1 to be non-zero\n    /// 2. validating relativeQuantity2_ to be non-zero\n    function __calcRelativeQuantity(\n        uint256 _quantity1,\n        uint256 _quantity2,\n        uint256 _relativeQuantity1\n    ) internal pure returns (uint256 relativeQuantity2_) {\n        return _relativeQuantity1.mul(_quantity2).div(_quantity1);\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/UniswapV2PoolPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../../interfaces/IUniswapV2Pair.sol\";\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../../../../utils/MathHelpers.sol\";\nimport \"../../../value-interpreter/ValueInterpreter.sol\";\nimport \"../../utils/UniswapV2PoolTokenValueCalculator.sol\";\nimport \"../IDerivativePriceFeed.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title UniswapV2PoolPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price feed for Uniswap lending pool tokens\ncontract UniswapV2PoolPriceFeed is\n    IDerivativePriceFeed,\n    FundDeployerOwnerMixin,\n    MathHelpers,\n    UniswapV2PoolTokenValueCalculator\n{\n    event PoolTokenAdded(address indexed poolToken, address token0, address token1);\n\n    struct PoolTokenInfo {\n        address token0;\n        address token1;\n        uint8 token0Decimals;\n        uint8 token1Decimals;\n    }\n\n    address private immutable FACTORY;\n    address private immutable VALUE_INTERPRETER;\n\n    mapping(address => PoolTokenInfo) private poolTokenToInfo;\n\n    constructor(\n        address _fundDeployer,\n        address _valueInterpreter,\n        address _factory\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        FACTORY = _factory;\n        VALUE_INTERPRETER = _valueInterpreter;\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        PoolTokenInfo memory poolTokenInfo = poolTokenToInfo[_derivative];\n\n        underlyings_ = new address[](2);\n        underlyings_[0] = poolTokenInfo.token0;\n        underlyings_[1] = poolTokenInfo.token1;\n\n        // Calculate the amounts underlying one unit of a pool token,\n        // taking into account the known, trusted rate between the two underlyings\n        (uint256 token0TrustedRateAmount, uint256 token1TrustedRateAmount) = __calcTrustedRate(\n            poolTokenInfo.token0,\n            poolTokenInfo.token1,\n            poolTokenInfo.token0Decimals,\n            poolTokenInfo.token1Decimals\n        );\n\n        (\n            uint256 token0DenormalizedRate,\n            uint256 token1DenormalizedRate\n        ) = __calcTrustedPoolTokenValue(\n            FACTORY,\n            _derivative,\n            token0TrustedRateAmount,\n            token1TrustedRateAmount\n        );\n\n        // Define normalized rates for each underlying\n        underlyingAmounts_ = new uint256[](2);\n        underlyingAmounts_[0] = _derivativeAmount.mul(token0DenormalizedRate).div(\n            UNISWAP_V2_POOL_TOKEN_UNIT\n        );\n        underlyingAmounts_[1] = _derivativeAmount.mul(token1DenormalizedRate).div(\n            UNISWAP_V2_POOL_TOKEN_UNIT\n        );\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return poolTokenToInfo[_asset].token0 != address(0);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Calculates the trusted rate of two assets based on our price feeds.\n    /// Uses the decimals-derived unit for whichever asset is used as the quote asset.\n    function __calcTrustedRate(\n        address _token0,\n        address _token1,\n        uint256 _token0Decimals,\n        uint256 _token1Decimals\n    ) private returns (uint256 token0RateAmount_, uint256 token1RateAmount_) {\n        // The quote asset of the value lookup must be a supported primitive asset,\n        // so we cycle through the tokens until reaching a primitive.\n        // If neither is a primitive, will revert at the ValueInterpreter\n        if (IValueInterpreter(VALUE_INTERPRETER).isSupportedPrimitiveAsset(_token0)) {\n            token1RateAmount_ = 10**_token1Decimals;\n            token0RateAmount_ = ValueInterpreter(VALUE_INTERPRETER).calcCanonicalAssetValue(\n                _token1,\n                token1RateAmount_,\n                _token0\n            );\n        } else {\n            token0RateAmount_ = 10**_token0Decimals;\n            token1RateAmount_ = ValueInterpreter(VALUE_INTERPRETER).calcCanonicalAssetValue(\n                _token0,\n                token0RateAmount_,\n                _token1\n            );\n        }\n\n        return (token0RateAmount_, token1RateAmount_);\n    }\n\n    //////////////////////////\n    // POOL TOKENS REGISTRY //\n    //////////////////////////\n\n    /// @notice Adds Uniswap pool tokens to the price feed\n    /// @param _poolTokens Uniswap pool tokens to add\n    function addPoolTokens(address[] calldata _poolTokens) external onlyFundDeployerOwner {\n        require(_poolTokens.length > 0, \"addPoolTokens: Empty _poolTokens\");\n\n        for (uint256 i; i < _poolTokens.length; i++) {\n            require(_poolTokens[i] != address(0), \"addPoolTokens: Empty poolToken\");\n            require(\n                poolTokenToInfo[_poolTokens[i]].token0 == address(0),\n                \"addPoolTokens: Value already set\"\n            );\n\n            IUniswapV2Pair uniswapV2Pair = IUniswapV2Pair(_poolTokens[i]);\n            address token0 = uniswapV2Pair.token0();\n            address token1 = uniswapV2Pair.token1();\n\n            require(\n                __poolTokenIsSupportable(token0, token1),\n                \"addPoolTokens: Unsupported pool token\"\n            );\n\n            poolTokenToInfo[_poolTokens[i]] = PoolTokenInfo({\n                token0: token0,\n                token1: token1,\n                token0Decimals: ERC20(token0).decimals(),\n                token1Decimals: ERC20(token1).decimals()\n            });\n\n            emit PoolTokenAdded(_poolTokens[i], token0, token1);\n        }\n    }\n\n    /// @dev Helper to determine if a pool token is supportable, based on whether price feeds are\n    /// available for its underlying feeds. At least one of the underlying tokens must be\n    /// a supported primitive asset, and the other must be a primitive or derivative.\n    function __poolTokenIsSupportable(address _token0, address _token1)\n        private\n        view\n        returns (bool isSupportable_)\n    {\n        console.log(\"__poolTokenIsSupportable: token0: %s\", _token0);\n        console.log(\"__poolTokenIsSupportable: token1: %s\", _token1);\n\n        IValueInterpreter valueInterpreterContract = IValueInterpreter(VALUE_INTERPRETER);\n\n        if (valueInterpreterContract.isSupportedPrimitiveAsset(_token0)) {\n            if (valueInterpreterContract.isSupportedAsset(_token1)) {\n                return true;\n            }\n        } else if (\n            valueInterpreterContract.isSupportedDerivativeAsset(_token0) &&\n            valueInterpreterContract.isSupportedPrimitiveAsset(_token1)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FACTORY` variable value\n    /// @return factory_ The `FACTORY` variable value\n    function getFactory() external view returns (address factory_) {\n        return FACTORY;\n    }\n\n    /// @notice Gets the `PoolTokenInfo` for a given pool token\n    /// @param _poolToken The pool token for which to get the `PoolTokenInfo`\n    /// @return poolTokenInfo_ The `PoolTokenInfo` value\n    function getPoolTokenInfo(address _poolToken)\n        external\n        view\n        returns (PoolTokenInfo memory poolTokenInfo_)\n    {\n        return poolTokenToInfo[_poolToken];\n    }\n\n    /// @notice Gets the underlyings for a given pool token\n    /// @param _poolToken The pool token for which to get its underlyings\n    /// @return token0_ The UniswapV2Pair.token0 value\n    /// @return token1_ The UniswapV2Pair.token1 value\n    function getPoolTokenUnderlyings(address _poolToken)\n        external\n        view\n        returns (address token0_, address token1_)\n    {\n        return (poolTokenToInfo[_poolToken].token0, poolTokenToInfo[_poolToken].token1);\n    }\n\n    /// @notice Gets the `VALUE_INTERPRETER` variable value\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getValueInterpreter() external view returns (address valueInterpreter_) {\n        return VALUE_INTERPRETER;\n    }\n}\n"
    },
    "contracts/release/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IUniswapV2Pair Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for our interactions with the Uniswap V2's Pair contract\ninterface IUniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (\n            uint112,\n            uint112,\n            uint32\n        );\n\n    function kLast() external view returns (uint256);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/release/infrastructure/value-interpreter/ValueInterpreter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../../utils/MathHelpers.sol\";\nimport \"../price-feeds/derivatives/AggregatedDerivativePriceFeedMixin.sol\";\nimport \"../price-feeds/derivatives/IDerivativePriceFeed.sol\";\nimport \"../price-feeds/primitives/ChainlinkPriceFeedMixin.sol\";\nimport \"./IValueInterpreter.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title ValueInterpreter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interprets price feeds to provide covert value between asset pairs\ncontract ValueInterpreter is\n    IValueInterpreter,\n    FundDeployerOwnerMixin,\n    AggregatedDerivativePriceFeedMixin,\n    ChainlinkPriceFeedMixin,\n    MathHelpers\n{\n    using SafeMath for uint256;\n\n    // Used to only tolerate a max rounding discrepancy of 0.01%\n    // when converting values via an inverse rate\n    uint256 private constant MIN_INVERSE_RATE_AMOUNT = 10000;\n\n    constructor(\n        address _fundDeployer,\n        address _wethToken,\n        uint256 _chainlinkStaleRateThreshold\n    )\n        public\n        FundDeployerOwnerMixin(_fundDeployer)\n        ChainlinkPriceFeedMixin(_wethToken, _chainlinkStaleRateThreshold)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the total value of given amounts of assets in a single quote asset\n    /// @param _baseAssets The assets to convert\n    /// @param _amounts The amounts of the _baseAssets to convert\n    /// @param _quoteAsset The asset to which to convert\n    /// @return value_ The sum value of _baseAssets, denominated in the _quoteAsset\n    /// @dev Does not alter protocol state,\n    /// but not a view because calls to price feeds can potentially update third party state.\n    /// Does not handle a derivative quote asset.\n    function calcCanonicalAssetsTotalValue(\n        address[] memory _baseAssets,\n        uint256[] memory _amounts,\n        address _quoteAsset\n    ) external override returns (uint256 value_) {\n        require(\n            _baseAssets.length == _amounts.length,\n            \"calcCanonicalAssetsTotalValue: Arrays unequal lengths\"\n        );\n        require(\n            isSupportedPrimitiveAsset(_quoteAsset),\n            \"calcCanonicalAssetsTotalValue: Unsupported _quoteAsset\"\n        );\n\n        for (uint256 i; i < _baseAssets.length; i++) {\n            uint256 assetValue = __calcAssetValue(_baseAssets[i], _amounts[i], _quoteAsset);\n            value_ = value_.add(assetValue);\n            console.log(\"calcCanonicalAssetsTotalValue:base asset : %s\", _baseAssets[i]);\n            console.log(\"calcCanonicalAssetsTotalValue:amount : %d\", _amounts[i]);\n            console.log(\"calcCanonicalAssetsTotalValue:quota asset : %s\", _quoteAsset);\n            console.log(\"calcCanonicalAssetsTotalValue:value : %d\", assetValue);\n        }\n\n        return value_;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Calculates the value of a given amount of one asset in terms of another asset\n    /// @param _baseAsset The asset from which to convert\n    /// @param _amount The amount of the _baseAsset to convert\n    /// @param _quoteAsset The asset to which to convert\n    /// @return value_ The equivalent quantity in the _quoteAsset\n    /// @dev Does not alter protocol state,\n    /// but not a view because calls to price feeds can potentially update third party state.\n    /// See also __calcPrimitiveToDerivativeValue() for important notes regarding a derivative _quoteAsset.\n    function calcCanonicalAssetValue(\n        address _baseAsset,\n        uint256 _amount,\n        address _quoteAsset\n    ) external override returns (uint256 value_) {\n        if (_baseAsset == _quoteAsset || _amount == 0) {\n            return _amount;\n        }\n\n        if (isSupportedPrimitiveAsset(_quoteAsset)) {\n            return __calcAssetValue(_baseAsset, _amount, _quoteAsset);\n        } else if (\n            isSupportedDerivativeAsset(_quoteAsset) && isSupportedPrimitiveAsset(_baseAsset)\n        ) {\n            return __calcPrimitiveToDerivativeValue(_baseAsset, _amount, _quoteAsset);\n        }\n\n        revert(\"calcCanonicalAssetValue: Unsupported conversion\");\n    }\n\n    /// @notice Checks whether an asset is a supported asset\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported asset\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return isSupportedPrimitiveAsset(_asset) || isSupportedDerivativeAsset(_asset);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to differentially calculate an asset value\n    /// based on if it is a primitive or derivative asset.\n    function __calcAssetValue(\n        address _baseAsset,\n        uint256 _amount,\n        address _quoteAsset\n    ) private returns (uint256 value_) {\n        if (_baseAsset == _quoteAsset || _amount == 0) {\n            return _amount;\n        }\n\n        // Handle case that asset is a primitive\n        if (isSupportedPrimitiveAsset(_baseAsset)) {\n            return __calcCanonicalValue(_baseAsset, _amount, _quoteAsset);\n        }\n\n        // Handle case that asset is a derivative\n        address derivativePriceFeed = getPriceFeedForDerivative(_baseAsset);\n        if (derivativePriceFeed != address(0)) {\n            return __calcDerivativeValue(derivativePriceFeed, _baseAsset, _amount, _quoteAsset);\n        }\n\n        revert(\"__calcAssetValue: Unsupported _baseAsset\");\n    }\n\n    /// @dev Helper to calculate the value of a derivative in an arbitrary asset.\n    /// Handles multiple underlying assets (e.g., Uniswap and Balancer pool tokens).\n    /// Handles underlying assets that are also derivatives (e.g., a cDAI-ETH LP)\n    function __calcDerivativeValue(\n        address _derivativePriceFeed,\n        address _derivative,\n        uint256 _amount,\n        address _quoteAsset\n    ) private returns (uint256 value_) {\n        (address[] memory underlyings, uint256[] memory underlyingAmounts) = IDerivativePriceFeed(\n            _derivativePriceFeed\n        )\n            .calcUnderlyingValues(_derivative, _amount);\n\n        require(underlyings.length > 0, \"__calcDerivativeValue: No underlyings\");\n        require(\n            underlyings.length == underlyingAmounts.length,\n            \"__calcDerivativeValue: Arrays unequal lengths\"\n        );\n\n        for (uint256 i = 0; i < underlyings.length; i++) {\n            uint256 underlyingValue = __calcAssetValue(\n                underlyings[i],\n                underlyingAmounts[i],\n                _quoteAsset\n            );\n\n            value_ = value_.add(underlyingValue);\n        }\n    }\n\n    /// @dev Helper to calculate the value of a primitive base asset in a derivative quote asset.\n    /// Assumes that the _primitiveBaseAsset and _derivativeQuoteAsset have been validated as supported.\n    /// Callers of this function should be aware of the following points, and take precautions as-needed,\n    /// such as prohibiting a derivative quote asset:\n    /// - The returned value will be slightly less the actual canonical value due to the conversion formula's\n    /// handling of the intermediate inverse rate (see comments below).\n    /// - If the assets involved have an extreme rate and/or have a low ERC20.decimals() value,\n    /// the inverse rate might not be considered \"sufficient\", and will revert.\n    function __calcPrimitiveToDerivativeValue(\n        address _primitiveBaseAsset,\n        uint256 _primitiveBaseAssetAmount,\n        address _derivativeQuoteAsset\n    ) private returns (uint256 value_) {\n        uint256 derivativeUnit = 10**uint256(ERC20(_derivativeQuoteAsset).decimals());\n\n        address derivativePriceFeed = getPriceFeedForDerivative(_derivativeQuoteAsset);\n        uint256 primitiveAmountForDerivativeUnit = __calcDerivativeValue(\n            derivativePriceFeed,\n            _derivativeQuoteAsset,\n            derivativeUnit,\n            _primitiveBaseAsset\n        );\n        // Only tolerate a max rounding discrepancy\n        require(\n            primitiveAmountForDerivativeUnit > MIN_INVERSE_RATE_AMOUNT,\n            \"__calcPrimitiveToDerivativeValue: Insufficient rate\"\n        );\n\n        // Adds `1` to primitiveAmountForDerivativeUnit so that the final return value is\n        // slightly less than the actual value, which is congruent with how all other\n        // asset conversions are floored in the protocol.\n        return\n            __calcRelativeQuantity(\n                primitiveAmountForDerivativeUnit.add(1),\n                derivativeUnit,\n                _primitiveBaseAssetAmount\n            );\n    }\n\n    ////////////////////////////\n    // PRIMITIVES (CHAINLINK) //\n    ////////////////////////////\n\n    /// @notice Adds a list of primitives with the given aggregator and rateAsset values\n    /// @param _primitives The primitives to add\n    /// @param _aggregators The ordered aggregators corresponding to the list of _primitives\n    /// @param _rateAssets The ordered rate assets corresponding to the list of _primitives\n    function addPrimitives(\n        address[] calldata _primitives,\n        address[] calldata _aggregators,\n        RateAsset[] calldata _rateAssets\n    ) external onlyFundDeployerOwner {\n        __addPrimitives(_primitives, _aggregators, _rateAssets);\n    }\n\n    /// @notice Removes a list of primitives from the feed\n    /// @param _primitives The primitives to remove\n    function removePrimitives(address[] calldata _primitives) external onlyFundDeployerOwner {\n        __removePrimitives(_primitives);\n    }\n\n    /// @notice Sets the `ehUsdAggregator` variable value\n    /// @param _nextEthUsdAggregator The `ehUsdAggregator` value to set\n    function setEthUsdAggregator(address _nextEthUsdAggregator) external onlyFundDeployerOwner {\n        __setEthUsdAggregator(_nextEthUsdAggregator);\n    }\n\n    /// @notice Updates a list of primitives with the given aggregator and rateAsset values\n    /// @param _primitives The primitives to update\n    /// @param _aggregators The ordered aggregators corresponding to the list of _primitives\n    /// @param _rateAssets The ordered rate assets corresponding to the list of _primitives\n    function updatePrimitives(\n        address[] calldata _primitives,\n        address[] calldata _aggregators,\n        RateAsset[] calldata _rateAssets\n    ) external onlyFundDeployerOwner {\n        __removePrimitives(_primitives);\n        __addPrimitives(_primitives, _aggregators, _rateAssets);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether an asset is a supported primitive\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported primitive\n    function isSupportedPrimitiveAsset(address _asset)\n        public\n        view\n        override\n        returns (bool isSupported_)\n    {\n        return _asset == getWethToken() || getAggregatorForPrimitive(_asset) != address(0);\n    }\n\n    ////////////////////////////////////\n    // DERIVATIVE PRICE FEED REGISTRY //\n    ////////////////////////////////////\n\n    /// @notice Adds a list of derivatives with the given price feed values\n    /// @param _derivatives The derivatives to add\n    /// @param _priceFeeds The ordered price feeds corresponding to the list of _derivatives\n    function addDerivatives(address[] calldata _derivatives, address[] calldata _priceFeeds)\n        external\n        onlyFundDeployerOwner\n    {\n        __addDerivatives(_derivatives, _priceFeeds);\n    }\n\n    /// @notice Removes a list of derivatives\n    /// @param _derivatives The derivatives to remove\n    function removeDerivatives(address[] calldata _derivatives) external onlyFundDeployerOwner {\n        __removeDerivatives(_derivatives);\n    }\n\n    /// @notice Updates a list of derivatives with the given price feed values\n    /// @param _derivatives The derivatives to update\n    /// @param _priceFeeds The ordered price feeds corresponding to the list of _derivatives\n    function updateDerivatives(address[] calldata _derivatives, address[] calldata _priceFeeds)\n        external\n        onlyFundDeployerOwner\n    {\n        __removeDerivatives(_derivatives);\n        __addDerivatives(_derivatives, _priceFeeds);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether an asset is a supported derivative\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported derivative\n    function isSupportedDerivativeAsset(address _asset)\n        public\n        view\n        override\n        returns (bool isSupported_)\n    {\n        return getPriceFeedForDerivative(_asset) != address(0);\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/utils/UniswapV2PoolTokenValueCalculator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../interfaces/IUniswapV2Factory.sol\";\nimport \"../../../interfaces/IUniswapV2Pair.sol\";\n\n/// @title UniswapV2PoolTokenValueCalculator Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Abstract contract for computing the value of Uniswap liquidity pool tokens\n/// @dev Unless otherwise noted, these functions are adapted to our needs and style guide from\n/// an un-merged Uniswap branch:\n/// https://github.com/Uniswap/uniswap-v2-periphery/blob/267ba44471f3357071a2fe2573fe4da42d5ad969/contracts/libraries/UniswapV2LiquidityMathLibrary.sol\nabstract contract UniswapV2PoolTokenValueCalculator {\n    using SafeMath for uint256;\n\n    uint256 internal constant UNISWAP_V2_POOL_TOKEN_UNIT = 10**18;\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Given a Uniswap pool with token0 and token1 and their trusted rate,\n    /// returns the value of one pool token unit in terms of token0 and token1.\n    /// This is the only function used outside of this contract.\n    function __calcTrustedPoolTokenValue(\n        address _factory,\n        address _pair,\n        uint256 _token0TrustedRateAmount,\n        uint256 _token1TrustedRateAmount\n    ) internal view returns (uint256 token0Amount_, uint256 token1Amount_) {\n        (uint256 reserve0, uint256 reserve1) = __calcReservesAfterArbitrage(\n            _pair,\n            _token0TrustedRateAmount,\n            _token1TrustedRateAmount\n        );\n\n        return __calcPoolTokenValue(_factory, _pair, reserve0, reserve1);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Computes liquidity value given all the parameters of the pair\n    function __calcPoolTokenValue(\n        address _factory,\n        address _pair,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) private view returns (uint256 token0Amount_, uint256 token1Amount_) {\n        IUniswapV2Pair pairContract = IUniswapV2Pair(_pair);\n        uint256 totalSupply = pairContract.totalSupply();\n\n        if (IUniswapV2Factory(_factory).feeTo() != address(0)) {\n            uint256 kLast = pairContract.kLast();\n            if (kLast > 0) {\n                uint256 rootK = __uniswapSqrt(_reserve0.mul(_reserve1));\n                uint256 rootKLast = __uniswapSqrt(kLast);\n                if (rootK > rootKLast) {\n                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));\n                    uint256 denominator = rootK.mul(5).add(rootKLast);\n                    uint256 feeLiquidity = numerator.div(denominator);\n                    totalSupply = totalSupply.add(feeLiquidity);\n                }\n            }\n        }\n        return (\n            _reserve0.mul(UNISWAP_V2_POOL_TOKEN_UNIT).div(totalSupply),\n            _reserve1.mul(UNISWAP_V2_POOL_TOKEN_UNIT).div(totalSupply)\n        );\n    }\n\n    /// @dev Calculates the direction and magnitude of the profit-maximizing trade\n    function __calcProfitMaximizingTrade(\n        uint256 _token0TrustedRateAmount,\n        uint256 _token1TrustedRateAmount,\n        uint256 _reserve0,\n        uint256 _reserve1\n    ) private pure returns (bool token0ToToken1_, uint256 amountIn_) {\n        token0ToToken1_ =\n            _reserve0.mul(_token1TrustedRateAmount).div(_reserve1) < _token0TrustedRateAmount;\n\n        uint256 leftSide;\n        uint256 rightSide;\n        if (token0ToToken1_) {\n            leftSide = __uniswapSqrt(\n                _reserve0.mul(_reserve1).mul(_token0TrustedRateAmount).mul(1000).div(\n                    _token1TrustedRateAmount.mul(997)\n                )\n            );\n            rightSide = _reserve0.mul(1000).div(997);\n        } else {\n            leftSide = __uniswapSqrt(\n                _reserve0.mul(_reserve1).mul(_token1TrustedRateAmount).mul(1000).div(\n                    _token0TrustedRateAmount.mul(997)\n                )\n            );\n            rightSide = _reserve1.mul(1000).div(997);\n        }\n\n        if (leftSide < rightSide) {\n            return (false, 0);\n        }\n\n        // Calculate the amount that must be sent to move the price to the profit-maximizing price\n        amountIn_ = leftSide.sub(rightSide);\n\n        return (token0ToToken1_, amountIn_);\n    }\n\n    /// @dev Calculates the pool reserves after an arbitrage moves the price to\n    /// the profit-maximizing rate, given an externally-observed trusted rate\n    /// between the two pooled assets\n    function __calcReservesAfterArbitrage(\n        address _pair,\n        uint256 _token0TrustedRateAmount,\n        uint256 _token1TrustedRateAmount\n    ) private view returns (uint256 reserve0_, uint256 reserve1_) {\n        (reserve0_, reserve1_, ) = IUniswapV2Pair(_pair).getReserves();\n\n        // Skip checking whether the reserve is 0, as this is extremely unlikely given how\n        // initial pool liquidity is locked, and since we maintain a list of registered pool tokens\n\n        // Calculate how much to swap to arb to the trusted price\n        (bool token0ToToken1, uint256 amountIn) = __calcProfitMaximizingTrade(\n            _token0TrustedRateAmount,\n            _token1TrustedRateAmount,\n            reserve0_,\n            reserve1_\n        );\n        if (amountIn == 0) {\n            return (reserve0_, reserve1_);\n        }\n\n        // Adjust the reserves to account for the arb trade to the trusted price\n        if (token0ToToken1) {\n            uint256 amountOut = __uniswapV2GetAmountOut(amountIn, reserve0_, reserve1_);\n            reserve0_ = reserve0_.add(amountIn);\n            reserve1_ = reserve1_.sub(amountOut);\n        } else {\n            uint256 amountOut = __uniswapV2GetAmountOut(amountIn, reserve1_, reserve0_);\n            reserve1_ = reserve1_.add(amountIn);\n            reserve0_ = reserve0_.sub(amountOut);\n        }\n\n        return (reserve0_, reserve1_);\n    }\n\n    /// @dev Uniswap square root function. See:\n    /// https://github.com/Uniswap/uniswap-lib/blob/6ddfedd5716ba85b905bf34d7f1f3c659101a1bc/contracts/libraries/Babylonian.sol\n    function __uniswapSqrt(uint256 _y) private pure returns (uint256 z_) {\n        if (_y > 3) {\n            z_ = _y;\n            uint256 x = _y / 2 + 1;\n            while (x < z_) {\n                z_ = x;\n                x = (_y / x + x) / 2;\n            }\n        } else if (_y != 0) {\n            z_ = 1;\n        }\n        // else z_ = 0\n\n        return z_;\n    }\n\n    /// @dev Simplified version of UniswapV2Library's getAmountOut() function. See:\n    /// https://github.com/Uniswap/uniswap-v2-periphery/blob/87edfdcaf49ccc52591502993db4c8c08ea9eec0/contracts/libraries/UniswapV2Library.sol#L42-L50\n    function __uniswapV2GetAmountOut(\n        uint256 _amountIn,\n        uint256 _reserveIn,\n        uint256 _reserveOut\n    ) private pure returns (uint256 amountOut_) {\n        uint256 amountInWithFee = _amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(_reserveOut);\n        uint256 denominator = _reserveIn.mul(1000).add(amountInWithFee);\n\n        return numerator.div(denominator);\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/IDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDerivativePriceFeed Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Simple interface for derivative price source oracle implementations\ninterface IDerivativePriceFeed {\n    function calcUnderlyingValues(address, uint256)\n        external\n        returns (address[] memory, uint256[] memory);\n\n    function isSupportedAsset(address) external view returns (bool);\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/AggregatedDerivativePriceFeedMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IDerivativePriceFeed.sol\";\n\n/// @title AggregatedDerivativePriceFeedMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Aggregates multiple derivative price feeds (e.g., Compound, Chai) and dispatches\n/// rate requests to the appropriate feed\nabstract contract AggregatedDerivativePriceFeedMixin {\n    event DerivativeAdded(address indexed derivative, address priceFeed);\n\n    event DerivativeRemoved(address indexed derivative);\n\n    mapping(address => address) private derivativeToPriceFeed;\n\n    /// @notice Gets the rates for 1 unit of the derivative to its underlying assets\n    /// @param _derivative The derivative for which to get the rates\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The rates for the _derivative to the underlyings_\n    function __calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        internal\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        address derivativePriceFeed = getPriceFeedForDerivative(_derivative);\n        require(\n            derivativePriceFeed != address(0),\n            \"calcUnderlyingValues: _derivative is not supported\"\n        );\n\n        return\n            IDerivativePriceFeed(derivativePriceFeed).calcUnderlyingValues(\n                _derivative,\n                _derivativeAmount\n            );\n    }\n\n    //////////////////////////\n    // DERIVATIVES REGISTRY //\n    //////////////////////////\n\n    /// @notice Adds a list of derivatives with the given price feed values\n    /// @param _derivatives The derivatives to add\n    /// @param _priceFeeds The ordered price feeds corresponding to the list of _derivatives\n    function __addDerivatives(address[] memory _derivatives, address[] memory _priceFeeds)\n        internal\n    {\n        require(\n            _derivatives.length == _priceFeeds.length,\n            \"__addDerivatives: Unequal _derivatives and _priceFeeds array lengths\"\n        );\n\n        for (uint256 i = 0; i < _derivatives.length; i++) {\n            require(\n                getPriceFeedForDerivative(_derivatives[i]) == address(0),\n                \"__addDerivatives: Already added\"\n            );\n\n            __validateDerivativePriceFeed(_derivatives[i], _priceFeeds[i]);\n\n            derivativeToPriceFeed[_derivatives[i]] = _priceFeeds[i];\n\n            emit DerivativeAdded(_derivatives[i], _priceFeeds[i]);\n        }\n    }\n\n    /// @notice Removes a list of derivatives\n    /// @param _derivatives The derivatives to remove\n    function __removeDerivatives(address[] memory _derivatives) internal {\n        for (uint256 i = 0; i < _derivatives.length; i++) {\n            require(\n                getPriceFeedForDerivative(_derivatives[i]) != address(0),\n                \"removeDerivatives: Derivative not yet added\"\n            );\n\n            delete derivativeToPriceFeed[_derivatives[i]];\n\n            emit DerivativeRemoved(_derivatives[i]);\n        }\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to validate a derivative price feed\n    function __validateDerivativePriceFeed(address _derivative, address _priceFeed) private view {\n        require(\n            IDerivativePriceFeed(_priceFeed).isSupportedAsset(_derivative),\n            \"__validateDerivativePriceFeed: Unsupported derivative\"\n        );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the registered price feed for a given derivative\n    /// @return priceFeed_ The price feed contract address\n    function getPriceFeedForDerivative(address _derivative)\n        public\n        view\n        returns (address priceFeed_)\n    {\n        return derivativeToPriceFeed[_derivative];\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/primitives/ChainlinkPriceFeedMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../interfaces/IChainlinkAggregator.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title ChainlinkPriceFeedMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A price feed that uses Chainlink oracles as price sources\nabstract contract ChainlinkPriceFeedMixin {\n    using SafeMath for uint256;\n\n    event EthUsdAggregatorSet(address prevEthUsdAggregator, address nextEthUsdAggregator);\n\n    event PrimitiveAdded(\n        address indexed primitive,\n        address aggregator,\n        RateAsset rateAsset,\n        uint256 unit\n    );\n\n    event PrimitiveRemoved(address indexed primitive);\n\n    enum RateAsset {ETH, USD}\n\n    struct AggregatorInfo {\n        address aggregator;\n        RateAsset rateAsset;\n    }\n\n    uint256 private constant ETH_UNIT = 10**18;\n\n    uint256 private immutable STALE_RATE_THRESHOLD;\n    address private immutable WETH_TOKEN;\n\n    address private ethUsdAggregator;\n    mapping(address => AggregatorInfo) private primitiveToAggregatorInfo;\n    mapping(address => uint256) private primitiveToUnit;\n\n    constructor(address _wethToken, uint256 _staleRateThreshold) public {\n        STALE_RATE_THRESHOLD = _staleRateThreshold;\n        WETH_TOKEN = _wethToken;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @notice Calculates the value of a base asset in terms of a quote asset (using a canonical rate)\n    /// @param _baseAsset The base asset\n    /// @param _baseAssetAmount The base asset amount to convert\n    /// @param _quoteAsset The quote asset\n    /// @return quoteAssetAmount_ The equivalent quote asset amount\n    function __calcCanonicalValue(\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        address _quoteAsset\n    ) internal view returns (uint256 quoteAssetAmount_) {\n        // Case where _baseAsset == _quoteAsset is handled by ValueInterpreter\n\n        int256 baseAssetRate = __getLatestRateData(_baseAsset);\n        require(baseAssetRate > 0, \"__calcCanonicalValue: Invalid base asset rate\");\n\n        int256 quoteAssetRate = __getLatestRateData(_quoteAsset);\n        require(quoteAssetRate > 0, \"__calcCanonicalValue: Invalid quote asset rate\");\n\n        return\n            __calcConversionAmount(\n                _baseAsset,\n                _baseAssetAmount,\n                uint256(baseAssetRate),\n                _quoteAsset,\n                uint256(quoteAssetRate)\n            );\n    }\n\n    /// @dev Helper to set the `ethUsdAggregator` value\n    function __setEthUsdAggregator(address _nextEthUsdAggregator) internal {\n        address prevEthUsdAggregator = getEthUsdAggregator();\n        require(\n            _nextEthUsdAggregator != prevEthUsdAggregator,\n            \"__setEthUsdAggregator: Value already set\"\n        );\n\n        __validateAggregator(_nextEthUsdAggregator);\n\n        ethUsdAggregator = _nextEthUsdAggregator;\n\n        emit EthUsdAggregatorSet(prevEthUsdAggregator, _nextEthUsdAggregator);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to convert an amount from a _baseAsset to a _quoteAsset\n    function __calcConversionAmount(\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetRate,\n        address _quoteAsset,\n        uint256 _quoteAssetRate\n    ) private view returns (uint256 quoteAssetAmount_) {\n        RateAsset baseAssetRateAsset = getRateAssetForPrimitive(_baseAsset);\n        RateAsset quoteAssetRateAsset = getRateAssetForPrimitive(_quoteAsset);\n        uint256 baseAssetUnit = getUnitForPrimitive(_baseAsset);\n        uint256 quoteAssetUnit = getUnitForPrimitive(_quoteAsset);\n\n        // If rates are both in ETH or both in USD\n        if (baseAssetRateAsset == quoteAssetRateAsset) {\n            return\n                __calcConversionAmountSameRateAsset(\n                    _baseAssetAmount,\n                    baseAssetUnit,\n                    _baseAssetRate,\n                    quoteAssetUnit,\n                    _quoteAssetRate\n                );\n        }\n\n        (, int256 ethPerUsdRate, , uint256 ethPerUsdRateLastUpdatedAt, ) = IChainlinkAggregator(\n            getEthUsdAggregator()\n        )\n            .latestRoundData();\n        require(ethPerUsdRate > 0, \"__calcConversionAmount: Bad ethUsd rate\");\n        __validateRateIsNotStale(ethPerUsdRateLastUpdatedAt);\n\n        // If _baseAsset's rate is in ETH and _quoteAsset's rate is in USD\n        if (baseAssetRateAsset == RateAsset.ETH) {\n            return\n                __calcConversionAmountEthRateAssetToUsdRateAsset(\n                    _baseAssetAmount,\n                    baseAssetUnit,\n                    _baseAssetRate,\n                    quoteAssetUnit,\n                    _quoteAssetRate,\n                    uint256(ethPerUsdRate)\n                );\n        }\n\n        // If _baseAsset's rate is in USD and _quoteAsset's rate is in ETH\n        return\n            __calcConversionAmountUsdRateAssetToEthRateAsset(\n                _baseAssetAmount,\n                baseAssetUnit,\n                _baseAssetRate,\n                quoteAssetUnit,\n                _quoteAssetRate,\n                uint256(ethPerUsdRate)\n            );\n    }\n\n    /// @dev Helper to convert amounts where the base asset has an ETH rate and the quote asset has a USD rate\n    function __calcConversionAmountEthRateAssetToUsdRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate,\n        uint256 _ethPerUsdRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow.\n        // Intermediate step needed to resolve stack-too-deep error.\n        uint256 intermediateStep = _baseAssetAmount.mul(_baseAssetRate).mul(_ethPerUsdRate).div(\n            ETH_UNIT\n        );\n\n        return intermediateStep.mul(_quoteAssetUnit).div(_baseAssetUnit).div(_quoteAssetRate);\n    }\n\n    /// @dev Helper to convert amounts where base and quote assets both have ETH rates or both have USD rates\n    function __calcConversionAmountSameRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow\n        return\n            _baseAssetAmount.mul(_baseAssetRate).mul(_quoteAssetUnit).div(\n                _baseAssetUnit.mul(_quoteAssetRate)\n            );\n    }\n\n    /// @dev Helper to convert amounts where the base asset has a USD rate and the quote asset has an ETH rate\n    function __calcConversionAmountUsdRateAssetToEthRateAsset(\n        uint256 _baseAssetAmount,\n        uint256 _baseAssetUnit,\n        uint256 _baseAssetRate,\n        uint256 _quoteAssetUnit,\n        uint256 _quoteAssetRate,\n        uint256 _ethPerUsdRate\n    ) private pure returns (uint256 quoteAssetAmount_) {\n        // Only allows two consecutive multiplication operations to avoid potential overflow\n        // Intermediate step needed to resolve stack-too-deep error.\n        uint256 intermediateStep = _baseAssetAmount.mul(_baseAssetRate).mul(_quoteAssetUnit).div(\n            _ethPerUsdRate\n        );\n\n        return intermediateStep.mul(ETH_UNIT).div(_baseAssetUnit).div(_quoteAssetRate);\n    }\n\n    /// @dev Helper to get the latest rate for a given primitive\n    function __getLatestRateData(address _primitive) private view returns (int256 rate_) {\n        if (_primitive == getWethToken()) {\n            return int256(ETH_UNIT);\n        }\n\n        address aggregator = getAggregatorForPrimitive(_primitive);\n        require(aggregator != address(0), \"__getLatestRateData: Primitive does not exist\");\n\n        uint256 rateUpdatedAt;\n        (, rate_, , rateUpdatedAt, ) = IChainlinkAggregator(aggregator).latestRoundData();\n        __validateRateIsNotStale(rateUpdatedAt);\n\n        return rate_;\n    }\n\n    /// @dev Helper to validate that a rate is not from a round considered to be stale\n    function __validateRateIsNotStale(uint256 _latestUpdatedAt) private view {\n        require(\n            _latestUpdatedAt >= block.timestamp.sub(getStaleRateThreshold()),\n            \"__validateRateIsNotStale: Stale rate detected\"\n        );\n    }\n\n    /////////////////////////\n    // PRIMITIVES REGISTRY //\n    /////////////////////////\n\n    /// @notice Adds a list of primitives with the given aggregator and rateAsset values\n    /// @param _primitives The primitives to add\n    /// @param _aggregators The ordered aggregators corresponding to the list of _primitives\n    /// @param _rateAssets The ordered rate assets corresponding to the list of _primitives\n    function __addPrimitives(\n        address[] calldata _primitives,\n        address[] calldata _aggregators,\n        RateAsset[] calldata _rateAssets\n    ) internal {\n        require(\n            _primitives.length == _aggregators.length,\n            \"__addPrimitives: Unequal _primitives and _aggregators array lengths\"\n        );\n        require(\n            _primitives.length == _rateAssets.length,\n            \"__addPrimitives: Unequal _primitives and _rateAssets array lengths\"\n        );\n\n        for (uint256 i; i < _primitives.length; i++) {\n            require(\n                getAggregatorForPrimitive(_primitives[i]) == address(0),\n                \"__addPrimitives: Value already set\"\n            );\n\n            console.log(\"before __validateAggregator:%s\", _aggregators[i]);\n            __validateAggregator(_aggregators[i]);\n            console.log(\"after __validateAggregator:%s\", _aggregators[i]);\n\n            primitiveToAggregatorInfo[_primitives[i]] = AggregatorInfo({\n                aggregator: _aggregators[i],\n                rateAsset: _rateAssets[i]\n            });\n            console.log(\"after __validateAggregator AggregatorInfo :%s\", _aggregators[i]);\n            // Store the amount that makes up 1 unit given the asset's decimals\n            uint256 unit = 10**uint256(ERC20(_primitives[i]).decimals());\n            console.log(\"after __validateAggregator ERC20 :%s\", _aggregators[i]);\n            primitiveToUnit[_primitives[i]] = unit;\n\n            emit PrimitiveAdded(_primitives[i], _aggregators[i], _rateAssets[i], unit);\n        }\n    }\n\n    /// @notice Removes a list of primitives from the feed\n    /// @param _primitives The primitives to remove\n    function __removePrimitives(address[] calldata _primitives) internal {\n        for (uint256 i; i < _primitives.length; i++) {\n            require(\n                getAggregatorForPrimitive(_primitives[i]) != address(0),\n                \"__removePrimitives: Primitive not yet added\"\n            );\n\n            delete primitiveToAggregatorInfo[_primitives[i]];\n            delete primitiveToUnit[_primitives[i]];\n\n            emit PrimitiveRemoved(_primitives[i]);\n        }\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to validate an aggregator by checking its return values for the expected interface\n    function __validateAggregator(address _aggregator) private view {\n        (, int256 answer, , uint256 updatedAt, ) = IChainlinkAggregator(_aggregator)\n            .latestRoundData();\n        require(answer > 0, \"__validateAggregator: No rate detected\");\n        __validateRateIsNotStale(updatedAt);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the aggregator for a primitive\n    /// @param _primitive The primitive asset for which to get the aggregator value\n    /// @return aggregator_ The aggregator address\n    function getAggregatorForPrimitive(address _primitive)\n        public\n        view\n        returns (address aggregator_)\n    {\n        return primitiveToAggregatorInfo[_primitive].aggregator;\n    }\n\n    /// @notice Gets the `ethUsdAggregator` variable value\n    /// @return ethUsdAggregator_ The `ethUsdAggregator` variable value\n    function getEthUsdAggregator() public view returns (address ethUsdAggregator_) {\n        return ethUsdAggregator;\n    }\n\n    /// @notice Gets the rateAsset variable value for a primitive\n    /// @return rateAsset_ The rateAsset variable value\n    /// @dev This isn't strictly necessary as WETH_TOKEN will be undefined and thus\n    /// the RateAsset will be the 0-position of the enum (i.e. ETH), but it makes the\n    /// behavior more explicit\n    function getRateAssetForPrimitive(address _primitive)\n        public\n        view\n        returns (RateAsset rateAsset_)\n    {\n        if (_primitive == getWethToken()) {\n            return RateAsset.ETH;\n        }\n\n        return primitiveToAggregatorInfo[_primitive].rateAsset;\n    }\n\n    /// @notice Gets the `STALE_RATE_THRESHOLD` variable value\n    /// @return staleRateThreshold_ The `STALE_RATE_THRESHOLD` value\n    function getStaleRateThreshold() public view returns (uint256 staleRateThreshold_) {\n        return STALE_RATE_THRESHOLD;\n    }\n\n    /// @notice Gets the unit variable value for a primitive\n    /// @return unit_ The unit variable value\n    function getUnitForPrimitive(address _primitive) public view returns (uint256 unit_) {\n        if (_primitive == getWethToken()) {\n            return ETH_UNIT;\n        }\n\n        return primitiveToUnit[_primitive];\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable value\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/infrastructure/value-interpreter/IValueInterpreter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IValueInterpreter interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for ValueInterpreter\ninterface IValueInterpreter {\n    function calcCanonicalAssetValue(\n        address,\n        uint256,\n        address\n    ) external returns (uint256);\n\n    function calcCanonicalAssetsTotalValue(\n        address[] calldata,\n        uint256[] calldata,\n        address\n    ) external returns (uint256);\n\n    function isSupportedAsset(address) external view returns (bool);\n\n    function isSupportedDerivativeAsset(address) external view returns (bool);\n\n    function isSupportedPrimitiveAsset(address) external view returns (bool);\n}\n"
    },
    "contracts/release/interfaces/IChainlinkAggregator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IChainlinkAggregator Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IChainlinkAggregator {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        );\n}\n"
    },
    "contracts/release/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IUniswapV2Factory Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for our interactions with the Uniswap V2's Factory contract\ninterface IUniswapV2Factory {\n    function feeTo() external view returns (address);\n\n    function getPair(address, address) external view returns (address);\n}\n"
    },
    "contracts/release/off-chain/FundValueCalculator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../persistent/off-chain/fund-value-calculator/IFundValueCalculator.sol\";\nimport \"../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../core/fund/vault/VaultLib.sol\";\nimport \"../extensions/fee-manager/FeeManager.sol\";\nimport \"../infrastructure/protocol-fees/ProtocolFeeTracker.sol\";\nimport \"../infrastructure/value-interpreter/ValueInterpreter.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title FundValueCalculator Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A peripheral contract for serving fund value calculation requests from the FundValueCalculatorRouter\n/// @dev These are convenience functions intended for off-chain consumption,\n/// some of which involve potentially expensive state transitions.\n/// Does not take into account asset finality (e.g., Synths).\ncontract FundValueCalculator is IFundValueCalculator {\n    using SafeMath for uint256;\n\n    // Protocol fee-related constants, taken from ProtocolFeeTracker.sol\n    uint256 private constant MAX_BPS = 10000;\n    uint256 private constant SECONDS_IN_YEAR = 31557600; // 60*60*24*365.25\n    // Protocol fee-related constants, taken from ProtocolFeeReserveLib.sol\n    uint256 private constant BUYBACK_DISCOUNT_DIVISOR = 2;\n\n    // Shares-related constants\n    uint256 private constant SHARES_UNIT = 10**18;\n\n    address private immutable FEE_MANAGER;\n    address private immutable PROTOCOL_FEE_TRACKER;\n    address private immutable VALUE_INTERPRETER;\n\n    constructor(\n        address _feeManager,\n        address _protocolFeeTracker,\n        address _valueInterpreter\n    ) public {\n        FEE_MANAGER = _feeManager;\n        PROTOCOL_FEE_TRACKER = _protocolFeeTracker;\n        VALUE_INTERPRETER = _valueInterpreter;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the GAV for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return gav_ The GAV quoted in _quoteAsset\n    function calcGavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        override\n        returns (uint256 gav_)\n    {\n        (address denominationAsset, uint256 valueInDenominationAsset) = calcGav(_vaultProxy);\n\n        return\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAsset,\n                valueInDenominationAsset,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the gross value of one shares unit (10 ** 18) for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return grossShareValue_ The gross share value quoted in _quoteAsset\n    function calcGrossShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        override\n        returns (uint256 grossShareValue_)\n    {\n        (address denominationAsset, uint256 valueInDenominationAsset) = calcGrossShareValue(\n            _vaultProxy\n        );\n\n        return\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAsset,\n                valueInDenominationAsset,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the NAV for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return nav_ The NAV quoted in _quoteAsset\n    function calcNavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        override\n        returns (uint256 nav_)\n    {\n        (address denominationAsset, uint256 valueInDenominationAsset) = calcNav(_vaultProxy);\n\n        return\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAsset,\n                valueInDenominationAsset,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the net value of one shares unit (10 ** 18) for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return netShareValue_ The net share value quoted in _quoteAsset\n    function calcNetShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        override\n        returns (uint256 netShareValue_)\n    {\n        (address denominationAsset, uint256 valueInDenominationAsset) = calcNetShareValue(\n            _vaultProxy\n        );\n\n        return\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAsset,\n                valueInDenominationAsset,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the net value of all shares held by a specified account, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _sharesHolder The account holding shares\n    /// @param _quoteAsset The quote asset\n    /// @return netValue_ The net value of all shares held by _sharesHolder quoted in _quoteAsset\n    function calcNetValueForSharesHolderInAsset(\n        address _vaultProxy,\n        address _sharesHolder,\n        address _quoteAsset\n    ) external override returns (uint256 netValue_) {\n        (\n            address denominationAsset,\n            uint256 valueInDenominationAsset\n        ) = calcNetValueForSharesHolder(_vaultProxy, _sharesHolder);\n\n        return\n            ValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAsset,\n                valueInDenominationAsset,\n                _quoteAsset\n            );\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Calculates the GAV for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return gav_ The GAV quoted in the denomination asset\n    function calcGav(address _vaultProxy)\n        public\n        override\n        returns (address denominationAsset_, uint256 gav_)\n    {\n        ComptrollerLib comptrollerProxyContract = __getComptrollerProxyForVault(_vaultProxy);\n\n        return (\n            comptrollerProxyContract.getDenominationAsset(),\n            comptrollerProxyContract.calcGav(false)\n        );\n    }\n\n    /// @notice Calculates the gross value of one shares unit (10 ** 18) for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return grossShareValue_ The gross share value quoted in the denomination asset\n    function calcGrossShareValue(address _vaultProxy)\n        public\n        override\n        returns (address denominationAsset_, uint256 grossShareValue_)\n    {\n        ComptrollerLib comptrollerProxyContract = __getComptrollerProxyForVault(_vaultProxy);\n\n        return (\n            comptrollerProxyContract.getDenominationAsset(),\n            comptrollerProxyContract.calcGrossShareValue(false)\n        );\n    }\n\n    /// @notice Calculates the NAV for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return nav_ The NAV quoted in the denomination asset\n    /// @dev This value should only be consumed from off-chain,\n    /// as the NAV is only valid for the shares quantity prior to the settlement of fees,\n    /// and this function actually settles fund-level fees, so the NAV would no longer be valid\n    function calcNav(address _vaultProxy)\n        public\n        override\n        returns (address denominationAsset_, uint256 nav_)\n    {\n        uint256 preSharesSupply = ERC20(_vaultProxy).totalSupply();\n\n        uint256 netShareValue;\n        (denominationAsset_, netShareValue) = calcNetShareValue(_vaultProxy);\n\n        nav_ = preSharesSupply.mul(netShareValue).div(SHARES_UNIT);\n\n        return (denominationAsset_, nav_);\n    }\n\n    /// @notice Calculates the net value of one shares unit (10 ** 18) for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return netShareValue_ The net share value quoted in the denomination asset\n    function calcNetShareValue(address _vaultProxy)\n        public\n        override\n        returns (address denominationAsset_, uint256 netShareValue_)\n    {\n        ComptrollerLib comptrollerProxyContract = __getComptrollerProxyForVault(_vaultProxy);\n\n        // Settle Continuous fees\n        comptrollerProxyContract.callOnExtension(getFeeManager(), 0, \"\");\n\n        // Calculate protocol fee shares due\n        uint256 protocolFeeSharesDue = calcProtocolFeeDueForFund(_vaultProxy);\n\n        denominationAsset_ = comptrollerProxyContract.getDenominationAsset();\n        netShareValue_ = __calcShareValue(\n            denominationAsset_,\n            comptrollerProxyContract.calcGav(false),\n            ERC20(_vaultProxy).totalSupply().add(protocolFeeSharesDue)\n        );\n\n        return (denominationAsset_, netShareValue_);\n    }\n\n    /// @notice Calculates the net value of all shares held by a specified account\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _sharesHolder The account holding shares\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return netValue_ The net value of all shares held by _sharesHolder\n    function calcNetValueForSharesHolder(address _vaultProxy, address _sharesHolder)\n        public\n        override\n        returns (address denominationAsset_, uint256 netValue_)\n    {\n        // Does not account for any new shares accrued to the _sharesHolder during calcs\n        uint256 sharesHolderBalance = ERC20(_vaultProxy).balanceOf(_sharesHolder);\n        console.log(\"calcNetValueForSharesHolder:sharesHolderBalance:%d\", sharesHolderBalance);\n\n        uint256 netShareValue;\n        (denominationAsset_, netShareValue) = calcNetShareValue(_vaultProxy);\n        console.log(\"calcNetValueForSharesHolder:denominationAsset_:%s\", denominationAsset_);\n        console.log(\"calcNetValueForSharesHolder:netShareValue:%d\", netShareValue);\n\n        netValue_ = sharesHolderBalance.mul(netShareValue).div(SHARES_UNIT);\n\n        console.log(\"calcNetValueForSharesHolder:netValue_:%d\", netValue_);\n\n        return (denominationAsset_, netValue_);\n    }\n\n    /// @notice Calculates the protocol fee shares currently due for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return sharesDue_ The protocol fee shares due\n    /// @dev Mostly copy-paste from ProtocolFeeTracker.payFee() and its helpers.\n    /// Includes the 50% buyback discount.\n    function calcProtocolFeeDueForFund(address _vaultProxy)\n        public\n        view\n        returns (uint256 sharesDue_)\n    {\n        // 1. Calc seconds since last payment\n        uint256 lastPaid = ProtocolFeeTracker(getProtocolFeeTracker()).getLastPaidForVault(\n            _vaultProxy\n        );\n        if (lastPaid >= block.timestamp || lastPaid == 0) {\n            return 0;\n        }\n\n        uint256 secondsDue = block.timestamp.sub(lastPaid);\n\n        // 2. Calc shares due as a proportion of annualized fee bps\n        uint256 sharesSupply = ERC20(_vaultProxy).totalSupply();\n\n        uint256 rawSharesDue = sharesSupply\n            .mul(ProtocolFeeTracker(getProtocolFeeTracker()).getFeeBpsForVault(_vaultProxy))\n            .mul(secondsDue)\n            .div(SECONDS_IN_YEAR)\n            .div(MAX_BPS);\n\n        uint256 supplyNetRawSharesDue = sharesSupply.sub(rawSharesDue);\n        if (supplyNetRawSharesDue == 0) {\n            return 0;\n        }\n\n        return\n            rawSharesDue.mul(sharesSupply).div(supplyNetRawSharesDue).div(\n                BUYBACK_DISCOUNT_DIVISOR\n            );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper for calculating the share value\n    function __calcShareValue(\n        address _denominationAsset,\n        uint256 _assetsValue,\n        uint256 _sharesSupply\n    ) private view returns (uint256 shareValue_) {\n        if (_sharesSupply == 0) {\n            return 10**uint256(ERC20(_denominationAsset).decimals());\n        }\n\n        return _assetsValue.mul(SHARES_UNIT).div(_sharesSupply);\n    }\n\n    /// @dev Helper to get the ComptrollerProxy for a given VaultProxy\n    function __getComptrollerProxyForVault(address _vaultProxy)\n        private\n        view\n        returns (ComptrollerLib comptrollerProxyContract_)\n    {\n        return ComptrollerLib(VaultLib(payable(_vaultProxy)).getAccessor());\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FEE_MANAGER` variable\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    function getFeeManager() public view returns (address feeManager_) {\n        return FEE_MANAGER;\n    }\n\n    /// @notice Gets the `PROTOCOL_FEE_TRACKER` variable\n    /// @return protocolFeeTracker_ The `PROTOCOL_FEE_TRACKER` variable value\n    function getProtocolFeeTracker() public view returns (address protocolFeeTracker_) {\n        return PROTOCOL_FEE_TRACKER;\n    }\n\n    /// @notice Gets the `VALUE_INTERPRETER` variable\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\n        return VALUE_INTERPRETER;\n    }\n}\n"
    },
    "contracts/persistent/off-chain/fund-value-calculator/IFundValueCalculator.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IFundValueCalculator interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IFundValueCalculator {\n    function calcGav(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 gav_);\n\n    function calcGavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 gav_);\n\n    function calcGrossShareValue(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 grossShareValue_);\n\n    function calcGrossShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 grossShareValue_);\n\n    function calcNav(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 nav_);\n\n    function calcNavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 nav_);\n\n    function calcNetShareValue(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 netShareValue_);\n\n    function calcNetShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 netShareValue_);\n\n    function calcNetValueForSharesHolder(address _vaultProxy, address _sharesHolder)\n        external\n        returns (address denominationAsset_, uint256 netValue_);\n\n    function calcNetValueForSharesHolderInAsset(\n        address _vaultProxy,\n        address _sharesHolder,\n        address _quoteAsset\n    ) external returns (uint256 netValue_);\n}\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../../../persistent/external-positions/IExternalPosition.sol\";\nimport \"../../../extensions/IExtension.sol\";\nimport \"../../../extensions/fee-manager/IFeeManager.sol\";\nimport \"../../../extensions/policy-manager/IPolicyManager.sol\";\nimport \"../../../infrastructure/asset-finality/IAssetFinalityResolver.sol\";\nimport \"../../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\";\nimport \"../../../infrastructure/gas-relayer/IGasRelayPaymaster.sol\";\nimport \"../../../infrastructure/gas-relayer/IGasRelayPaymasterDepositor.sol\";\nimport \"../../../infrastructure/value-interpreter/IValueInterpreter.sol\";\nimport \"../../../utils/beacon-proxy/IBeaconProxyFactory.sol\";\nimport \"../../../utils/AddressArrayLib.sol\";\nimport \"../../fund-deployer/IFundDeployer.sol\";\nimport \"../vault/IVault.sol\";\nimport \"./IComptroller.sol\";\n\n/// @title ComptrollerLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The core logic library shared by all funds\ncontract ComptrollerLib is IComptroller, IGasRelayPaymasterDepositor, GasRelayRecipientMixin {\n    using AddressArrayLib for address[];\n    using SafeMath for uint256;\n    using SafeERC20 for ERC20;\n\n    event AutoProtocolFeeSharesBuybackSet(bool autoProtocolFeeSharesBuyback);\n\n    event BuyBackMaxProtocolFeeSharesFailed(\n        bytes indexed failureReturnData,\n        uint256 sharesAmount,\n        uint256 buybackValueInMln,\n        uint256 gav\n    );\n    event DeactivateFeeManagerFailed();\n\n    event GasRelayPaymasterSet(address gasRelayPaymaster);\n\n    event MigratedSharesDuePaid(uint256 sharesDue);\n\n    event PayProtocolFeeDuringDestructFailed();\n\n    event PreRedeemSharesHookFailed(\n        bytes indexed failureReturnData,\n        address indexed redeemer,\n        uint256 sharesAmount\n    );\n\n    event RedeemSharesInKindCalcGavFailed();\n\n    event SharesBought(\n        address indexed buyer,\n        uint256 investmentAmount,\n        uint256 sharesIssued,\n        uint256 sharesReceived\n    );\n\n    event SharesRedeemed(\n        address indexed redeemer,\n        address indexed recipient,\n        uint256 sharesAmount,\n        address[] receivedAssets,\n        uint256[] receivedAssetAmounts\n    );\n\n    event VaultProxySet(address vaultProxy);\n\n    // Constants and immutables - shared by all proxies\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\n    uint256 private constant SHARES_UNIT = 10**18;\n    address\n        private constant SPECIFIC_ASSET_REDEMPTION_DUMMY_FORFEIT_ADDRESS = 0x000000000000000000000000000000000000aaaa;\n    address private immutable ASSET_FINALITY_RESOLVER;\n    address private immutable DISPATCHER;\n    address private immutable EXTERNAL_POSITION_MANAGER;\n    address private immutable FUND_DEPLOYER;\n    address private immutable FEE_MANAGER;\n    address private immutable INTEGRATION_MANAGER;\n    address private immutable MLN_TOKEN;\n    address private immutable POLICY_MANAGER;\n    address private immutable PROTOCOL_FEE_RESERVE;\n    address private immutable VALUE_INTERPRETER;\n    address private immutable WETH_TOKEN;\n\n    // Pseudo-constants (can only be set once)\n\n    address internal denominationAsset;\n    address internal vaultProxy;\n    // True only for the one non-proxy\n    bool internal isLib;\n\n    // Storage\n\n    // Attempts to buy back protocol fee shares immediately after collection\n    bool internal autoProtocolFeeSharesBuyback;\n    // A reverse-mutex, granting atomic permission for particular contracts to make vault calls\n    bool internal permissionedVaultActionAllowed;\n    // A mutex to protect against reentrancy\n    bool internal reentranceLocked;\n    // A timelock after the last time shares were bought for an account\n    // that must expire before that account transfers or redeems their shares\n    uint256 internal sharesActionTimelock;\n    mapping(address => uint256) internal acctToLastSharesBoughtTimestamp;\n    // The contract which manages paying gas relayers\n    address private gasRelayPaymaster;\n\n    ///////////////\n    // MODIFIERS //\n    ///////////////\n\n    modifier allowsPermissionedVaultAction {\n        __assertPermissionedVaultActionNotAllowed();\n        permissionedVaultActionAllowed = true;\n        _;\n        permissionedVaultActionAllowed = false;\n    }\n\n    modifier locksReentrance() {\n        __assertNotReentranceLocked();\n        reentranceLocked = true;\n        _;\n        reentranceLocked = false;\n    }\n\n    modifier onlyFundDeployer() {\n        __assertIsFundDeployer();\n        _;\n    }\n    modifier onlyGasRelayPaymaster() {\n        __assertIsGasRelayPaymaster();\n        _;\n    }\n\n    modifier onlyOwner() {\n        __assertIsOwner(__msgSender());\n        _;\n    }\n\n    modifier onlyOwnerNotRelayable() {\n        __assertIsOwner(msg.sender);\n        _;\n    }\n\n    // ASSERTION HELPERS\n\n    // Modifiers are inefficient in terms of contract size,\n    // so we use helper functions to prevent repetitive inlining of expensive string values.\n\n    function __assertIsFundDeployer() private view {\n        require(msg.sender == getFundDeployer(), \"Only FundDeployer callable\");\n    }\n\n    function __assertIsGasRelayPaymaster() private view {\n        require(msg.sender == getGasRelayPaymaster(), \"Only Gas Relay Paymaster callable\");\n    }\n\n    function __assertIsOwner(address _who) private view {\n        require(_who == IVault(getVaultProxy()).getOwner(), \"Only fund owner callable\");\n    }\n\n    function __assertNotReentranceLocked() private view {\n        require(!reentranceLocked, \"Re-entrance\");\n    }\n\n    function __assertPermissionedVaultActionNotAllowed() private view {\n        require(!permissionedVaultActionAllowed, \"Vault action re-entrance\");\n    }\n\n    function __assertSharesActionNotTimelocked(address _vaultProxy, address _account)\n        private\n        view\n    {\n        uint256 lastSharesBoughtTimestamp = getLastSharesBoughtTimestampForAccount(_account);\n\n        require(\n            lastSharesBoughtTimestamp == 0 ||\n                block.timestamp.sub(lastSharesBoughtTimestamp) >= getSharesActionTimelock() ||\n                __hasPendingMigrationOrReconfiguration(_vaultProxy),\n            \"Shares action timelocked\"\n        );\n    }\n\n    constructor(\n        address _dispatcher,\n        address _protocolFeeReserve,\n        address _fundDeployer,\n        address _valueInterpreter,\n        address _externalPositionManager,\n        address _feeManager,\n        address _integrationManager,\n        address _policyManager,\n        address _assetFinalityResolver,\n        address _gasRelayPaymasterFactory,\n        address _mlnToken,\n        address _wethToken\n    ) public GasRelayRecipientMixin(_gasRelayPaymasterFactory) {\n        ASSET_FINALITY_RESOLVER = _assetFinalityResolver;\n        DISPATCHER = _dispatcher;\n        EXTERNAL_POSITION_MANAGER = _externalPositionManager;\n        FEE_MANAGER = _feeManager;\n        FUND_DEPLOYER = _fundDeployer;\n        INTEGRATION_MANAGER = _integrationManager;\n        MLN_TOKEN = _mlnToken;\n        POLICY_MANAGER = _policyManager;\n        PROTOCOL_FEE_RESERVE = _protocolFeeReserve;\n        VALUE_INTERPRETER = _valueInterpreter;\n        WETH_TOKEN = _wethToken;\n        isLib = true;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Calls a specified action on an Extension\n    /// @param _extension The Extension contract to call (e.g., FeeManager)\n    /// @param _actionId An ID representing the action to take on the extension (see extension)\n    /// @param _callArgs The encoded data for the call\n    /// @dev Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy\n    /// (for access control). Uses a mutex of sorts that allows \"permissioned vault actions\"\n    /// during calls originating from this function.\n    function callOnExtension(\n        address _extension,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override locksReentrance allowsPermissionedVaultAction {\n        require(\n            _extension == getFeeManager() ||\n                _extension == getIntegrationManager() ||\n                _extension == getExternalPositionManager(),\n            \"callOnExtension: _extension invalid\"\n        );\n\n        IExtension(_extension).receiveCallFromComptroller(__msgSender(), _actionId, _callArgs);\n    }\n\n    /// @notice Makes an arbitrary call with the VaultProxy contract as the sender\n    /// @param _contract The contract to call\n    /// @param _selector The selector to call\n    /// @param _encodedArgs The encoded arguments for the call\n    /// @return returnData_ The data returned by the call\n    function vaultCallOnContract(\n        address _contract,\n        bytes4 _selector,\n        bytes calldata _encodedArgs\n    ) external onlyOwner returns (bytes memory returnData_) {\n        require(\n            IFundDeployer(getFundDeployer()).isAllowedVaultCall(\n                _contract,\n                _selector,\n                keccak256(_encodedArgs)\n            ),\n            \"vaultCallOnContract: Not allowed\"\n        );\n\n        return\n            IVault(getVaultProxy()).callOnContract(\n                _contract,\n                abi.encodePacked(_selector, _encodedArgs)\n            );\n    }\n\n    /// @dev Helper to check if a VaultProxy has a pending migration or reconfiguration request\n    function __hasPendingMigrationOrReconfiguration(address _vaultProxy)\n        private\n        view\n        returns (bool hasPendingMigrationOrReconfiguration)\n    {\n        return\n            IDispatcher(getDispatcher()).hasMigrationRequest(_vaultProxy) ||\n            IFundDeployer(getFundDeployer()).hasReconfigurationRequest(_vaultProxy);\n    }\n\n    //////////////////\n    // PROTOCOL FEE //\n    //////////////////\n\n    /// @notice Buys back shares collected as protocol fee at a discounted shares price, using MLN\n    /// @param _sharesAmount The amount of shares to buy back\n    function buyBackProtocolFeeShares(uint256 _sharesAmount) external {\n        address vaultProxyCopy = vaultProxy;\n        require(\n            IVault(vaultProxyCopy).canManageAssets(__msgSender()),\n            \"buyBackProtocolFeeShares: Unauthorized\"\n        );\n\n        uint256 gav = calcGav(true);\n\n        IVault(vaultProxyCopy).buyBackProtocolFeeShares(\n            _sharesAmount,\n            __getBuybackValueInMln(vaultProxyCopy, _sharesAmount, gav),\n            gav\n        );\n    }\n\n    /// @notice Sets whether to attempt to buyback protocol fee shares immediately when collected\n    /// @param _nextAutoProtocolFeeSharesBuyback True if protocol fee shares should be attempted\n    /// to be bought back immediately when collected\n    function setAutoProtocolFeeSharesBuyback(bool _nextAutoProtocolFeeSharesBuyback)\n        external\n        onlyOwner\n    {\n        autoProtocolFeeSharesBuyback = _nextAutoProtocolFeeSharesBuyback;\n\n        emit AutoProtocolFeeSharesBuybackSet(_nextAutoProtocolFeeSharesBuyback);\n    }\n\n    /// @dev Helper to buyback the max available protocol fee shares, during an auto-buyback\n    function __buyBackMaxProtocolFeeShares(address _vaultProxy, uint256 _gav) private {\n        uint256 sharesAmount = ERC20(_vaultProxy).balanceOf(getProtocolFeeReserve());\n        uint256 buybackValueInMln = __getBuybackValueInMln(_vaultProxy, sharesAmount, _gav);\n\n        try\n            IVault(_vaultProxy).buyBackProtocolFeeShares(sharesAmount, buybackValueInMln, _gav)\n         {} catch (bytes memory reason) {\n            emit BuyBackMaxProtocolFeeSharesFailed(reason, sharesAmount, buybackValueInMln, _gav);\n        }\n    }\n\n    /// @dev Helper to buyback the max available protocol fee shares\n    function __getBuybackValueInMln(\n        address _vaultProxy,\n        uint256 _sharesAmount,\n        uint256 _gav\n    ) private returns (uint256 buybackValueInMln_) {\n        address denominationAssetCopy = getDenominationAsset();\n\n        uint256 grossShareValue = __calcGrossShareValue(\n            _gav,\n            ERC20(_vaultProxy).totalSupply(),\n            10**uint256(ERC20(denominationAssetCopy).decimals())\n        );\n\n        uint256 buybackValueInDenominationAsset = grossShareValue.mul(_sharesAmount).div(\n            SHARES_UNIT\n        );\n\n        return\n            IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAssetCopy,\n                buybackValueInDenominationAsset,\n                getMlnToken()\n            );\n    }\n\n    ////////////////////////////////\n    // PERMISSIONED VAULT ACTIONS //\n    ////////////////////////////////\n\n    /// @notice Makes a permissioned, state-changing call on the VaultProxy contract\n    /// @param _action The enum representing the VaultAction to perform on the VaultProxy\n    /// @param _actionData The call data for the action to perform\n    function permissionedVaultAction(IVault.VaultAction _action, bytes calldata _actionData)\n        external\n        override\n    {\n        __assertPermissionedVaultAction(msg.sender, _action);\n\n        // Validate action as needed\n        if (_action == IVault.VaultAction.RemoveTrackedAsset) {\n            require(\n                abi.decode(_actionData, (address)) != getDenominationAsset(),\n                \"permissionedVaultAction: Cannot untrack denomination asset\"\n            );\n        }\n\n        IVault(getVaultProxy()).receiveValidatedVaultAction(_action, _actionData);\n    }\n\n    /// @dev Helper to assert that a caller is allowed to perform a particular VaultAction.\n    /// Uses this pattern rather than multiple `require` statements to save on contract size.\n    function __assertPermissionedVaultAction(address _caller, IVault.VaultAction _action)\n        private\n        view\n    {\n        bool validAction;\n        if (permissionedVaultActionAllowed) {\n            // Calls are roughly ordered by likely frequency\n            if (_caller == getIntegrationManager()) {\n                if (\n                    _action == IVault.VaultAction.AddTrackedAsset ||\n                    _action == IVault.VaultAction.RemoveTrackedAsset ||\n                    _action == IVault.VaultAction.WithdrawAssetTo ||\n                    _action == IVault.VaultAction.ApproveAssetSpender\n                ) {\n                    validAction = true;\n                }\n            } else if (_caller == getFeeManager()) {\n                if (\n                    _action == IVault.VaultAction.MintShares ||\n                    _action == IVault.VaultAction.BurnShares ||\n                    _action == IVault.VaultAction.TransferShares\n                ) {\n                    validAction = true;\n                }\n            } else if (_caller == getExternalPositionManager()) {\n                if (\n                    _action == IVault.VaultAction.CallOnExternalPosition ||\n                    _action == IVault.VaultAction.AddExternalPosition ||\n                    _action == IVault.VaultAction.RemoveExternalPosition\n                ) {\n                    validAction = true;\n                }\n            }\n        }\n\n        require(validAction, \"__assertPermissionedVaultAction: Action not allowed\");\n    }\n\n    ///////////////\n    // LIFECYCLE //\n    ///////////////\n\n    // Ordered by execution in the lifecycle\n\n    /// @notice Initializes a fund with its core config\n    /// @param _denominationAsset The asset in which the fund's value should be denominated\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @dev Pseudo-constructor per proxy.\n    /// No need to assert access because this is called atomically on deployment,\n    /// and once it's called, it cannot be called again.\n    function init(address _denominationAsset, uint256 _sharesActionTimelock) external override {\n        require(getDenominationAsset() == address(0), \"init: Already initialized\");\n        require(\n            IValueInterpreter(getValueInterpreter()).isSupportedPrimitiveAsset(_denominationAsset),\n            \"init: Bad denomination asset\"\n        );\n\n        denominationAsset = _denominationAsset;\n        sharesActionTimelock = _sharesActionTimelock;\n    }\n\n    /// @notice Sets the VaultProxy\n    /// @param _vaultProxy The VaultProxy contract\n    /// @dev No need to assert anything beyond FundDeployer access.\n    /// Called atomically with init(), but after ComptrollerProxy has been deployed.\n    function setVaultProxy(address _vaultProxy) external override onlyFundDeployer {\n        vaultProxy = _vaultProxy;\n\n        emit VaultProxySet(_vaultProxy);\n    }\n\n    /// @notice Runs atomic logic after a ComptrollerProxy has become its vaultProxy's `accessor`\n    /// @param _isMigration True if a migrated fund is being activated\n    /// @dev No need to assert anything beyond FundDeployer access.\n    function activate(bool _isMigration) external override onlyFundDeployer {\n        address vaultProxyCopy = getVaultProxy();\n\n        if (_isMigration) {\n            // Distribute any shares in the VaultProxy to the fund owner.\n            // This is a mechanism to ensure that even in the edge case of a fund being unable\n            // to payout fee shares owed during migration, these shares are not lost.\n            uint256 sharesDue = ERC20(vaultProxyCopy).balanceOf(vaultProxyCopy);\n            if (sharesDue > 0) {\n                IVault(vaultProxyCopy).transferShares(\n                    vaultProxyCopy,\n                    IVault(vaultProxyCopy).getOwner(),\n                    sharesDue\n                );\n\n                emit MigratedSharesDuePaid(sharesDue);\n            }\n        }\n\n        IVault(vaultProxyCopy).addTrackedAsset(getDenominationAsset());\n\n        // Activate extensions\n        IExtension(getFeeManager()).activateForFund(_isMigration);\n        IExtension(getPolicyManager()).activateForFund(_isMigration);\n    }\n\n    /// @notice Wind down and destroy a ComptrollerProxy that is active\n    /// @param _deactivateFeeManagerGasLimit The amount of gas to forward to deactivate the FeeManager\n    /// @param _payProtocolFeeGasLimit The amount of gas to forward to pay the protocol fee\n    /// @dev No need to assert anything beyond FundDeployer access.\n    /// Uses the try/catch pattern throughout out of an abundance of caution for the function's success.\n    /// All external calls must use limited forwarded gas to ensure that a migration to another release\n    /// does not get bricked by logic that consumes too much gas for the block limit.\n    function destructActivated(\n        uint256 _deactivateFeeManagerGasLimit,\n        uint256 _payProtocolFeeGasLimit\n    ) external override onlyFundDeployer allowsPermissionedVaultAction {\n        // Forwarding limited gas here also protects fee recipients by guaranteeing that fee payout logic\n        // will run in the next function call\n        try IVault(getVaultProxy()).payProtocolFee{gas: _payProtocolFeeGasLimit}()  {} catch {\n            emit PayProtocolFeeDuringDestructFailed();\n        }\n\n        // Do not attempt to auto-buyback protocol fee shares in this case,\n        // as the call is gav-dependent and can consume too much gas\n\n        // Deactivate extensions only as-necessary\n\n        // Pays out shares outstanding for fees\n        try\n            IExtension(getFeeManager()).deactivateForFund{gas: _deactivateFeeManagerGasLimit}()\n         {} catch {\n            emit DeactivateFeeManagerFailed();\n        }\n\n        __selfDestruct();\n    }\n\n    /// @notice Destroy a ComptrollerProxy that has not been activated\n    function destructUnactivated() external override onlyFundDeployer {\n        __selfDestruct();\n    }\n\n    /// @dev Helper to self-destruct the contract.\n    /// There should never be ETH in the ComptrollerLib,\n    /// so no need to waste gas to get the fund owner\n    function __selfDestruct() private {\n        // Not necessary, but failsafe to protect the lib against selfdestruct\n        require(!isLib, \"__selfDestruct: Only delegate callable\");\n\n        selfdestruct(payable(address(this)));\n    }\n\n    ////////////////\n    // ACCOUNTING //\n    ////////////////\n\n    /// @notice Calculates the gross asset value (GAV) of the fund\n    /// @param _finalizeAssets True if all assets must have exact final balances settled\n    /// @return gav_ The fund GAV\n    function calcGav(bool _finalizeAssets) public override returns (uint256 gav_) {\n        address vaultProxyAddress = getVaultProxy();\n        address[] memory assets = IVault(vaultProxyAddress).getTrackedAssets();\n        address[] memory externalPositions = IVault(vaultProxyAddress)\n            .getActiveExternalPositions();\n\n        if (assets.length == 0 && externalPositions.length == 0) {\n            return 0;\n        }\n\n        // It is not necessary to finalize assets in external positions, as synths will have\n        // already been settled prior to transferring to the external position contract\n        if (_finalizeAssets) {\n            IAssetFinalityResolver(getAssetFinalityResolver()).finalizeAssets(\n                vaultProxyAddress,\n                assets\n            );\n        }\n\n        uint256[] memory balances = new uint256[](assets.length);\n        for (uint256 i; i < assets.length; i++) {\n            balances[i] = ERC20(assets[i]).balanceOf(vaultProxyAddress);\n            IVault(vaultProxyAddress).debugGav(assets[i], balances[i], vaultProxyAddress);\n        }\n\n        gav_ = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetsTotalValue(\n            assets,\n            balances,\n            getDenominationAsset()\n        );\n\n        if (externalPositions.length > 0) {\n            for (uint256 i; i < externalPositions.length; i++) {\n                uint256 externalPositionValue = __calcExternalPositionValue(externalPositions[i]);\n\n                gav_ = gav_.add(externalPositionValue);\n            }\n        }\n\n        return gav_;\n    }\n\n    /// @notice Calculates the gross value of 1 unit of shares in the fund's denomination asset\n    /// @param _requireFinality True if all assets must have exact final balances settled\n    /// @return grossShareValue_ The amount of the denomination asset per share\n    /// @dev Does not account for any fees outstanding.\n    function calcGrossShareValue(bool _requireFinality)\n        external\n        override\n        returns (uint256 grossShareValue_)\n    {\n        uint256 gav = calcGav(_requireFinality);\n\n        grossShareValue_ = __calcGrossShareValue(\n            gav,\n            ERC20(getVaultProxy()).totalSupply(),\n            10**uint256(ERC20(getDenominationAsset()).decimals())\n        );\n\n        return grossShareValue_;\n    }\n\n    // @dev Helper for calculating a external position value. Prevents from stack too deep\n    function __calcExternalPositionValue(address _externalPosition)\n        private\n        returns (uint256 value_)\n    {\n        (address[] memory managedAssets, uint256[] memory managedAmounts) = IExternalPosition(\n            _externalPosition\n        )\n            .getManagedAssets();\n\n        uint256 managedValue = IValueInterpreter(getValueInterpreter())\n            .calcCanonicalAssetsTotalValue(managedAssets, managedAmounts, getDenominationAsset());\n\n        (address[] memory debtAssets, uint256[] memory debtAmounts) = IExternalPosition(\n            _externalPosition\n        )\n            .getDebtAssets();\n\n        uint256 debtValue = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetsTotalValue(\n            debtAssets,\n            debtAmounts,\n            getDenominationAsset()\n        );\n\n        if (managedValue > debtValue) {\n            value_ = managedValue.sub(debtValue);\n        }\n\n        return value_;\n    }\n\n    /// @dev Helper for calculating the gross share value\n    function __calcGrossShareValue(\n        uint256 _gav,\n        uint256 _sharesSupply,\n        uint256 _denominationAssetUnit\n    ) private pure returns (uint256 grossShareValue_) {\n        if (_sharesSupply == 0) {\n            return _denominationAssetUnit;\n        }\n\n        return _gav.mul(SHARES_UNIT).div(_sharesSupply);\n    }\n\n    ///////////////////\n    // PARTICIPATION //\n    ///////////////////\n\n    // BUY SHARES\n\n    /// @notice Buys shares on behalf of another user\n    /// @param _buyer The account on behalf of whom to buy shares\n    /// @param _investmentAmount The amount of the fund's denomination asset with which to buy shares\n    /// @param _minSharesQuantity The minimum quantity of shares to buy\n    /// @return sharesReceived_ The actual amount of shares received\n    /// @dev This function is freely callable if there is no sharesActionTimelock set, but it is\n    /// limited to a list of trusted callers otherwise, in order to prevent a griefing attack\n    /// where the caller buys shares for a _buyer, thereby resetting their lastSharesBought value.\n    function buySharesOnBehalf(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity\n    ) external returns (uint256 sharesReceived_) {\n        bool hasSharesActionTimelock = getSharesActionTimelock() > 0;\n        address canonicalSender = __msgSender();\n\n        require(\n            !hasSharesActionTimelock ||\n                IFundDeployer(getFundDeployer()).isAllowedBuySharesOnBehalfCaller(canonicalSender),\n            \"buySharesOnBehalf: Unauthorized\"\n        );\n\n        return\n            __buyShares(\n                _buyer,\n                _investmentAmount,\n                _minSharesQuantity,\n                hasSharesActionTimelock,\n                canonicalSender\n            );\n    }\n\n    /// @notice Buys shares\n    /// @param _investmentAmount The amount of the fund's denomination asset\n    /// with which to buy shares\n    /// @param _minSharesQuantity The minimum quantity of shares to buy\n    /// @return sharesReceived_ The actual amount of shares received\n    function buyShares(uint256 _investmentAmount, uint256 _minSharesQuantity)\n        external\n        returns (uint256 sharesReceived_)\n    {\n        bool hasSharesActionTimelock = getSharesActionTimelock() > 0;\n        address canonicalSender = __msgSender();\n\n        return\n            __buyShares(\n                canonicalSender,\n                _investmentAmount,\n                _minSharesQuantity,\n                hasSharesActionTimelock,\n                canonicalSender\n            );\n    }\n\n    /// @dev Helper for buy shares logic\n    function __buyShares(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity,\n        bool _hasSharesActionTimelock,\n        address _canonicalSender\n    ) private locksReentrance allowsPermissionedVaultAction returns (uint256 sharesReceived_) {\n        // Enforcing a _minSharesQuantity also validates `_investmentAmount > 0`\n        // and guarantees the function cannot succeed while minting 0 shares\n        require(_minSharesQuantity > 0, \"__buyShares: _minSharesQuantity must be >0\");\n\n        address vaultProxyCopy = getVaultProxy();\n        require(\n            !_hasSharesActionTimelock || !__hasPendingMigrationOrReconfiguration(vaultProxyCopy),\n            \"__buyShares: Pending migration or reconfiguration\"\n        );\n\n        uint256 gav = calcGav(true);\n\n        // Gives Extensions a chance to run logic prior to the minting of bought shares.\n        // Fees implementing this hook should be aware that\n        // it might be the case that _investmentAmount != actualInvestmentAmount,\n        // if the denomination asset charges a transfer fee, for example.\n        __preBuySharesHook(_buyer, _investmentAmount, gav);\n\n        // Pay the protocol fee after running other fees, but before minting new shares\n        IVault(vaultProxyCopy).payProtocolFee();\n        if (doesAutoProtocolFeeSharesBuyback()) {\n            __buyBackMaxProtocolFeeShares(vaultProxyCopy, gav);\n        }\n\n        // Transfer the investment asset to the fund.\n        // Does not follow the checks-effects-interactions pattern, but it is necessary to\n        // do this delta balance calculation before calculating shares to mint.\n        uint256 receivedInvestmentAmount = __transferFromWithReceivedAmount(\n            getDenominationAsset(),\n            _canonicalSender,\n            vaultProxyCopy,\n            _investmentAmount\n        );\n\n        // Calculate the amount of shares to issue with the investment amount\n        uint256 sharePrice = __calcGrossShareValue(\n            gav,\n            ERC20(vaultProxyCopy).totalSupply(),\n            10**uint256(ERC20(getDenominationAsset()).decimals())\n        );\n        uint256 sharesIssued = receivedInvestmentAmount.mul(SHARES_UNIT).div(sharePrice);\n\n        // Mint shares to the buyer\n        uint256 prevBuyerShares = ERC20(vaultProxyCopy).balanceOf(_buyer);\n        IVault(vaultProxyCopy).mintShares(_buyer, sharesIssued);\n\n        // Gives Extensions a chance to run logic after shares are issued\n        __postBuySharesHook(_buyer, receivedInvestmentAmount, sharesIssued, gav);\n\n        // The number of actual shares received may differ from shares issued due to\n        // how the PostBuyShares hooks are invoked by Extensions (i.e., fees)\n        sharesReceived_ = ERC20(vaultProxyCopy).balanceOf(_buyer).sub(prevBuyerShares);\n        require(\n            sharesReceived_ >= _minSharesQuantity,\n            \"__buyShares: Shares received < _minSharesQuantity\"\n        );\n\n        if (_hasSharesActionTimelock) {\n            acctToLastSharesBoughtTimestamp[_buyer] = block.timestamp;\n        }\n\n        emit SharesBought(_buyer, receivedInvestmentAmount, sharesIssued, sharesReceived_);\n\n        return sharesReceived_;\n    }\n\n    /// @dev Helper for Extension actions immediately prior to issuing shares\n    function __preBuySharesHook(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _gav\n    ) private {\n        IFeeManager(getFeeManager()).invokeHook(\n            IFeeManager.FeeHook.PreBuyShares,\n            abi.encode(_buyer, _investmentAmount),\n            _gav\n        );\n    }\n\n    /// @dev Helper for Extension actions immediately after issuing shares.\n    /// This could be cleaned up so both Extensions take the same encoded args and handle GAV\n    /// in the same way, but there is not the obvious need for gas savings of recycling\n    /// the GAV value for the current policies as there is for the fees.\n    function __postBuySharesHook(\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _sharesIssued,\n        uint256 _preBuySharesGav\n    ) private {\n        uint256 gav = _preBuySharesGav.add(_investmentAmount);\n        IFeeManager(getFeeManager()).invokeHook(\n            IFeeManager.FeeHook.PostBuyShares,\n            abi.encode(_buyer, _investmentAmount, _sharesIssued),\n            gav\n        );\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.PostBuyShares,\n            abi.encode(_buyer, _investmentAmount, _sharesIssued, gav)\n        );\n    }\n\n    /// @dev Helper to execute ERC20.transferFrom() while calculating the actual amount received\n    function __transferFromWithReceivedAmount(\n        address _asset,\n        address _sender,\n        address _recipient,\n        uint256 _transferAmount\n    ) private returns (uint256 receivedAmount_) {\n        uint256 preTransferRecipientBalance = ERC20(_asset).balanceOf(_recipient);\n\n        ERC20(_asset).safeTransferFrom(_sender, _recipient, _transferAmount);\n\n        return ERC20(_asset).balanceOf(_recipient).sub(preTransferRecipientBalance);\n    }\n\n    // REDEEM SHARES\n\n    /// @notice Redeems a specified amount of the sender's shares for specified asset proportions\n    /// @param _recipient The account that will receive the specified assets\n    /// @param _sharesQuantity The quantity of shares to redeem\n    /// @param _payoutAssets The assets to payout\n    /// @param _payoutAssetPercentages The percentage of the owed amount to pay out in each asset\n    /// @return payoutAmounts_ The amount of each asset paid out to the _recipient\n    /// @dev Redeem all shares of the sender by setting _sharesQuantity to the max uint value.\n    /// _payoutAssetPercentages must total exactly 100%. In order to specify less and forgo the\n    /// remaining gav owed on the redeemed shares, pass in address(0) with the percentage to forego.\n    /// Unlike redeemSharesInKind(), this function allows policies to run and prevent redemption.\n    function redeemSharesForSpecificAssets(\n        address _recipient,\n        uint256 _sharesQuantity,\n        address[] calldata _payoutAssets,\n        uint256[] calldata _payoutAssetPercentages\n    ) external locksReentrance returns (uint256[] memory payoutAmounts_) {\n        address canonicalSender = __msgSender();\n        require(\n            _payoutAssets.length == _payoutAssetPercentages.length,\n            \"redeemSharesForSpecificAssets: Unequal arrays\"\n        );\n        require(\n            _payoutAssets.isUniqueSet(),\n            \"redeemSharesForSpecificAssets: Duplicate payout asset\"\n        );\n\n        uint256 gav = calcGav(true);\n\n        IVault vaultProxyContract = IVault(getVaultProxy());\n        (uint256 sharesToRedeem, uint256 sharesSupply) = __redeemSharesSetup(\n            vaultProxyContract,\n            canonicalSender,\n            _sharesQuantity,\n            true,\n            gav\n        );\n\n        payoutAmounts_ = __payoutSpecifiedAssetPercentages(\n            vaultProxyContract,\n            _recipient,\n            _payoutAssets,\n            _payoutAssetPercentages,\n            gav.mul(sharesToRedeem).div(sharesSupply)\n        );\n\n        // Run post-redemption in order to have access to the payoutAmounts\n        __postRedeemSharesForSpecificAssetsHook(\n            canonicalSender,\n            _recipient,\n            sharesToRedeem,\n            _payoutAssets,\n            payoutAmounts_,\n            gav\n        );\n\n        emit SharesRedeemed(\n            canonicalSender,\n            _recipient,\n            sharesToRedeem,\n            _payoutAssets,\n            payoutAmounts_\n        );\n\n        return payoutAmounts_;\n    }\n\n    /// @notice Redeems a specified amount of the sender's shares\n    /// for a proportionate slice of the vault's assets\n    /// @param _recipient The account that will receive the proportionate slice of assets\n    /// @param _sharesQuantity The quantity of shares to redeem\n    /// @param _additionalAssets Additional (non-tracked) assets to claim\n    /// @param _assetsToSkip Tracked assets to forfeit\n    /// @return payoutAssets_ The assets paid out to the _recipient\n    /// @return payoutAmounts_ The amount of each asset paid out to the _recipient\n    /// @dev Redeem all shares of the sender by setting _sharesQuantity to the max uint value.\n    /// Any claim to passed _assetsToSkip will be forfeited entirely. This should generally\n    /// only be exercised if a bad asset is causing redemption to fail.\n    /// This function should never fail without a way to bypass the failure, which is assured\n    /// through two mechanisms:\n    /// 1. The FeeManager is called with the try/catch pattern to assure that calls to it\n    /// can never block redemption.\n    /// 2. If a token fails upon transfer(), that token can be skipped (and its balance forfeited)\n    /// by explicitly specifying _assetsToSkip.\n    /// Because of these assurances, shares should always be redeemable, with the exception\n    /// of the timelock period on shares actions that must be respected.\n    function redeemSharesInKind(\n        address _recipient,\n        uint256 _sharesQuantity,\n        address[] calldata _additionalAssets,\n        address[] calldata _assetsToSkip\n    )\n        external\n        locksReentrance\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\n    {\n        address canonicalSender = __msgSender();\n        require(\n            _additionalAssets.isUniqueSet(),\n            \"redeemSharesInKind: _additionalAssets contains duplicates\"\n        );\n        require(\n            _assetsToSkip.isUniqueSet(),\n            \"redeemSharesInKind: _assetsToSkip contains duplicates\"\n        );\n\n        // Parse the payout assets given optional params to add or skip assets.\n        // Note that there is no validation that the _additionalAssets are known assets to\n        // the protocol. This means that the redeemer could specify a malicious asset,\n        // but since all state-changing, user-callable functions on this contract share the\n        // non-reentrant modifier, there is nowhere to perform a reentrancy attack.\n        payoutAssets_ = __parseRedemptionPayoutAssets(\n            IVault(vaultProxy).getTrackedAssets(),\n            _additionalAssets,\n            _assetsToSkip\n        );\n\n        // Resolve finality of all assets as needed.\n        // Run this prior to calculating GAV.\n        IAssetFinalityResolver(getAssetFinalityResolver()).finalizeAssets(\n            vaultProxy,\n            payoutAssets_\n        );\n\n        // If protocol fee shares will be auto-bought back, attempt to calculate GAV to pass into fees,\n        // as we will require GAV later during the buyback.\n        uint256 gavOrZero;\n        if (doesAutoProtocolFeeSharesBuyback()) {\n            // Since GAV calculation can fail with a revering price or a no-longer-supported asset,\n            // we must try/catch GAV calculation to ensure that in-kind redemption can still succeed\n            try this.calcGav(false) returns (uint256 gav) {\n                gavOrZero = gav;\n            } catch {\n                emit RedeemSharesInKindCalcGavFailed();\n            }\n        }\n\n        (uint256 sharesToRedeem, uint256 sharesSupply) = __redeemSharesSetup(\n            IVault(vaultProxy),\n            canonicalSender,\n            _sharesQuantity,\n            false,\n            gavOrZero\n        );\n\n        // Calculate and transfer payout asset amounts due to _recipient\n        payoutAmounts_ = new uint256[](payoutAssets_.length);\n        for (uint256 i; i < payoutAssets_.length; i++) {\n            payoutAmounts_[i] = ERC20(payoutAssets_[i])\n                .balanceOf(vaultProxy)\n                .mul(sharesToRedeem)\n                .div(sharesSupply);\n\n            // Transfer payout asset to _recipient\n            if (payoutAmounts_[i] > 0) {\n                IVault(vaultProxy).withdrawAssetTo(\n                    payoutAssets_[i],\n                    _recipient,\n                    payoutAmounts_[i]\n                );\n            }\n        }\n\n        emit SharesRedeemed(\n            canonicalSender,\n            _recipient,\n            sharesToRedeem,\n            payoutAssets_,\n            payoutAmounts_\n        );\n\n        return (payoutAssets_, payoutAmounts_);\n    }\n\n    /// @dev Helper to parse an array of payout assets during redemption, taking into account\n    /// additional assets and assets to skip. _assetsToSkip ignores _additionalAssets.\n    /// All input arrays are assumed to be unique.\n    function __parseRedemptionPayoutAssets(\n        address[] memory _trackedAssets,\n        address[] memory _additionalAssets,\n        address[] memory _assetsToSkip\n    ) private pure returns (address[] memory payoutAssets_) {\n        address[] memory trackedAssetsToPayout = _trackedAssets.removeItems(_assetsToSkip);\n        if (_additionalAssets.length == 0) {\n            return trackedAssetsToPayout;\n        }\n\n        // Add additional assets. Duplicates of trackedAssets are ignored.\n        bool[] memory indexesToAdd = new bool[](_additionalAssets.length);\n        uint256 additionalItemsCount;\n        for (uint256 i; i < _additionalAssets.length; i++) {\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\n                indexesToAdd[i] = true;\n                additionalItemsCount++;\n            }\n        }\n        if (additionalItemsCount == 0) {\n            return trackedAssetsToPayout;\n        }\n\n        payoutAssets_ = new address[](trackedAssetsToPayout.length.add(additionalItemsCount));\n        for (uint256 i; i < trackedAssetsToPayout.length; i++) {\n            payoutAssets_[i] = trackedAssetsToPayout[i];\n        }\n        uint256 payoutAssetsIndex = trackedAssetsToPayout.length;\n        for (uint256 i; i < _additionalAssets.length; i++) {\n            if (indexesToAdd[i]) {\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\n                payoutAssetsIndex++;\n            }\n        }\n\n        return payoutAssets_;\n    }\n\n    /// @dev Helper to payout specified asset percentages during redeemSharesForSpecificAssets()\n    function __payoutSpecifiedAssetPercentages(\n        IVault vaultProxyContract,\n        address _recipient,\n        address[] calldata _payoutAssets,\n        uint256[] calldata _payoutAssetPercentages,\n        uint256 _owedGav\n    ) private returns (uint256[] memory payoutAmounts_) {\n        address denominationAssetCopy = getDenominationAsset();\n        uint256 percentagesTotal;\n        payoutAmounts_ = new uint256[](_payoutAssets.length);\n        for (uint256 i; i < _payoutAssets.length; i++) {\n            percentagesTotal = percentagesTotal.add(_payoutAssetPercentages[i]);\n\n            // Used to explicitly specify less than 100% in total _payoutAssetPercentages\n            if (_payoutAssets[i] == SPECIFIC_ASSET_REDEMPTION_DUMMY_FORFEIT_ADDRESS) {\n                continue;\n            }\n\n            payoutAmounts_[i] = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\n                denominationAssetCopy,\n                _owedGav.mul(_payoutAssetPercentages[i]).div(ONE_HUNDRED_PERCENT),\n                _payoutAssets[i]\n            );\n            // Guards against corner case of primitive-to-derivative asset conversion that floors to 0,\n            // or redeeming a very low shares amount and/or percentage where asset value owed is 0\n            require(\n                payoutAmounts_[i] > 0,\n                \"__payoutSpecifiedAssetPercentages: Zero amount for asset\"\n            );\n\n            vaultProxyContract.withdrawAssetTo(_payoutAssets[i], _recipient, payoutAmounts_[i]);\n        }\n\n        require(\n            percentagesTotal == ONE_HUNDRED_PERCENT,\n            \"__payoutSpecifiedAssetPercentages: Percents must total 100%\"\n        );\n\n        return payoutAmounts_;\n    }\n\n    /// @dev Helper for system actions immediately prior to redeeming shares.\n    /// Policy validation is not currently allowed on redemption, to ensure continuous redeemability.\n    function __preRedeemSharesHook(\n        address _redeemer,\n        uint256 _sharesToRedeem,\n        bool _forSpecifiedAssets,\n        uint256 _gavIfCalculated\n    ) private allowsPermissionedVaultAction {\n        try\n            IFeeManager(getFeeManager()).invokeHook(\n                IFeeManager.FeeHook.PreRedeemShares,\n                abi.encode(_redeemer, _sharesToRedeem, _forSpecifiedAssets),\n                _gavIfCalculated\n            )\n         {} catch (bytes memory reason) {\n            emit PreRedeemSharesHookFailed(reason, _redeemer, _sharesToRedeem);\n        }\n    }\n\n    /// @dev Helper to run policy validation after other logic for redeeming shares for specific assets.\n    /// Avoids stack-too-deep error.\n    function __postRedeemSharesForSpecificAssetsHook(\n        address _redeemer,\n        address _recipient,\n        uint256 _sharesToRedeemPostFees,\n        address[] memory _assets,\n        uint256[] memory _assetAmounts,\n        uint256 _gavPreRedeem\n    ) private {\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.RedeemSharesForSpecificAssets,\n            abi.encode(\n                _redeemer,\n                _recipient,\n                _sharesToRedeemPostFees,\n                _assets,\n                _assetAmounts,\n                _gavPreRedeem\n            )\n        );\n    }\n\n    /// @dev Helper to execute common pre-shares redemption logic\n    function __redeemSharesSetup(\n        IVault vaultProxyContract,\n        address _redeemer,\n        uint256 _sharesQuantityInput,\n        bool _forSpecifiedAssets,\n        uint256 _gavIfCalculated\n    ) private returns (uint256 sharesToRedeem_, uint256 sharesSupply_) {\n        __assertSharesActionNotTimelocked(address(vaultProxyContract), _redeemer);\n\n        ERC20 sharesContract = ERC20(address(vaultProxyContract));\n\n        uint256 preFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);\n\n        if (_sharesQuantityInput == type(uint256).max) {\n            sharesToRedeem_ = preFeesRedeemerSharesBalance;\n        } else {\n            sharesToRedeem_ = _sharesQuantityInput;\n        }\n        require(sharesToRedeem_ > 0, \"__redeemSharesSetup: No shares to redeem\");\n\n        __preRedeemSharesHook(_redeemer, sharesToRedeem_, _forSpecifiedAssets, _gavIfCalculated);\n\n        // Update the redemption amount if fees were charged (or accrued) to the redeemer\n        uint256 postFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);\n        if (_sharesQuantityInput == type(uint256).max) {\n            sharesToRedeem_ = postFeesRedeemerSharesBalance;\n        } else if (postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance) {\n            sharesToRedeem_ = sharesToRedeem_.sub(\n                preFeesRedeemerSharesBalance.sub(postFeesRedeemerSharesBalance)\n            );\n        }\n\n        // Pay the protocol fee after running other fees, but before burning shares\n        vaultProxyContract.payProtocolFee();\n\n        if (_gavIfCalculated > 0 && doesAutoProtocolFeeSharesBuyback()) {\n            __buyBackMaxProtocolFeeShares(address(vaultProxyContract), _gavIfCalculated);\n        }\n\n        // Destroy the shares after getting the shares supply\n        sharesSupply_ = sharesContract.totalSupply();\n        vaultProxyContract.burnShares(_redeemer, sharesToRedeem_);\n\n        return (sharesToRedeem_, sharesSupply_);\n    }\n\n    // TRANSFER SHARES\n\n    /// @notice Runs logic prior to transferring shares that are not freely transferable\n    /// @param _sender The sender of the shares\n    /// @param _recipient The recipient of the shares\n    /// @param _amount The amount of shares\n    function preTransferSharesHook(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) external override {\n        address vaultProxyCopy = getVaultProxy();\n        require(msg.sender == vaultProxyCopy, \"preTransferSharesHook: Only VaultProxy callable\");\n        __assertSharesActionNotTimelocked(vaultProxyCopy, _sender);\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            address(this),\n            IPolicyManager.PolicyHook.PreTransferShares,\n            abi.encode(_sender, _recipient, _amount)\n        );\n    }\n\n    /// @notice Runs logic prior to transferring shares that are freely transferable\n    /// @param _sender The sender of the shares\n    /// @dev No need to validate caller, as policies are not run\n    function preTransferSharesHookFreelyTransferable(address _sender) external view override {\n        __assertSharesActionNotTimelocked(getVaultProxy(), _sender);\n    }\n\n    /////////////////\n    // GAS RELAYER //\n    /////////////////\n\n    /// @notice Deploys a paymaster contract and deposits WETH, enabling gas relaying\n    function deployGasRelayPaymaster() external onlyOwnerNotRelayable {\n        require(\n            getGasRelayPaymaster() == address(0),\n            \"deployGasRelayPaymaster: Paymaster already deployed\"\n        );\n\n        bytes memory constructData = abi.encodeWithSignature(\"init(address)\", getVaultProxy());\n        address paymaster = IBeaconProxyFactory(getGasRelayPaymasterFactory()).deployProxy(\n            constructData\n        );\n\n        __setGasRelayPaymaster(paymaster);\n\n        __depositToGasRelayPaymaster(paymaster);\n    }\n\n    /// @notice Tops up the gas relay paymaster deposit\n    function depositToGasRelayPaymaster() external onlyOwner {\n        __depositToGasRelayPaymaster(getGasRelayPaymaster());\n    }\n\n    /// @notice Pull WETH from vault to gas relay paymaster\n    /// @param _amount Amount of the WETH to pull from the vault\n    function pullWethForGasRelayer(uint256 _amount) external override onlyGasRelayPaymaster {\n        IVault(getVaultProxy()).withdrawAssetTo(getWethToken(), getGasRelayPaymaster(), _amount);\n    }\n\n    /// @notice Sets the gasRelayPaymaster variable value\n    /// @param _nextGasRelayPaymaster The next gasRelayPaymaster value\n    function setGasRelayPaymaster(address _nextGasRelayPaymaster)\n        external\n        override\n        onlyFundDeployer\n    {\n        __setGasRelayPaymaster(_nextGasRelayPaymaster);\n    }\n\n    /// @notice Removes the gas relay paymaster, withdrawing the remaining WETH balance\n    /// and disabling gas relaying\n    function shutdownGasRelayPaymaster() external onlyOwnerNotRelayable {\n        IGasRelayPaymaster(gasRelayPaymaster).withdrawBalance();\n\n        IVault(vaultProxy).addTrackedAsset(getWethToken());\n\n        delete gasRelayPaymaster;\n\n        emit GasRelayPaymasterSet(address(0));\n    }\n\n    /// @dev Helper to deposit to the gas relay paymaster\n    function __depositToGasRelayPaymaster(address _paymaster) private {\n        IGasRelayPaymaster(_paymaster).deposit();\n    }\n\n    /// @dev Helper to set the next `gasRelayPaymaster` variable\n    function __setGasRelayPaymaster(address _nextGasRelayPaymaster) private {\n        gasRelayPaymaster = _nextGasRelayPaymaster;\n\n        emit GasRelayPaymasterSet(_nextGasRelayPaymaster);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // LIB IMMUTABLES\n\n    /// @notice Gets the `ASSET_FINALITY_RESOLVER` variable\n    /// @return assetFinalityResolver_ The `ASSET_FINALITY_RESOLVER` variable value\n    function getAssetFinalityResolver() public view returns (address assetFinalityResolver_) {\n        return ASSET_FINALITY_RESOLVER;\n    }\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the `EXTERNAL_POSITION_MANAGER` variable\n    /// @return externalPositionManager_ The `EXTERNAL_POSITION_MANAGER` variable value\n    function getExternalPositionManager()\n        public\n        view\n        override\n        returns (address externalPositionManager_)\n    {\n        return EXTERNAL_POSITION_MANAGER;\n    }\n\n    /// @notice Gets the `FEE_MANAGER` variable\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    function getFeeManager() public view override returns (address feeManager_) {\n        return FEE_MANAGER;\n    }\n\n    /// @notice Gets the `FUND_DEPLOYER` variable\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\n    function getFundDeployer() public view override returns (address fundDeployer_) {\n        return FUND_DEPLOYER;\n    }\n\n    /// @notice Gets the `INTEGRATION_MANAGER` variable\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\n    function getIntegrationManager() public view override returns (address integrationManager_) {\n        return INTEGRATION_MANAGER;\n    }\n\n    /// @notice Gets the `MLN_TOKEN` variable\n    /// @return mlnToken_ The `MLN_TOKEN` variable value\n    function getMlnToken() public view returns (address mlnToken_) {\n        return MLN_TOKEN;\n    }\n\n    /// @notice Gets the `POLICY_MANAGER` variable\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\n    function getPolicyManager() public view override returns (address policyManager_) {\n        return POLICY_MANAGER;\n    }\n\n    /// @notice Gets the `PROTOCOL_FEE_RESERVE` variable\n    /// @return protocolFeeReserve_ The `PROTOCOL_FEE_RESERVE` variable value\n    function getProtocolFeeReserve() public view returns (address protocolFeeReserve_) {\n        return PROTOCOL_FEE_RESERVE;\n    }\n\n    /// @notice Gets the `VALUE_INTERPRETER` variable\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\n        return VALUE_INTERPRETER;\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n\n    // PROXY STORAGE\n\n    /// @notice Checks if collected protocol fee shares are automatically bought back\n    /// while buying or redeeming shares\n    /// @return doesAutoBuyback_ True if shares are automatically bought back\n    function doesAutoProtocolFeeSharesBuyback() public view returns (bool doesAutoBuyback_) {\n        return autoProtocolFeeSharesBuyback;\n    }\n\n    /// @notice Gets the `denominationAsset` variable\n    /// @return denominationAsset_ The `denominationAsset` variable value\n    function getDenominationAsset() public view override returns (address denominationAsset_) {\n        return denominationAsset;\n    }\n\n    /// @notice Gets the `gasRelayPaymaster` variable\n    /// @return gasRelayPaymaster_ The `gasRelayPaymaster` variable value\n    function getGasRelayPaymaster() public view override returns (address gasRelayPaymaster_) {\n        return gasRelayPaymaster;\n    }\n\n    /// @notice Gets the timestamp of the last time shares were bought for a given account\n    /// @param _who The account for which to get the timestamp\n    /// @return lastSharesBoughtTimestamp_ The timestamp of the last shares bought\n    function getLastSharesBoughtTimestampForAccount(address _who)\n        public\n        view\n        returns (uint256 lastSharesBoughtTimestamp_)\n    {\n        return acctToLastSharesBoughtTimestamp[_who];\n    }\n\n    /// @notice Gets the `sharesActionTimelock` variable\n    /// @return sharesActionTimelock_ The `sharesActionTimelock` variable value\n    function getSharesActionTimelock() public view returns (uint256 sharesActionTimelock_) {\n        return sharesActionTimelock;\n    }\n\n    /// @notice Gets the `vaultProxy` variable\n    /// @return vaultProxy_ The `vaultProxy` variable value\n    function getVaultProxy() public view override returns (address vaultProxy_) {\n        return vaultProxy;\n    }\n}\n"
    },
    "contracts/release/core/fund/vault/VaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../../../persistent/external-positions/IExternalPosition.sol\";\nimport \"../../../../persistent/protocol-fee-reserve/interfaces/IProtocolFeeReserve1.sol\";\nimport \"../../../../persistent/vault/VaultLibBase2.sol\";\nimport \"../../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\";\nimport \"../../../infrastructure/protocol-fees/IProtocolFeeTracker.sol\";\nimport \"../../../extensions/external-position-manager/IExternalPositionManager.sol\";\nimport \"../../../interfaces/IWETH.sol\";\nimport \"../../../utils/AddressArrayLib.sol\";\nimport \"../comptroller/IComptroller.sol\";\nimport \"./IVault.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title VaultLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The per-release proxiable library contract for VaultProxy\n/// @dev The difference in terminology between \"asset\" and \"trackedAsset\" is intentional.\n/// A fund might actually have asset balances of un-tracked assets,\n/// but only tracked assets are used in gav calculations.\n/// Note that this contract inherits VaultLibSafeMath (a verbatim Open Zeppelin SafeMath copy)\n/// from SharesTokenBase via VaultLibBase2\ncontract VaultLib is VaultLibBase2, IVault, GasRelayRecipientMixin {\n    using AddressArrayLib for address[];\n    using SafeERC20 for ERC20;\n\n    // \"Positions\" are \"tracked assets\" + active \"external positions\"\n    // Before updating POSITIONS_LIMIT in the future, it is important to consider:\n    // 1. The highest positions limit ever allowed in the protocol\n    // 2. That the next value will need to be respected by all future releases\n    uint256 private constant POSITIONS_LIMIT = 20;\n\n    address private immutable EXTERNAL_POSITION_MANAGER;\n    address private immutable MLN_TOKEN;\n    address private immutable PROTOCOL_FEE_RESERVE;\n    address private immutable PROTOCOL_FEE_TRACKER;\n    address private immutable WETH_TOKEN;\n\n    modifier notShares(address _asset) {\n        require(_asset != address(this), \"Cannot act on shares\");\n        _;\n    }\n\n    modifier onlyAccessor() {\n        require(msg.sender == accessor, \"Only the designated accessor can make this call\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(__msgSender() == owner, \"Only the owner can call this function\");\n        _;\n    }\n\n    constructor(\n        address _externalPositionManager,\n        address _gasRelayPaymasterFactory,\n        address _protocolFeeReserve,\n        address _protocolFeeTracker,\n        address _mlnToken,\n        address _wethToken\n    ) public GasRelayRecipientMixin(_gasRelayPaymasterFactory) {\n        EXTERNAL_POSITION_MANAGER = _externalPositionManager;\n        MLN_TOKEN = _mlnToken;\n        PROTOCOL_FEE_RESERVE = _protocolFeeReserve;\n        PROTOCOL_FEE_TRACKER = _protocolFeeTracker;\n        WETH_TOKEN = _wethToken;\n    }\n\n    /// @dev If a VaultProxy receives ETH, immediately wrap into WETH.\n    /// Will not be able to receive ETH via .transfer() or .send() due to limited gas forwarding.\n    receive() external payable {\n        uint256 ethAmount = payable(address(this)).balance;\n        IWETH(payable(getWethToken())).deposit{value: ethAmount}();\n\n        emit EthReceived(msg.sender, ethAmount);\n    }\n\n    /**\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\n     * assets in borrow(), withdraw() and flashLoan()\n     * @param target The recipient of the aTokens\n     * @param amount The amount getting transferred\n     * @return The amount transferred\n     **/\n    function transferUnderlyingTo(\n        address asset,\n        address target,\n        uint256 amount\n    ) public override returns (uint256) {\n        IERC20(asset).transfer(target, amount);\n        return amount;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Gets the external position library contract for a given type\n    /// @param _typeId The type for which to get the external position library\n    /// @return externalPositionLib_ The external position library\n    function getExternalPositionLibForType(uint256 _typeId)\n        external\n        view\n        override\n        returns (address externalPositionLib_)\n    {\n        return\n            IExternalPositionManager(getExternalPositionManager()).getExternalPositionLibForType(\n                _typeId\n            );\n    }\n\n    /// @notice Sets shares as (permanently) freely transferable\n    /// @dev Once set, this can never be allowed to be unset, as it provides a critical\n    /// transferability guarantee to liquidity pools and other smart contract holders\n    /// that rely on transfers to function properly. Enabling this option will skip all\n    /// policies run upon transferring shares, but will still respect the shares action timelock.\n    function setFreelyTransferableShares() external onlyOwner {\n        require(!sharesAreFreelyTransferable(), \"setFreelyTransferableShares: Already set\");\n\n        freelyTransferableShares = true;\n\n        emit FreelyTransferableSharesSet();\n    }\n\n    ////////////////////////\n    // PERMISSIONED ROLES //\n    ////////////////////////\n\n    /// @notice Registers accounts that can manage vault holdings within the protocol\n    /// @param _managers The accounts to add as asset managers\n    function addAssetManagers(address[] calldata _managers) external onlyOwner {\n        for (uint256 i; i < _managers.length; i++) {\n            require(!isAssetManager(_managers[i]), \"addAssetManagers: Manager already registered\");\n\n            accountToIsAssetManager[_managers[i]] = true;\n\n            emit AssetManagerAdded(_managers[i]);\n        }\n    }\n\n    /// @notice Claim ownership of the contract\n    function claimOwnership() external {\n        address nextOwner = nominatedOwner;\n        require(\n            msg.sender == nextOwner,\n            \"claimOwnership: Only the nominatedOwner can call this function\"\n        );\n\n        delete nominatedOwner;\n\n        address prevOwner = owner;\n        owner = nextOwner;\n\n        emit OwnershipTransferred(prevOwner, nextOwner);\n    }\n\n    /// @notice Deregisters accounts that can manage vault holdings within the protocol\n    /// @param _managers The accounts to remove as asset managers\n    function removeAssetManagers(address[] calldata _managers) external onlyOwner {\n        for (uint256 i; i < _managers.length; i++) {\n            require(isAssetManager(_managers[i]), \"removeAssetManagers: Manager not registered\");\n\n            accountToIsAssetManager[_managers[i]] = false;\n\n            emit AssetManagerRemoved(_managers[i]);\n        }\n    }\n\n    /// @notice Revoke the nomination of a new contract owner\n    function removeNominatedOwner() external onlyOwner {\n        address removedNominatedOwner = nominatedOwner;\n        require(\n            removedNominatedOwner != address(0),\n            \"removeNominatedOwner: There is no nominated owner\"\n        );\n\n        delete nominatedOwner;\n\n        emit NominatedOwnerRemoved(removedNominatedOwner);\n    }\n\n    /// @notice Sets the account that is allowed to migrate a fund to new releases\n    /// @param _nextMigrator The account to set as the allowed migrator\n    /// @dev Set to address(0) to remove the migrator.\n    function setMigrator(address _nextMigrator) external onlyOwner {\n        address prevMigrator = migrator;\n        require(_nextMigrator != prevMigrator, \"setMigrator: Value already set\");\n\n        migrator = _nextMigrator;\n\n        emit MigratorSet(prevMigrator, _nextMigrator);\n    }\n\n    /// @notice Nominate a new contract owner\n    /// @param _nextNominatedOwner The account to nominate\n    /// @dev Does not prohibit overwriting the current nominatedOwner\n    function setNominatedOwner(address _nextNominatedOwner) external onlyOwner {\n        require(\n            _nextNominatedOwner != address(0),\n            \"setNominatedOwner: _nextNominatedOwner cannot be empty\"\n        );\n        require(\n            _nextNominatedOwner != owner,\n            \"setNominatedOwner: _nextNominatedOwner is already the owner\"\n        );\n        require(\n            _nextNominatedOwner != nominatedOwner,\n            \"setNominatedOwner: _nextNominatedOwner is already nominated\"\n        );\n\n        nominatedOwner = _nextNominatedOwner;\n\n        emit NominatedOwnerSet(_nextNominatedOwner);\n    }\n\n    ////////////////////////\n    // FUND DEPLOYER ONLY //\n    ////////////////////////\n\n    /// @notice Updates the accessor during a config change within this release\n    /// @param _nextAccessor The next accessor\n    function setAccessorForFundReconfiguration(address _nextAccessor) external override {\n        require(msg.sender == getFundDeployer(), \"Only the FundDeployer can make this call\");\n\n        __setAccessor(_nextAccessor);\n    }\n\n    ///////////////////////////////////////\n    // ACCESSOR (COMPTROLLER PROXY) ONLY //\n    ///////////////////////////////////////\n\n    //Removed onlyAccessor condition for now\n    /// @notice Adds a tracked asset\n    /// @param _asset The asset to add as a tracked asset\n    function addTrackedAsset(address _asset) external override {\n        __addTrackedAsset(_asset);\n    }\n\n    /// @notice Burns fund shares from a particular account\n    /// @param _target The account for which to burn shares\n    /// @param _amount The amount of shares to burn\n    function burnShares(address _target, uint256 _amount) external override onlyAccessor {\n        __burn(_target, _amount);\n    }\n\n    /// @notice Buys back shares collected as protocol fee at a discounted shares price, using MLN\n    /// @param _sharesAmount The amount of shares to buy back\n    /// @param _mlnValue The MLN-denominated market value of _sharesAmount\n    /// @param _gav The total fund GAV\n    /// @dev Since the vault controls both the MLN to burn and the admin function to burn any user's\n    /// fund shares, there is no need to transfer assets back-and-forth with the ProtocolFeeReserve.\n    /// We only need to know the correct discounted amount of MLN to burn.\n    function buyBackProtocolFeeShares(\n        uint256 _sharesAmount,\n        uint256 _mlnValue,\n        uint256 _gav\n    ) external override onlyAccessor {\n        uint256 mlnAmountToBurn = IProtocolFeeReserve1(getProtocolFeeReserve())\n            .buyBackSharesViaTrustedVaultProxy(_sharesAmount, _mlnValue, _gav);\n\n        if (mlnAmountToBurn == 0) {\n            return;\n        }\n\n        // Burn shares and MLN amounts\n        // If shares or MLN balance is insufficient, will revert\n        __burn(getProtocolFeeReserve(), _sharesAmount);\n        ERC20Burnable(getMlnToken()).burn(mlnAmountToBurn);\n\n        emit ProtocolFeeSharesBoughtBack(_sharesAmount, _mlnValue, mlnAmountToBurn);\n    }\n\n    /// @notice Makes an arbitrary call with this contract as the sender\n    /// @param _contract The contract to call\n    /// @param _callData The call data for the call\n    /// @return returnData_ The data returned by the call\n    function callOnContract(address _contract, bytes calldata _callData)\n        external\n        override\n        onlyAccessor\n        returns (bytes memory returnData_)\n    {\n        bool success;\n        (success, returnData_) = _contract.call(_callData);\n        require(success, string(returnData_));\n\n        return returnData_;\n    }\n\n    /// @notice Mints fund shares to a particular account\n    /// @param _target The account for which to burn shares\n    /// @param _amount The amount of shares to mint\n    function mintShares(address _target, uint256 _amount) external override onlyAccessor {\n        __mint(_target, _amount);\n    }\n\n    /// @notice Pays the due protocol fee by minting shares to the ProtocolFeeReserve\n    function payProtocolFee() external override onlyAccessor {\n        uint256 sharesDue = IProtocolFeeTracker(getProtocolFeeTracker()).payFee();\n\n        if (sharesDue == 0) {\n            return;\n        }\n\n        __mint(getProtocolFeeReserve(), sharesDue);\n\n        emit ProtocolFeePaidInShares(sharesDue);\n    }\n\n    /// @notice Transfers fund shares from one account to another\n    /// @param _from The account from which to transfer shares\n    /// @param _to The account to which to transfer shares\n    /// @param _amount The amount of shares to transfer\n    /// @dev For protocol use only, all other transfers should operate\n    /// via standard ERC20 functions\n    function transferShares(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) external override onlyAccessor {\n        __transfer(_from, _to, _amount);\n    }\n\n    /// @notice Withdraws an asset from the VaultProxy to a given account\n    /// @param _asset The asset to withdraw\n    /// @param _target The account to which to withdraw the asset\n    /// @param _amount The amount of asset to withdraw\n    function withdrawAssetTo(\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) external override {\n        __withdrawAssetTo(_asset, _target, _amount);\n    }\n\n    /// @notice Withdraws an asset from the VaultProxy to a given account\n    /// @param _asset The asset to withdraw\n    /// @param _target The account to which to withdraw the asset\n    /// @param _amount The amount of asset to withdraw\n    function withdrawAssetToVault(\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) external override {\n        __withdrawAssetTo(_asset, _target, _amount);\n    }\n\n    ///////////////////////////\n    // VAULT ACTION DISPATCH //\n    ///////////////////////////\n\n    /// @notice Dispatches a call initiated from an Extension, validated by the ComptrollerProxy\n    /// @param _action The VaultAction to perform\n    /// @param _actionData The call data for the action to perform\n    function receiveValidatedVaultAction(VaultAction _action, bytes calldata _actionData)\n        external\n        override\n        onlyAccessor\n    {\n        if (_action == VaultAction.AddExternalPosition) {\n            __executeVaultActionAddExternalPosition(_actionData);\n        } else if (_action == VaultAction.AddTrackedAsset) {\n            __executeVaultActionAddTrackedAsset(_actionData);\n        } else if (_action == VaultAction.ApproveAssetSpender) {\n            __executeVaultActionApproveAssetSpender(_actionData);\n        } else if (_action == VaultAction.BurnShares) {\n            __executeVaultActionBurnShares(_actionData);\n        } else if (_action == VaultAction.CallOnExternalPosition) {\n            __executeVaultActionCallOnExternalPosition(_actionData);\n        } else if (_action == VaultAction.MintShares) {\n            __executeVaultActionMintShares(_actionData);\n        } else if (_action == VaultAction.RemoveExternalPosition) {\n            __executeVaultActionRemoveExternalPosition(_actionData);\n        } else if (_action == VaultAction.RemoveTrackedAsset) {\n            __executeVaultActionRemoveTrackedAsset(_actionData);\n        } else if (_action == VaultAction.TransferShares) {\n            __executeVaultActionTransferShares(_actionData);\n        } else if (_action == VaultAction.WithdrawAssetTo) {\n            __executeVaultActionWithdrawAssetTo(_actionData);\n        }\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.AddExternalPosition\n    function __executeVaultActionAddExternalPosition(bytes memory _actionData) private {\n        __addExternalPosition(abi.decode(_actionData, (address)));\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.AddTrackedAsset\n    function __executeVaultActionAddTrackedAsset(bytes memory _actionData) private {\n        __addTrackedAsset(abi.decode(_actionData, (address)));\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.ApproveAssetSpender\n    function __executeVaultActionApproveAssetSpender(bytes memory _actionData) private {\n        (address asset, address target, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n\n        __approveAssetSpender(asset, target, amount);\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.BurnShares\n    function __executeVaultActionBurnShares(bytes memory _actionData) private {\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\n\n        __burn(target, amount);\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.CallOnExternalPosition\n    function __executeVaultActionCallOnExternalPosition(bytes memory _actionData) private {\n        (\n            address externalPosition,\n            bytes memory callOnExternalPositionActionData,\n            address[] memory assetsToTransfer,\n            uint256[] memory amountsToTransfer,\n            address[] memory assetsToReceive\n        ) = abi.decode(_actionData, (address, bytes, address[], uint256[], address[]));\n\n        __callOnExternalPosition(\n            externalPosition,\n            callOnExternalPositionActionData,\n            assetsToTransfer,\n            amountsToTransfer,\n            assetsToReceive\n        );\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.MintShares\n    function __executeVaultActionMintShares(bytes memory _actionData) private {\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\n\n        __mint(target, amount);\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.RemoveExternalPosition\n    function __executeVaultActionRemoveExternalPosition(bytes memory _actionData) private {\n        __removeExternalPosition(abi.decode(_actionData, (address)));\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.RemoveTrackedAsset\n    function __executeVaultActionRemoveTrackedAsset(bytes memory _actionData) private {\n        __removeTrackedAsset(abi.decode(_actionData, (address)));\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.TransferShares\n    function __executeVaultActionTransferShares(bytes memory _actionData) private {\n        (address from, address to, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n\n        __transfer(from, to, amount);\n    }\n\n    /// @dev Helper to decode actionData and execute VaultAction.WithdrawAssetTo\n    function __executeVaultActionWithdrawAssetTo(bytes memory _actionData) private {\n        (address asset, address target, uint256 amount) = abi.decode(\n            _actionData,\n            (address, address, uint256)\n        );\n\n        __withdrawAssetTo(asset, target, amount);\n    }\n\n    ///////////////////\n    // VAULT ACTIONS //\n    ///////////////////\n\n    /// @dev Helper to track a new active external position\n    function __addExternalPosition(address _externalPosition) private {\n        if (!isActiveExternalPosition(_externalPosition)) {\n            __validatePositionsLimit();\n\n            externalPositionToIsActive[_externalPosition] = true;\n            activeExternalPositions.push(_externalPosition);\n\n            emit ExternalPositionAdded(_externalPosition);\n        }\n    }\n\n    /// @dev Helper to add a tracked asset\n    function __addTrackedAsset(address _asset) private notShares(_asset) {\n        if (!isTrackedAsset(_asset)) {\n            __validatePositionsLimit();\n\n            assetToIsTracked[_asset] = true;\n            trackedAssets.push(_asset);\n\n            emit TrackedAssetAdded(_asset);\n        }\n    }\n\n    /// @dev Helper to grant an allowance to a spender to use a vault asset\n    function __approveAssetSpender(\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) private notShares(_asset) {\n        ERC20 assetContract = ERC20(_asset);\n        if (assetContract.allowance(address(this), _target) > 0) {\n            assetContract.safeApprove(_target, 0);\n        }\n        assetContract.safeApprove(_target, _amount);\n    }\n\n    /// @dev Helper to make a call on a external position contract\n    /// @param _externalPosition The external position to call\n    /// @param _actionData The action data for the call\n    /// @param _assetsToTransfer The assets to transfer to the external position\n    /// @param _amountsToTransfer The amount of assets to be transferred to the external position\n    /// @param _assetsToReceive The assets that will be received from the call\n    function __callOnExternalPosition(\n        address _externalPosition,\n        bytes memory _actionData,\n        address[] memory _assetsToTransfer,\n        uint256[] memory _amountsToTransfer,\n        address[] memory _assetsToReceive\n    ) private {\n        require(\n            isActiveExternalPosition(_externalPosition),\n            \"__callOnExternalPosition: Not an active external position\"\n        );\n\n        for (uint256 i; i < _assetsToTransfer.length; i++) {\n            __withdrawAssetTo(_assetsToTransfer[i], _externalPosition, _amountsToTransfer[i]);\n        }\n\n        IExternalPosition(_externalPosition).receiveCallFromVault(_actionData);\n\n        for (uint256 i; i < _assetsToReceive.length; i++) {\n            __addTrackedAsset(_assetsToReceive[i]);\n        }\n    }\n\n    /// @dev Helper to the get the Vault's balance of a given asset\n    function __getAssetBalance(address _asset) private view returns (uint256 balance_) {\n        return ERC20(_asset).balanceOf(address(this));\n    }\n\n    /// @dev Helper to remove a external position from the vault\n    function __removeExternalPosition(address _externalPosition) private {\n        if (isActiveExternalPosition(_externalPosition)) {\n            externalPositionToIsActive[_externalPosition] = false;\n\n            activeExternalPositions.removeStorageItem(_externalPosition);\n\n            emit ExternalPositionRemoved(_externalPosition);\n        }\n    }\n\n    /// @dev Helper to remove a tracked asset\n    function __removeTrackedAsset(address _asset) private {\n        if (isTrackedAsset(_asset)) {\n            assetToIsTracked[_asset] = false;\n\n            trackedAssets.removeStorageItem(_asset);\n\n            emit TrackedAssetRemoved(_asset);\n        }\n    }\n\n    /// @dev Helper to validate that the positions limit has not been reached\n    function __validatePositionsLimit() private view {\n        require(\n            trackedAssets.length + activeExternalPositions.length < POSITIONS_LIMIT,\n            \"__validatePositionsLimit: Limit exceeded\"\n        );\n    }\n\n    /// @dev Helper to withdraw an asset from the vault to a specified recipient\n    function __withdrawAssetTo(\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) private notShares(_asset) {\n        ERC20(_asset).transfer(_target, _amount);\n\n        emit AssetWithdrawn(_asset, _target, _amount);\n    }\n\n    ////////////////////////////\n    // SHARES ERC20 OVERRIDES //\n    ////////////////////////////\n\n    /// @notice Gets the `symbol` value of the shares token\n    /// @return symbol_ The `symbol` value\n    /// @dev Defers the shares symbol value to the Dispatcher contract\n    function symbol() public view override returns (string memory symbol_) {\n        return IDispatcher(creator).getSharesTokenSymbol();\n    }\n\n    /// @dev Standard implementation of ERC20's transfer().\n    /// Overridden to allow arbitrary logic in ComptrollerProxy prior to transfer.\n    function transfer(address _recipient, uint256 _amount)\n        public\n        override\n        returns (bool success_)\n    {\n        __invokePreTransferSharesHook(msg.sender, _recipient, _amount);\n\n        return super.transfer(_recipient, _amount);\n    }\n\n    /// @dev Standard implementation of ERC20's transferFrom().\n    /// Overridden to allow arbitrary logic in ComptrollerProxy prior to transfer.\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public override returns (bool success_) {\n        __invokePreTransferSharesHook(_sender, _recipient, _amount);\n\n        return super.transferFrom(_sender, _recipient, _amount);\n    }\n\n    /// @dev Helper to call the relevant preTransferShares hook\n    function __invokePreTransferSharesHook(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) private {\n        if (sharesAreFreelyTransferable()) {\n            IComptroller(accessor).preTransferSharesHookFreelyTransferable(_sender);\n        } else {\n            IComptroller(accessor).preTransferSharesHook(_sender, _recipient, _amount);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Checks whether an account can manage assets\n    /// @param _who The account to check\n    /// @return canManageAssets_ True if the account can manage assets\n    function canManageAssets(address _who) external view override returns (bool canManageAssets_) {\n        return _who == getOwner() || isAssetManager(_who);\n    }\n\n    /// @notice Checks whether an account can use gas relaying\n    /// @param _who The account to check\n    /// @return canRelayCalls_ True if the account can use gas relaying on this fund\n    function canRelayCalls(address _who) external view override returns (bool canRelayCalls_) {\n        return _who == getOwner() || isAssetManager(_who) || _who == getMigrator();\n    }\n\n    /// @notice Gets the `accessor` variable\n    /// @return accessor_ The `accessor` variable value\n    function getAccessor() public view override returns (address accessor_) {\n        return accessor;\n    }\n\n    /// @notice Gets the `creator` variable\n    /// @return creator_ The `creator` variable value\n    function getCreator() external view returns (address creator_) {\n        return creator;\n    }\n\n    /// @notice Gets the `migrator` variable\n    /// @return migrator_ The `migrator` variable value\n    function getMigrator() public view returns (address migrator_) {\n        return migrator;\n    }\n\n    /// @notice Gets the account that is nominated to be the next owner of this contract\n    /// @return nominatedOwner_ The account that is nominated to be the owner\n    function getNominatedOwner() external view returns (address nominatedOwner_) {\n        return nominatedOwner;\n    }\n\n    /// @notice Gets the `activeExternalPositions` variable\n    /// @return activeExternalPositions_ The `activeExternalPositions` variable value\n    function getActiveExternalPositions()\n        external\n        view\n        override\n        returns (address[] memory activeExternalPositions_)\n    {\n        return activeExternalPositions;\n    }\n\n    /// @notice Gets the `trackedAssets` variable\n    /// @return trackedAssets_ The `trackedAssets` variable value\n    function getTrackedAssets() external view override returns (address[] memory trackedAssets_) {\n        return trackedAssets;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the `EXTERNAL_POSITION_MANAGER` variable\n    /// @return externalPositionManager_ The `EXTERNAL_POSITION_MANAGER` variable value\n    function getExternalPositionManager() public view returns (address externalPositionManager_) {\n        return EXTERNAL_POSITION_MANAGER;\n    }\n\n    /// @notice Gets the vaults fund deployer\n    /// @return fundDeployer_ The fund deployer contract associated with this vault\n    function getFundDeployer() public view returns (address fundDeployer_) {\n        return IDispatcher(creator).getFundDeployerForVaultProxy(address(this));\n    }\n\n    /// @notice Gets the `MLN_TOKEN` variable\n    /// @return mlnToken_ The `MLN_TOKEN` variable value\n    function getMlnToken() public view returns (address mlnToken_) {\n        return MLN_TOKEN;\n    }\n\n    /// @notice Gets the `owner` variable\n    /// @return owner_ The `owner` variable value\n    function getOwner() public view override returns (address owner_) {\n        return owner;\n    }\n\n    /// @notice Gets the `PROTOCOL_FEE_RESERVE` variable\n    /// @return protocolFeeReserve_ The `PROTOCOL_FEE_RESERVE` variable value\n    function getProtocolFeeReserve() public view returns (address protocolFeeReserve_) {\n        return PROTOCOL_FEE_RESERVE;\n    }\n\n    /// @notice Gets the `PROTOCOL_FEE_TRACKER` variable\n    /// @return protocolFeeTracker_ The `PROTOCOL_FEE_TRACKER` variable value\n    function getProtocolFeeTracker() public view returns (address protocolFeeTracker_) {\n        return PROTOCOL_FEE_TRACKER;\n    }\n\n    /// @notice Check whether an external position is active on the vault\n    /// @param _externalPosition The externalPosition to check\n    /// @return isActiveExternalPosition_ True if the address is an active external position on the vault\n    function isActiveExternalPosition(address _externalPosition)\n        public\n        view\n        override\n        returns (bool isActiveExternalPosition_)\n    {\n        return externalPositionToIsActive[_externalPosition];\n    }\n\n    /// @notice Checks whether an account is an allowed asset manager\n    /// @param _who The account to check\n    /// @return isAssetManager_ True if the account is an allowed asset manager\n    function isAssetManager(address _who) public view returns (bool isAssetManager_) {\n        return accountToIsAssetManager[_who];\n    }\n\n    /// @notice Checks whether an address is a tracked asset of the vault\n    /// @param _asset The address to check\n    /// @return isTrackedAsset_ True if the address is a tracked asset\n    function isTrackedAsset(address _asset) public view override returns (bool isTrackedAsset_) {\n        return assetToIsTracked[_asset];\n    }\n\n    /// @notice Checks whether shares are (permanently) freely transferable\n    /// @return sharesAreFreelyTransferable_ True if shares are (permanently) freely transferable\n    function sharesAreFreelyTransferable()\n        public\n        view\n        override\n        returns (bool sharesAreFreelyTransferable_)\n    {\n        return freelyTransferableShares;\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n\n    function debugGav(\n        address asset,\n        uint256 balance,\n        address vault\n    ) external view override {\n        console.log(\"calcGav:For asset :%s\", asset);\n        console.log(\"calcGav:Balance asset :%d\", balance);\n        console.log(\"calcGav:proxy vault :%s\", vault);\n    }\n\n    function handleRepayment(address user, uint256 amount) external override {}\n}\n"
    },
    "contracts/release/extensions/fee-manager/FeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../core/fund/comptroller/IComptroller.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../../utils/AddressArrayLib.sol\";\nimport \"../utils/ExtensionBase.sol\";\nimport \"../utils/PermissionedVaultActionMixin.sol\";\nimport \"./IFee.sol\";\nimport \"./IFeeManager.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title FeeManager Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Manages fees for funds\n/// @dev Any arbitrary fee is allowed by default, so all participants must be aware of\n/// their fund's configuration, especially whether they use official fees only.\n/// Fees can only be added upon fund setup, migration, or reconfiguration.\ncontract FeeManager is IFeeManager, ExtensionBase, PermissionedVaultActionMixin {\n    using AddressArrayLib for address[];\n    using SafeMath for uint256;\n\n    event FeeEnabledForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        bytes settingsData\n    );\n\n    event FeeSettledForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        SettlementType indexed settlementType,\n        address payer,\n        address payee,\n        uint256 sharesDue\n    );\n\n    event SharesOutstandingPaidForFund(\n        address indexed comptrollerProxy,\n        address indexed fee,\n        address indexed payee,\n        uint256 sharesDue\n    );\n\n    mapping(address => address[]) private comptrollerProxyToFees;\n    mapping(address => mapping(address => uint256))\n        private comptrollerProxyToFeeToSharesOutstanding;\n\n    constructor(address _fundDeployer) public ExtensionBase(_fundDeployer) {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Activate already-configured fees for use in the calling fund\n    function activateForFund(bool) external override {\n        address comptrollerProxy = msg.sender;\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\n\n        address[] memory enabledFees = getEnabledFeesForFund(comptrollerProxy);\n        for (uint256 i; i < enabledFees.length; i++) {\n            IFee(enabledFees[i]).activateForFund(comptrollerProxy, vaultProxy);\n        }\n    }\n\n    /// @notice Deactivate fees for a fund\n    /// @dev There will be no fees if the caller is not a valid ComptrollerProxy\n    function deactivateForFund() external override {\n        address comptrollerProxy = msg.sender;\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\n\n        // Force payout of remaining shares outstanding\n        address[] memory fees = getEnabledFeesForFund(comptrollerProxy);\n        for (uint256 i; i < fees.length; i++) {\n            __payoutSharesOutstanding(comptrollerProxy, vaultProxy, fees[i]);\n        }\n    }\n\n    /// @notice Allows all fees for a particular FeeHook to implement settle() and update() logic\n    /// @param _hook The FeeHook to invoke\n    /// @param _settlementData The encoded settlement parameters specific to the FeeHook\n    /// @param _gav The GAV for a fund if known in the invocating code, otherwise 0\n    function invokeHook(\n        FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    ) external override {\n        __invokeHook(msg.sender, _hook, _settlementData, _gav, true);\n    }\n\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\n    /// @param _actionId An ID representing the desired action\n    /// @param _callArgs Encoded arguments specific to the _actionId\n    /// @dev This is the only way to call a function on this contract that updates VaultProxy state.\n    /// For both of these actions, any caller is allowed, so we don't use the caller param.\n    function receiveCallFromComptroller(\n        address,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override {\n        if (_actionId == 0) {\n            // Settle and update all continuous fees\n            __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \"\", 0, true);\n        } else if (_actionId == 1) {\n            __payoutSharesOutstandingForFees(msg.sender, _callArgs);\n        } else {\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\n        }\n    }\n\n    /// @notice Enable and configure fees for use in the calling fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _configData Encoded config data\n    /// @dev The order of `fees` determines the order in which fees of the same FeeHook will be applied.\n    /// It is recommended to run ManagementFee before PerformanceFee in order to achieve precise\n    /// PerformanceFee calcs.\n    function setConfigForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes calldata _configData\n    ) external override onlyFundDeployer {\n        console.log(\"FeeManager:setConfigForFund:sender  %s\", msg.sender);\n\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\n\n        console.log(\"FeeManager:setConfigForFund:__setValidatedVaultProxy\");\n        console.logBytes(_configData);\n\n        (address[3] memory fees, bytes[3] memory settingsData) = abi.decode(\n            _configData,\n            (address[3], bytes[3])\n        );\n        console.log(\"FeeManager:abi decode\");\n\n        for (uint256 i; i < fees.length; i++) {\n            console.log(\"FeeManager:setConfigForFund:fees: %s\", fees[i]);\n            console.logBytes(settingsData[i]);\n        }\n\n        console.log(\"FeeManager:setConfigForFund:settingsData\");\n        // Sanity checks\n        require(\n            fees.length == settingsData.length,\n            \"setConfigForFund: fees and settingsData array lengths unequal\"\n        );\n        console.log(\"FeeManager:setConfigForFund:first require\");\n\n        //require(fees.isUniqueSet(), \"setConfigForFund: fees cannot include duplicates\");\n\n        console.log(\"FeeManager:setConfigForFund:second require\");\n        // Enable each fee with settings\n        for (uint256 i; i < fees.length; i++) {\n            console.log(\"FeeManager:setConfigForFund:loop: %d\", i);\n            // Set fund config on fee\n            IFee(fees[i]).addFundSettings(_comptrollerProxy, settingsData[i]);\n            console.log(\"FeeManager:setConfigForFund:addFundSettings\");\n            // Enable fee for fund\n            comptrollerProxyToFees[_comptrollerProxy].push(fees[i]);\n            console.log(\"FeeManager:setConfigForFund:comptrollerProxyToFees\");\n            emit FeeEnabledForFund(_comptrollerProxy, fees[i], settingsData[i]);\n        }\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to get the canonical value of GAV if not yet set and required by fee\n    function __getGavAsNecessary(address _comptrollerProxy, uint256 _gavOrZero)\n        private\n        returns (uint256 gav_)\n    {\n        if (_gavOrZero == 0) {\n            // Do not finalize synths, as this can lead to lost fees when redeeming shares\n            return IComptroller(_comptrollerProxy).calcGav(false);\n        } else {\n            return _gavOrZero;\n        }\n    }\n\n    /// @dev Helper to run settle() on all enabled fees for a fund that implement a given hook, and then to\n    /// optionally run update() on the same fees. This order allows fees an opportunity to update\n    /// their local state after all VaultProxy state transitions (i.e., minting, burning,\n    /// transferring shares) have finished. To optimize for the expensive operation of calculating\n    /// GAV, once one fee requires GAV, we recycle that `gav` value for subsequent fees.\n    /// Assumes that _gav is either 0 or has already been validated.\n    function __invokeHook(\n        address _comptrollerProxy,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero,\n        bool _updateFees\n    ) private {\n        address[] memory fees = getEnabledFeesForFund(_comptrollerProxy);\n        if (fees.length == 0) {\n            return;\n        }\n\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\n\n        // This check isn't strictly necessary, but its cost is insignificant,\n        // and helps to preserve data integrity.\n        require(vaultProxy != address(0), \"__invokeHook: Fund is not active\");\n\n        // First, allow all fees to implement settle()\n        uint256 gav = __settleFees(\n            _comptrollerProxy,\n            vaultProxy,\n            fees,\n            _hook,\n            _settlementData,\n            _gavOrZero\n        );\n\n        // Second, allow fees to implement update()\n        // This function does not allow any further altering of VaultProxy state\n        // (i.e., burning, minting, or transferring shares)\n        if (_updateFees) {\n            __updateFees(_comptrollerProxy, vaultProxy, fees, _hook, _settlementData, gav);\n        }\n    }\n\n    /// @dev Helper to get the end recipient for a given fee and fund\n    function __parseFeeRecipientForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _fee\n    ) private view returns (address recipient_) {\n        recipient_ = IFee(_fee).getRecipientForFund(_comptrollerProxy);\n        if (recipient_ == address(0)) {\n            recipient_ = IVault(_vaultProxy).getOwner();\n        }\n\n        return recipient_;\n    }\n\n    /// @dev Helper to payout the shares outstanding for the specified fees.\n    /// Does not call settle() on fees.\n    /// Only callable via ComptrollerProxy.callOnExtension().\n    function __payoutSharesOutstandingForFees(address _comptrollerProxy, bytes memory _callArgs)\n        private\n    {\n        address[] memory fees = abi.decode(_callArgs, (address[]));\n        address vaultProxy = getVaultProxyForFund(msg.sender);\n\n        for (uint256 i; i < fees.length; i++) {\n            if (IFee(fees[i]).payout(_comptrollerProxy, vaultProxy)) {\n                __payoutSharesOutstanding(_comptrollerProxy, vaultProxy, fees[i]);\n            }\n        }\n    }\n\n    /// @dev Helper to payout shares outstanding for a given fee.\n    /// Assumes the fee is payout-able.\n    function __payoutSharesOutstanding(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _fee\n    ) private {\n        uint256 sharesOutstanding = getFeeSharesOutstandingForFund(_comptrollerProxy, _fee);\n        if (sharesOutstanding == 0) {\n            return;\n        }\n\n        delete comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\n\n        address payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\n\n        __transferShares(_comptrollerProxy, _vaultProxy, payee, sharesOutstanding);\n\n        emit SharesOutstandingPaidForFund(_comptrollerProxy, _fee, payee, sharesOutstanding);\n    }\n\n    /// @dev Helper to settle a fee\n    function __settleFee(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _fee,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gav\n    ) private {\n        (SettlementType settlementType, address payer, uint256 sharesDue) = IFee(_fee).settle(\n            _comptrollerProxy,\n            _vaultProxy,\n            _hook,\n            _settlementData,\n            _gav\n        );\n        if (settlementType == SettlementType.None) {\n            return;\n        }\n\n        address payee;\n        if (settlementType == SettlementType.Direct) {\n            payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\n            __transferShares(_comptrollerProxy, payer, payee, sharesDue);\n        } else if (settlementType == SettlementType.Mint) {\n            payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\n            __mintShares(_comptrollerProxy, payee, sharesDue);\n        } else if (settlementType == SettlementType.Burn) {\n            __burnShares(_comptrollerProxy, payer, sharesDue);\n        } else if (settlementType == SettlementType.MintSharesOutstanding) {\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\n                .add(sharesDue);\n\n            payee = _vaultProxy;\n            __mintShares(_comptrollerProxy, payee, sharesDue);\n        } else if (settlementType == SettlementType.BurnSharesOutstanding) {\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\n                .sub(sharesDue);\n\n            payer = _vaultProxy;\n            __burnShares(_comptrollerProxy, payer, sharesDue);\n        } else {\n            revert(\"__settleFee: Invalid SettlementType\");\n        }\n\n        emit FeeSettledForFund(_comptrollerProxy, _fee, settlementType, payer, payee, sharesDue);\n    }\n\n    /// @dev Helper to settle fees that implement a given fee hook\n    function __settleFees(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address[] memory _fees,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero\n    ) private returns (uint256 gav_) {\n        gav_ = _gavOrZero;\n\n        for (uint256 i; i < _fees.length; i++) {\n            (bool settles, bool usesGav) = IFee(_fees[i]).settlesOnHook(_hook);\n            if (!settles) {\n                continue;\n            }\n\n            if (usesGav) {\n                gav_ = __getGavAsNecessary(_comptrollerProxy, gav_);\n            }\n\n            __settleFee(_comptrollerProxy, _vaultProxy, _fees[i], _hook, _settlementData, gav_);\n        }\n\n        return gav_;\n    }\n\n    /// @dev Helper to update fees that implement a given fee hook\n    function __updateFees(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address[] memory _fees,\n        FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gavOrZero\n    ) private {\n        uint256 gav = _gavOrZero;\n\n        for (uint256 i; i < _fees.length; i++) {\n            (bool updates, bool usesGav) = IFee(_fees[i]).updatesOnHook(_hook);\n            if (!updates) {\n                continue;\n            }\n\n            if (usesGav) {\n                gav = __getGavAsNecessary(_comptrollerProxy, gav);\n            }\n\n            IFee(_fees[i]).update(_comptrollerProxy, _vaultProxy, _hook, _settlementData, gav);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Get a list of enabled fees for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return enabledFees_ An array of enabled fee addresses\n    function getEnabledFeesForFund(address _comptrollerProxy)\n        public\n        view\n        returns (address[] memory enabledFees_)\n    {\n        return comptrollerProxyToFees[_comptrollerProxy];\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Get the amount of shares outstanding for a particular fee for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _fee The fee address\n    /// @return sharesOutstanding_ The amount of shares outstanding\n    function getFeeSharesOutstandingForFund(address _comptrollerProxy, address _fee)\n        public\n        view\n        returns (uint256 sharesOutstanding_)\n    {\n        return comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\n    }\n}\n"
    },
    "contracts/release/infrastructure/protocol-fees/ProtocolFeeTracker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../utils/FundDeployerOwnerMixin.sol\";\nimport \"./IProtocolFeeTracker.sol\";\n\n/// @title ProtocolFeeTracker Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The contract responsible for tracking owed protocol fees\ncontract ProtocolFeeTracker is IProtocolFeeTracker, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event InitializedForVault(address vaultProxy);\n\n    event FeeBpsDefaultSet(uint256 nextFeeBpsDefault);\n\n    event FeeBpsOverrideSetForVault(address indexed vaultProxy, uint256 nextFeeBpsOverride);\n\n    event FeePaidForVault(address indexed vaultProxy, uint256 sharesAmount, uint256 secondsPaid);\n\n    event LastPaidSetForVault(\n        address indexed vaultProxy,\n        uint256 prevTimestamp,\n        uint256 nextTimestamp\n    );\n\n    uint256 private constant MAX_BPS = 10000;\n    uint256 private constant SECONDS_IN_YEAR = 31557600; // 60*60*24*365.25\n\n    uint256 private feeBpsDefault;\n    mapping(address => uint256) private vaultProxyToFeeBpsOverride;\n    mapping(address => uint256) private vaultProxyToLastPaid;\n\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {\n        // Validate constants\n        require(\n            SECONDS_IN_YEAR == (60 * 60 * 24 * 36525) / 100,\n            \"constructor: Incorrect SECONDS_IN_YEAR\"\n        );\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Initializes protocol fee tracking for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @dev Does not validate whether _vaultProxy is already initialized,\n    /// as FundDeployer will only do this once\n    function initializeForVault(address _vaultProxy) external override {\n        require(msg.sender == getFundDeployer(), \"Only the FundDeployer can call this function\");\n\n        __setLastPaidForVault(_vaultProxy, block.timestamp);\n\n        emit InitializedForVault(_vaultProxy);\n    }\n\n    /// @notice Marks the protocol fee as paid for the sender, and gets the amount of shares that\n    /// should be minted for payment\n    /// @return sharesDue_ The amount of shares to be minted for payment\n    /// @dev This trusts the VaultProxy to mint the correct sharesDue_.\n    /// There is no need to validate that the VaultProxy is still on this release.\n    function payFee() external override returns (uint256 sharesDue_) {\n        address vaultProxy = msg.sender;\n\n        // VaultProxy is validated during initialization\n        uint256 lastPaid = getLastPaidForVault(vaultProxy);\n        if (lastPaid >= block.timestamp) {\n            return 0;\n        }\n\n        // Not strictly necessary as we trust the FundDeployer to have already initialized the\n        // VaultProxy, but inexpensive\n        require(lastPaid > 0, \"payFee: VaultProxy not initialized\");\n\n        uint256 secondsDue = block.timestamp.sub(lastPaid);\n        sharesDue_ = __calcSharesDueForVault(vaultProxy, secondsDue);\n\n        // Even if sharesDue_ is 0, we update the lastPaid timestamp and emit the event\n        __setLastPaidForVault(vaultProxy, block.timestamp);\n\n        emit FeePaidForVault(vaultProxy, sharesDue_, secondsDue);\n\n        return sharesDue_;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the protocol fee rate (in bps) for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @return feeBps_ The protocol fee (in bps)\n    function getFeeBpsForVault(address _vaultProxy) public view returns (uint256 feeBps_) {\n        feeBps_ = getFeeBpsOverrideForVault(_vaultProxy);\n\n        if (feeBps_ == 0) {\n            feeBps_ = getFeeBpsDefault();\n        }\n\n        return feeBps_;\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to calculate the protocol fee shares due for a given VaultProxy\n    function __calcSharesDueForVault(address _vaultProxy, uint256 _secondsDue)\n        private\n        view\n        returns (uint256 sharesDue_)\n    {\n        uint256 sharesSupply = ERC20(_vaultProxy).totalSupply();\n\n        uint256 rawSharesDue = sharesSupply\n            .mul(getFeeBpsForVault(_vaultProxy))\n            .mul(_secondsDue)\n            .div(SECONDS_IN_YEAR)\n            .div(MAX_BPS);\n\n        uint256 supplyNetRawSharesDue = sharesSupply.sub(rawSharesDue);\n        if (supplyNetRawSharesDue == 0) {\n            return 0;\n        }\n\n        return rawSharesDue.mul(sharesSupply).div(supplyNetRawSharesDue);\n    }\n\n    /// @dev Helper to set the lastPaid timestamp for a given VaultProxy\n    function __setLastPaidForVault(address _vaultProxy, uint256 _nextTimestamp) private {\n        vaultProxyToLastPaid[_vaultProxy] = _nextTimestamp;\n    }\n\n    ////////////////\n    // ADMIN ONLY //\n    ////////////////\n\n    /// @notice Sets the default protocol fee rate (in bps)\n    /// @param _nextFeeBpsDefault The default protocol fee rate (in bps) to set\n    function setFeeBpsDefault(uint256 _nextFeeBpsDefault) external onlyFundDeployerOwner {\n        require(_nextFeeBpsDefault < MAX_BPS, \"setDefaultFeeBps: Exceeds max\");\n\n        feeBpsDefault = _nextFeeBpsDefault;\n\n        emit FeeBpsDefaultSet(_nextFeeBpsDefault);\n    }\n\n    /// @notice Sets a specified protocol fee rate (in bps) for a particular VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @param _nextFeeBpsOverride The protocol fee rate (in bps) to set\n    function setFeeBpsOverrideForVault(address _vaultProxy, uint256 _nextFeeBpsOverride)\n        external\n        onlyFundDeployerOwner\n    {\n        require(_nextFeeBpsOverride < MAX_BPS, \"setFeeBpsOverrideForVault: Exceeds max\");\n\n        vaultProxyToFeeBpsOverride[_vaultProxy] = _nextFeeBpsOverride;\n\n        emit FeeBpsOverrideSetForVault(_vaultProxy, _nextFeeBpsOverride);\n    }\n\n    /// @notice Sets the lastPaid timestamp for a specified VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @param _nextTimestamp The lastPaid timestamp to set\n    function setLastPaidForVault(address _vaultProxy, uint256 _nextTimestamp)\n        external\n        onlyFundDeployerOwner\n    {\n        uint256 prevTimestamp = getLastPaidForVault(_vaultProxy);\n        require(prevTimestamp > 0, \"setLastPaidForVault: _vaultProxy not initialized\");\n        require(\n            _nextTimestamp > prevTimestamp || _nextTimestamp > block.timestamp,\n            \"setLastPaidForVault: Can only increase or set a future timestamp\"\n        );\n\n        __setLastPaidForVault(_vaultProxy, _nextTimestamp);\n\n        emit LastPaidSetForVault(_vaultProxy, prevTimestamp, _nextTimestamp);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `feeBpsDefault` variable value\n    /// @return feeBpsDefault_ The `feeBpsDefault` variable value\n    function getFeeBpsDefault() public view returns (uint256 feeBpsDefault_) {\n        return feeBpsDefault;\n    }\n\n    /// @notice Gets the feeBpsOverride value for the given VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @return feeBpsOverride_ The feeBpsOverride value\n    function getFeeBpsOverrideForVault(address _vaultProxy)\n        public\n        view\n        returns (uint256 feeBpsOverride_)\n    {\n        return vaultProxyToFeeBpsOverride[_vaultProxy];\n    }\n\n    /// @notice Gets the lastPaid value for the given VaultProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @return lastPaid_ The lastPaid value\n    function getLastPaidForVault(address _vaultProxy) public view returns (uint256 lastPaid_) {\n        return vaultProxyToLastPaid[_vaultProxy];\n    }\n}\n"
    },
    "contracts/persistent/dispatcher/IDispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IDispatcher Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IDispatcher {\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function claimOwnership() external;\n\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external returns (address vaultProxy_);\n\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\n\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\n\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (address fundDeployer_);\n\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        );\n\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\n\n    function getNominatedOwner() external view returns (address nominatedOwner_);\n\n    function getOwner() external view returns (address owner_);\n\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\n\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (uint256 secondsRemaining_);\n\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasExecutableRequest_);\n\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        returns (bool hasMigrationRequest_);\n\n    function removeNominatedOwner() external;\n\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\n\n    function setMigrationTimelock(uint256 _nextTimelock) external;\n\n    function setNominatedOwner(address _nextNominatedOwner) external;\n\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\n\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external;\n}\n"
    },
    "contracts/persistent/external-positions/IExternalPosition.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExternalPosition Contract\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IExternalPosition {\n    function getDebtAssets() external returns (address[] memory, uint256[] memory);\n\n    function getManagedAssets() external returns (address[] memory, uint256[] memory);\n\n    function init(bytes memory) external;\n\n    function receiveCallFromVault(bytes memory) external;\n}\n"
    },
    "contracts/release/extensions/IExtension.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExtension Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all extensions\ninterface IExtension {\n    function activateForFund(bool _isMigration) external;\n\n    function deactivateForFund() external;\n\n    function receiveCallFromComptroller(\n        address _caller,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external;\n\n    function setConfigForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes calldata _configData\n    ) external;\n}\n"
    },
    "contracts/release/extensions/fee-manager/IFeeManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title FeeManager Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the FeeManager\ninterface IFeeManager {\n    // No fees for the current release are implemented post-redeemShares\n    enum FeeHook {Continuous, PreBuyShares, PostBuyShares, PreRedeemShares}\n    enum SettlementType {None, Direct, Mint, Burn, MintSharesOutstanding, BurnSharesOutstanding}\n\n    function invokeHook(\n        FeeHook,\n        bytes calldata,\n        uint256\n    ) external;\n}\n"
    },
    "contracts/release/extensions/policy-manager/IPolicyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title PolicyManager Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the PolicyManager\ninterface IPolicyManager {\n    // When updating PolicyHook, also update these functions in PolicyManager:\n    // 1. __getAllPolicyHooks()\n    // 2. __policyHookRestrictsCurrentInvestorActions()\n    enum PolicyHook {\n        PostBuyShares,\n        PostCallOnIntegration,\n        PreTransferShares,\n        RedeemSharesForSpecificAssets,\n        AddTrackedAssets,\n        RemoveTrackedAssets,\n        CreateExternalPosition,\n        PostCallOnExternalPosition,\n        RemoveExternalPosition,\n        ReactivateExternalPosition\n    }\n\n    function validatePolicies(\n        address,\n        PolicyHook,\n        bytes calldata\n    ) external;\n}\n"
    },
    "contracts/release/infrastructure/asset-finality/IAssetFinalityResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IAssetFinalityResolver Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IAssetFinalityResolver {\n    function finalizeAssets(address, address[] calldata) external;\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/GasRelayRecipientMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\nimport \"../../utils/beacon-proxy/IBeaconProxyFactory.sol\";\nimport \"./IGasRelayPaymaster.sol\";\n\npragma solidity 0.6.12;\n\n/// @title GasRelayRecipientMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin that enables receiving GSN-relayed calls\n/// @dev IMPORTANT: Do not use storage var in this contract,\n/// unless it is no longer inherited by the VaultLib\nabstract contract GasRelayRecipientMixin {\n    address internal immutable GAS_RELAY_PAYMASTER_FACTORY;\n\n    constructor(address _gasRelayPaymasterFactory) internal {\n        GAS_RELAY_PAYMASTER_FACTORY = _gasRelayPaymasterFactory;\n    }\n\n    /// @dev Helper to parse the canonical sender of a tx based on whether it has been relayed\n    function __msgSender() internal view returns (address payable canonicalSender_) {\n        if (msg.data.length >= 24 && msg.sender == getGasRelayTrustedForwarder()) {\n            assembly {\n                canonicalSender_ := shr(96, calldataload(sub(calldatasize(), 20)))\n            }\n\n            return canonicalSender_;\n        }\n\n        return msg.sender;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `GAS_RELAY_PAYMASTER_FACTORY` variable\n    /// @return gasRelayPaymasterFactory_ The `GAS_RELAY_PAYMASTER_FACTORY` variable value\n    function getGasRelayPaymasterFactory()\n        public\n        view\n        returns (address gasRelayPaymasterFactory_)\n    {\n        return GAS_RELAY_PAYMASTER_FACTORY;\n    }\n\n    /// @notice Gets the trusted forwarder for GSN relaying\n    /// @return trustedForwarder_ The trusted forwarder\n    function getGasRelayTrustedForwarder() public view returns (address trustedForwarder_) {\n        return\n            IGasRelayPaymaster(\n                IBeaconProxyFactory(getGasRelayPaymasterFactory()).getCanonicalLib()\n            )\n                .trustedForwarder();\n    }\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/IGasRelayPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../interfaces/IGsnPaymaster.sol\";\n\n/// @title IGasRelayPaymaster Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGasRelayPaymaster is IGsnPaymaster {\n    function deposit() external;\n\n    function withdrawBalance() external;\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/IGasRelayPaymasterDepositor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IGasRelayPaymasterDepositor Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGasRelayPaymasterDepositor {\n    function pullWethForGasRelayer(uint256) external;\n}\n"
    },
    "contracts/release/utils/beacon-proxy/IBeaconProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\nimport \"./IBeacon.sol\";\n\npragma solidity 0.6.12;\n\n/// @title IBeaconProxyFactory interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IBeaconProxyFactory is IBeacon {\n    function deployProxy(bytes memory _constructData) external returns (address proxy_);\n\n    function setCanonicalLib(address _canonicalLib) external;\n}\n"
    },
    "contracts/release/utils/AddressArrayLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title AddressArray Library\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A library to extend the address array data type\nlibrary AddressArrayLib {\n    /////////////\n    // STORAGE //\n    /////////////\n\n    /// @dev Helper to remove an item from a storage array\n    function removeStorageItem(address[] storage _self, address _itemToRemove)\n        internal\n        returns (bool removed_)\n    {\n        uint256 itemCount = _self.length;\n        for (uint256 i; i < itemCount; i++) {\n            if (_self[i] == _itemToRemove) {\n                if (i < itemCount - 1) {\n                    _self[i] = _self[itemCount - 1];\n                }\n                _self.pop();\n                removed_ = true;\n                break;\n            }\n        }\n\n        return removed_;\n    }\n\n    ////////////\n    // MEMORY //\n    ////////////\n\n    /// @dev Helper to add an item to an array. Does not assert uniqueness of the new item.\n    function addItem(address[] memory _self, address _itemToAdd)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        nextArray_ = new address[](_self.length + 1);\n        for (uint256 i; i < _self.length; i++) {\n            nextArray_[i] = _self[i];\n        }\n        nextArray_[_self.length] = _itemToAdd;\n\n        return nextArray_;\n    }\n\n    /// @dev Helper to add an item to an array, only if it is not already in the array.\n    function addUniqueItem(address[] memory _self, address _itemToAdd)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        if (contains(_self, _itemToAdd)) {\n            return _self;\n        }\n\n        return addItem(_self, _itemToAdd);\n    }\n\n    /// @dev Helper to verify if an array contains a particular value\n    function contains(address[] memory _self, address _target)\n        internal\n        pure\n        returns (bool doesContain_)\n    {\n        for (uint256 i; i < _self.length; i++) {\n            if (_target == _self[i]) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /// @dev Helper to merge the unique items of a second array.\n    /// Does not consider uniqueness of either array, only relative uniqueness.\n    /// Preserves ordering.\n    function mergeArray(address[] memory _self, address[] memory _arrayToMerge)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        uint256 newUniqueItemCount;\n        for (uint256 i; i < _arrayToMerge.length; i++) {\n            if (!contains(_self, _arrayToMerge[i])) {\n                newUniqueItemCount++;\n            }\n        }\n\n        if (newUniqueItemCount == 0) {\n            return _self;\n        }\n\n        nextArray_ = new address[](_self.length + newUniqueItemCount);\n        for (uint256 i; i < _self.length; i++) {\n            nextArray_[i] = _self[i];\n        }\n        uint256 nextArrayIndex = _self.length;\n        for (uint256 i; i < _arrayToMerge.length; i++) {\n            if (!contains(_self, _arrayToMerge[i])) {\n                nextArray_[nextArrayIndex] = _arrayToMerge[i];\n                nextArrayIndex++;\n            }\n        }\n\n        return nextArray_;\n    }\n\n    /// @dev Helper to verify if array is a set of unique values.\n    /// Does not assert length > 0.\n    function isUniqueSet(address[] memory _self) internal pure returns (bool isUnique_) {\n        if (_self.length <= 1) {\n            return true;\n        }\n\n        uint256 arrayLength = _self.length;\n        for (uint256 i; i < arrayLength; i++) {\n            for (uint256 j = i + 1; j < arrayLength; j++) {\n                if (_self[i] == _self[j]) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    /// @dev Helper to remove items from an array. Removes all matching occurrences of each item.\n    /// Does not assert uniqueness of either array.\n    function removeItems(address[] memory _self, address[] memory _itemsToRemove)\n        internal\n        pure\n        returns (address[] memory nextArray_)\n    {\n        if (_itemsToRemove.length == 0) {\n            return _self;\n        }\n\n        bool[] memory indexesToRemove = new bool[](_self.length);\n        uint256 remainingItemsCount = _self.length;\n        for (uint256 i; i < _self.length; i++) {\n            if (contains(_itemsToRemove, _self[i])) {\n                indexesToRemove[i] = true;\n                remainingItemsCount--;\n            }\n        }\n\n        if (remainingItemsCount == _self.length) {\n            nextArray_ = _self;\n        } else if (remainingItemsCount > 0) {\n            nextArray_ = new address[](remainingItemsCount);\n            uint256 nextArrayIndex;\n            for (uint256 i; i < _self.length; i++) {\n                if (!indexesToRemove[i]) {\n                    nextArray_[nextArrayIndex] = _self[i];\n                    nextArrayIndex++;\n                }\n            }\n        }\n\n        return nextArray_;\n    }\n}\n"
    },
    "contracts/release/core/fund/vault/IVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../persistent/vault/interfaces/IExternalPositionVault.sol\";\nimport \"../../../../persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\";\nimport \"../../../../persistent/vault/interfaces/IMigratableVault.sol\";\n\n/// @title IVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IVault is IMigratableVault, IFreelyTransferableSharesVault, IExternalPositionVault {\n    enum VaultAction {\n        None,\n        // Shares management\n        BurnShares,\n        MintShares,\n        TransferShares,\n        // Asset management\n        AddTrackedAsset,\n        ApproveAssetSpender,\n        RemoveTrackedAsset,\n        WithdrawAssetTo,\n        // External position management\n        AddExternalPosition,\n        CallOnExternalPosition,\n        RemoveExternalPosition\n    }\n\n    function addTrackedAsset(address) external;\n\n    function burnShares(address, uint256) external;\n\n    function buyBackProtocolFeeShares(\n        uint256,\n        uint256,\n        uint256\n    ) external;\n\n    function callOnContract(address, bytes calldata) external returns (bytes memory);\n\n    function canManageAssets(address) external view returns (bool);\n\n    function canRelayCalls(address) external view returns (bool);\n\n    function getAccessor() external view returns (address);\n\n    function getOwner() external view returns (address);\n\n    function getActiveExternalPositions() external view returns (address[] memory);\n\n    function getTrackedAssets() external view returns (address[] memory);\n\n    function isActiveExternalPosition(address) external view returns (bool);\n\n    function isTrackedAsset(address) external view returns (bool);\n\n    function mintShares(address, uint256) external;\n\n    function payProtocolFee() external;\n\n    function receiveValidatedVaultAction(VaultAction, bytes calldata) external;\n\n    function setAccessorForFundReconfiguration(address) external;\n\n    function transferShares(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function withdrawAssetTo(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function withdrawAssetToVault(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function transferUnderlyingTo(\n        address asset,\n        address target,\n        uint256 amount\n    ) external returns (uint256);\n\n    function debugGav(\n        address,\n        uint256,\n        address\n    ) external view;\n\n    function handleRepayment(address, uint256) external;\n}\n"
    },
    "contracts/release/core/fund/comptroller/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../vault/IVault.sol\";\n\n/// @title IComptroller Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IComptroller {\n    function activate(bool) external;\n\n    function calcGav(bool) external returns (uint256);\n\n    function calcGrossShareValue(bool) external returns (uint256);\n\n    function callOnExtension(\n        address,\n        uint256,\n        bytes calldata\n    ) external;\n\n    function destructActivated(uint256, uint256) external;\n\n    function destructUnactivated() external;\n\n    function getDenominationAsset() external view returns (address);\n\n    function getExternalPositionManager() external view returns (address);\n\n    function getFeeManager() external view returns (address);\n\n    function getFundDeployer() external view returns (address);\n\n    function getGasRelayPaymaster() external view returns (address);\n\n    function getIntegrationManager() external view returns (address);\n\n    function getPolicyManager() external view returns (address);\n\n    function getVaultProxy() external view returns (address);\n\n    function init(address, uint256) external;\n\n    function permissionedVaultAction(IVault.VaultAction, bytes calldata) external;\n\n    function preTransferSharesHook(\n        address,\n        address,\n        uint256\n    ) external;\n\n    function preTransferSharesHookFreelyTransferable(address) external view;\n\n    function setGasRelayPaymaster(address) external;\n\n    function setVaultProxy(address) external;\n}\n"
    },
    "contracts/release/utils/beacon-proxy/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IBeacon interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IBeacon {\n    function getCanonicalLib() external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/IGsnPaymaster.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IGsnTypes.sol\";\n\n/// @title IGsnPaymaster interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGsnPaymaster {\n    struct GasAndDataLimits {\n        uint256 acceptanceBudget;\n        uint256 preRelayedCallGasLimit;\n        uint256 postRelayedCallGasLimit;\n        uint256 calldataSizeLimit;\n    }\n\n    function getGasAndDataLimits() external view returns (GasAndDataLimits memory limits);\n\n    function getHubAddr() external view returns (address);\n\n    function getRelayHubDeposit() external view returns (uint256);\n\n    function preRelayedCall(\n        IGsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 maxPossibleGas\n    ) external returns (bytes memory context, bool rejectOnRecipientRevert);\n\n    function postRelayedCall(\n        bytes calldata context,\n        bool success,\n        uint256 gasUseWithoutPost,\n        IGsnTypes.RelayData calldata relayData\n    ) external;\n\n    function trustedForwarder() external view returns (address);\n\n    function versionPaymaster() external view returns (string memory);\n}\n"
    },
    "contracts/release/interfaces/IGsnTypes.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IGsnForwarder.sol\";\n\n/// @title IGsnTypes Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGsnTypes {\n    struct RelayData {\n        uint256 gasPrice;\n        uint256 pctRelayFee;\n        uint256 baseRelayFee;\n        address relayWorker;\n        address paymaster;\n        address forwarder;\n        bytes paymasterData;\n        uint256 clientId;\n    }\n\n    struct RelayRequest {\n        IGsnForwarder.ForwardRequest request;\n        RelayData relayData;\n    }\n}\n"
    },
    "contracts/release/interfaces/IGsnForwarder.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IGsnForwarder interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGsnForwarder {\n    struct ForwardRequest {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint256 nonce;\n        bytes data;\n        uint256 validUntil;\n    }\n}\n"
    },
    "contracts/persistent/vault/interfaces/IExternalPositionVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExternalPositionVault interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// Provides an interface to get the externalPositionLib for a given type from the Vault\ninterface IExternalPositionVault {\n    function getExternalPositionLibForType(uint256) external view returns (address);\n}\n"
    },
    "contracts/persistent/vault/interfaces/IFreelyTransferableSharesVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IFreelyTransferableSharesVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Provides the interface for determining whether a vault's shares\n/// are guaranteed to be freely transferable.\n/// @dev DO NOT EDIT CONTRACT\ninterface IFreelyTransferableSharesVault {\n    function sharesAreFreelyTransferable()\n        external\n        view\n        returns (bool sharesAreFreelyTransferable_);\n}\n"
    },
    "contracts/persistent/vault/interfaces/IMigratableVault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IMigratableVault Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev DO NOT EDIT CONTRACT\ninterface IMigratableVault {\n    function canMigrate(address _who) external view returns (bool canMigrate_);\n\n    function init(\n        address _owner,\n        address _accessor,\n        string calldata _fundName\n    ) external;\n\n    function setAccessor(address _nextAccessor) external;\n\n    function setVaultLib(address _nextVaultLib) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../../utils/Context.sol\";\nimport \"./ERC20.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    using SafeMath for uint256;\n\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \"ERC20: burn amount exceeds allowance\");\n\n        _approve(account, _msgSender(), decreasedAllowance);\n        _burn(account, amount);\n    }\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/interfaces/IProtocolFeeReserve1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IProtocolFeeReserve1 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev Each interface should inherit the previous interface,\n/// e.g., `IProtocolFeeReserve2 is IProtocolFeeReserve1`\ninterface IProtocolFeeReserve1 {\n    function buyBackSharesViaTrustedVaultProxy(\n        uint256 _sharesAmount,\n        uint256 _mlnValue,\n        uint256 _gav\n    ) external returns (uint256 mlnAmountToBurn_);\n}\n"
    },
    "contracts/persistent/vault/VaultLibBase2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./VaultLibBase1.sol\";\n\n/// @title VaultLibBase2 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The first implementation of VaultLibBase1, with additional events and storage\n/// @dev All subsequent implementations should inherit the previous implementation,\n/// e.g., `VaultLibBase2 is VaultLibBase1`\n/// DO NOT EDIT CONTRACT.\nabstract contract VaultLibBase2 is VaultLibBase1 {\n    event AssetManagerAdded(address manager);\n\n    event AssetManagerRemoved(address manager);\n\n    event EthReceived(address indexed sender, uint256 amount);\n\n    event ExternalPositionAdded(address indexed externalPosition);\n\n    event ExternalPositionRemoved(address indexed externalPosition);\n\n    event FreelyTransferableSharesSet();\n\n    event NominatedOwnerRemoved(address indexed nominatedOwner);\n\n    event NominatedOwnerSet(address indexed nominatedOwner);\n\n    event ProtocolFeePaidInShares(uint256 sharesAmount);\n\n    event ProtocolFeeSharesBoughtBack(uint256 sharesAmount, uint256 mlnValue, uint256 mlnBurned);\n\n    event OwnershipTransferred(address indexed prevOwner, address indexed nextOwner);\n\n    // In order to make transferability guarantees to liquidity pools and other smart contracts\n    // that hold/treat shares as generic ERC20 tokens, a permanent guarantee on transferability\n    // is required. Once set as `true`, freelyTransferableShares should never be unset.\n    bool internal freelyTransferableShares;\n    address internal nominatedOwner;\n    address[] internal activeExternalPositions;\n    mapping(address => bool) internal accountToIsAssetManager;\n    mapping(address => bool) internal externalPositionToIsActive;\n}\n"
    },
    "contracts/release/infrastructure/protocol-fees/IProtocolFeeTracker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IProtocolFeeTracker Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IProtocolFeeTracker {\n    function initializeForVault(address) external;\n\n    function payFee() external returns (uint256);\n}\n"
    },
    "contracts/release/extensions/external-position-manager/IExternalPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExternalPositionManager interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for the ExternalPositionManager\ninterface IExternalPositionManager {\n    struct ExternalPositionTypeInfo {\n        address parser;\n        address lib;\n    }\n    enum ExternalPositionManagerActions {\n        CreateExternalPosition,\n        CallOnExternalPosition,\n        RemoveExternalPosition,\n        ReactivateExternalPosition\n    }\n\n    function getExternalPositionLibForType(uint256) external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title WETH Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IWETH {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/persistent/vault/VaultLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./VaultLibBaseCore.sol\";\n\n/// @title VaultLibBase1 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The first implementation of VaultLibBaseCore, with additional events and storage\n/// @dev All subsequent implementations should inherit the previous implementation,\n/// e.g., `VaultLibBase2 is VaultLibBase1`\n/// DO NOT EDIT CONTRACT.\nabstract contract VaultLibBase1 is VaultLibBaseCore {\n    event AssetWithdrawn(address indexed asset, address indexed target, uint256 amount);\n\n    event TrackedAssetAdded(address asset);\n\n    event TrackedAssetRemoved(address asset);\n\n    address[] internal trackedAssets;\n    mapping(address => bool) internal assetToIsTracked;\n}\n"
    },
    "contracts/persistent/vault/VaultLibBaseCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./interfaces/IMigratableVault.sol\";\nimport \"./utils/ProxiableVaultLib.sol\";\nimport \"./utils/SharesTokenBase.sol\";\n\n/// @title VaultLibBaseCore Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A persistent contract containing all required storage variables and\n/// required functions for a VaultLib implementation\n/// @dev DO NOT EDIT CONTRACT. If new events or storage are necessary, they should be added to\n/// a numbered VaultLibBaseXXX that inherits the previous base. See VaultLibBase1.\nabstract contract VaultLibBaseCore is IMigratableVault, ProxiableVaultLib, SharesTokenBase {\n    event AccessorSet(address prevAccessor, address nextAccessor);\n\n    event MigratorSet(address prevMigrator, address nextMigrator);\n\n    event OwnerSet(address prevOwner, address nextOwner);\n\n    event VaultLibSet(address prevVaultLib, address nextVaultLib);\n\n    address internal accessor;\n    address internal creator;\n    address internal migrator;\n    address internal owner;\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Initializes the VaultProxy with core configuration\n    /// @param _owner The address to set as the fund owner\n    /// @param _accessor The address to set as the permissioned accessor of the VaultLib\n    /// @param _fundName The name of the fund\n    /// @dev Serves as a per-proxy pseudo-constructor\n    function init(\n        address _owner,\n        address _accessor,\n        string calldata _fundName\n    ) external override {\n        require(creator == address(0), \"init: Proxy already initialized\");\n        creator = msg.sender;\n        sharesName = _fundName;\n\n        __setAccessor(_accessor);\n        __setOwner(_owner);\n\n        emit VaultLibSet(address(0), getVaultLib());\n    }\n\n    /// @notice Sets the permissioned accessor of the VaultLib\n    /// @param _nextAccessor The address to set as the permissioned accessor of the VaultLib\n    function setAccessor(address _nextAccessor) external override {\n        require(msg.sender == creator, \"setAccessor: Only callable by the contract creator\");\n\n        __setAccessor(_nextAccessor);\n    }\n\n    /// @notice Sets the VaultLib target for the VaultProxy\n    /// @param _nextVaultLib The address to set as the VaultLib\n    /// @dev This function is absolutely critical. __updateCodeAddress() validates that the\n    /// target is a valid Proxiable contract instance.\n    /// Does not block _nextVaultLib from being the same as the current VaultLib\n    function setVaultLib(address _nextVaultLib) external override {\n        require(msg.sender == creator, \"setVaultLib: Only callable by the contract creator\");\n\n        address prevVaultLib = getVaultLib();\n\n        __updateCodeAddress(_nextVaultLib);\n\n        emit VaultLibSet(prevVaultLib, _nextVaultLib);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether an account is allowed to migrate the VaultProxy\n    /// @param _who The account to check\n    /// @return canMigrate_ True if the account is allowed to migrate the VaultProxy\n    function canMigrate(address _who) public view virtual override returns (bool canMigrate_) {\n        return _who == owner || _who == migrator;\n    }\n\n    /// @notice Gets the VaultLib target for the VaultProxy\n    /// @return vaultLib_ The address of the VaultLib target\n    function getVaultLib() public view returns (address vaultLib_) {\n        assembly {\n            // solium-disable-line\n            vaultLib_ := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\n        }\n        return vaultLib_;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Helper to set the permissioned accessor of the VaultProxy.\n    /// Does not prevent the prevAccessor from being the _nextAccessor.\n    function __setAccessor(address _nextAccessor) internal {\n        require(_nextAccessor != address(0), \"__setAccessor: _nextAccessor cannot be empty\");\n        address prevAccessor = accessor;\n\n        accessor = _nextAccessor;\n\n        emit AccessorSet(prevAccessor, _nextAccessor);\n    }\n\n    /// @dev Helper to set the owner of the VaultProxy\n    function __setOwner(address _nextOwner) internal {\n        require(_nextOwner != address(0), \"__setOwner: _nextOwner cannot be empty\");\n        address prevOwner = owner;\n        require(_nextOwner != prevOwner, \"__setOwner: _nextOwner is the current owner\");\n\n        owner = _nextOwner;\n\n        emit OwnerSet(prevOwner, _nextOwner);\n    }\n}\n"
    },
    "contracts/persistent/vault/utils/ProxiableVaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ProxiableVaultLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that defines the upgrade behavior for VaultLib instances\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\n/// Code position in storage is `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`,\n/// which is \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\".\nabstract contract ProxiableVaultLib {\n    /// @dev Updates the target of the proxy to be the contract at _nextVaultLib\n    function __updateCodeAddress(address _nextVaultLib) internal {\n        require(\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\n                ProxiableVaultLib(_nextVaultLib).proxiableUUID(),\n            \"__updateCodeAddress: _nextVaultLib not compatible\"\n        );\n        assembly {\n            // solium-disable-line\n            sstore(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                _nextVaultLib\n            )\n        }\n    }\n\n    /// @notice Returns a unique bytes32 hash for VaultLib instances\n    /// @return uuid_ The bytes32 hash representing the UUID\n    /// @dev The UUID is `bytes32(keccak256('mln.proxiable.vaultlib'))`\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\n        return 0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5;\n    }\n}\n"
    },
    "contracts/persistent/vault/utils/SharesTokenBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./VaultLibSafeMath.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title StandardERC20 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Contains the storage, events, and default logic of an ERC20-compliant contract.\n/// @dev The logic can be overridden by VaultLib implementations.\n/// Adapted from OpenZeppelin 3.2.0.\n/// DO NOT EDIT THIS CONTRACT.\nabstract contract SharesTokenBase {\n    using VaultLibSafeMath for uint256;\n\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    /**\n     * @dev Emitted after aTokens are burned\n     * @param from The owner of the aTokens, getting them burned\n     * @param target The address that will receive the underlying\n     * @param value The amount being burned\n     **/\n    event Burn(address indexed from, address indexed target, uint256 value);\n\n    string internal sharesName;\n    string internal sharesSymbol;\n    uint256 internal sharesTotalSupply;\n    mapping(address => uint256) internal sharesBalances;\n    mapping(address => mapping(address => uint256)) internal sharesAllowances;\n\n    // EXTERNAL FUNCTIONS\n\n    /// @dev Standard implementation of ERC20's approve(). Can be overridden.\n    function approve(address _spender, uint256 _amount) public virtual returns (bool) {\n        __approve(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /// @dev Standard implementation of ERC20's transfer(). Can be overridden.\n    function transfer(address _recipient, uint256 _amount) public virtual returns (bool) {\n        __transfer(msg.sender, _recipient, _amount);\n        return true;\n    }\n\n    /// @dev Standard implementation of ERC20's transferFrom(). Can be overridden.\n    function transferFrom(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) public virtual returns (bool) {\n        __transfer(_sender, _recipient, _amount);\n        __approve(\n            _sender,\n            msg.sender,\n            sharesAllowances[_sender][msg.sender].sub(\n                _amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    // EXTERNAL FUNCTIONS - VIEW\n\n    /// @dev Standard implementation of ERC20's allowance(). Can be overridden.\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\n        return sharesAllowances[_owner][_spender];\n    }\n\n    /// @dev Standard implementation of ERC20's balanceOf(). Can be overridden.\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return sharesBalances[_account];\n    }\n\n    /// @dev Standard implementation of ERC20's decimals(). Can not be overridden.\n    function decimals() public pure returns (uint8) {\n        return 18;\n    }\n\n    /// @dev Standard implementation of ERC20's name(). Can be overridden.\n    function name() public view virtual returns (string memory) {\n        return sharesName;\n    }\n\n    /// @dev Standard implementation of ERC20's symbol(). Can be overridden.\n    function symbol() public view virtual returns (string memory) {\n        return sharesSymbol;\n    }\n\n    /// @dev Standard implementation of ERC20's totalSupply(). Can be overridden.\n    function totalSupply() public view virtual returns (uint256) {\n        return sharesTotalSupply;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Helper for approve(). Can be overridden.\n    function __approve(\n        address _owner,\n        address _spender,\n        uint256 _amount\n    ) internal virtual {\n        require(_owner != address(0), \"ERC20: approve from the zero address\");\n        require(_spender != address(0), \"ERC20: approve to the zero address\");\n\n        sharesAllowances[_owner][_spender] = _amount;\n        emit Approval(_owner, _spender, _amount);\n    }\n\n    /// @dev Helper to burn tokens from an account. Can be overridden.\n    function __burn(address _account, uint256 _amount) internal virtual {\n        console.log(\"SharesTokeBase:Burning account:%s\", _account);\n        console.log(\"SharesTokeBase:Burning amount:%s\", _amount);\n        console.log(\"SharesTokeBase:Burning current:%s\", sharesBalances[_account]);\n\n        require(_account != address(0), \"ERC20: burn from the zero address\");\n\n        sharesBalances[_account] = sharesBalances[_account].sub(\n            _amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        sharesTotalSupply = sharesTotalSupply.sub(_amount);\n        emit Transfer(_account, address(0), _amount);\n    }\n\n    /// @dev Helper to mint tokens to an account. Can be overridden.\n    function __mint(address _account, uint256 _amount) internal virtual {\n        require(_account != address(0), \"ERC20: mint to the zero address\");\n\n        sharesTotalSupply = sharesTotalSupply.add(_amount);\n        sharesBalances[_account] = sharesBalances[_account].add(_amount);\n        emit Transfer(address(0), _account, _amount);\n    }\n\n    /// @dev Helper to transfer tokens between accounts. Can be overridden.\n    function __transfer(\n        address _sender,\n        address _recipient,\n        uint256 _amount\n    ) internal virtual {\n        require(_sender != address(0), \"ERC20: transfer from the zero address\");\n        require(_recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        sharesBalances[_sender] = sharesBalances[_sender].sub(\n            _amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        sharesBalances[_recipient] = sharesBalances[_recipient].add(_amount);\n        emit Transfer(_sender, _recipient, _amount);\n    }\n}\n"
    },
    "contracts/persistent/vault/utils/VaultLibSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title VaultLibSafeMath library\n/// @notice A narrowed, verbatim implementation of OpenZeppelin 3.2.0 SafeMath\n/// for use with VaultLib\n/// @dev Preferred to importing from npm to guarantee consistent logic and revert reasons\n/// between VaultLib implementations\n/// DO NOT EDIT THIS CONTRACT\nlibrary VaultLibSafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"VaultLibSafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"VaultLibSafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"VaultLibSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"VaultLibSafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n\n        return c;\n    }\n\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"VaultLibSafeMath: modulo by zero\");\n    }\n\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/release/extensions/utils/ExtensionBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../IExtension.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title ExtensionBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Base class for an extension\nabstract contract ExtensionBase is IExtension, FundDeployerOwnerMixin {\n    event ValidatedVaultProxySetForFund(\n        address indexed comptrollerProxy,\n        address indexed vaultProxy\n    );\n\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\n\n    modifier onlyFundDeployer() {\n        console.log(\"ExtensionBase:onlyFundDeployer:msg.sender: %s\", msg.sender);\n        require(msg.sender == getFundDeployer(), \"Only the FundDeployer can make this call\");\n        _;\n    }\n\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\n\n    /// @notice Allows extension to run logic during fund activation\n    /// @dev Unimplemented by default, may be overridden.\n    function activateForFund(bool) external virtual override {\n        return;\n    }\n\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\n    /// @dev Unimplemented by default, may be overridden.\n    function deactivateForFund() external virtual override {\n        return;\n    }\n\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\n    /// and dispatches the appropriate action\n    /// @dev Unimplemented by default, may be overridden.\n    function receiveCallFromComptroller(\n        address,\n        uint256,\n        bytes calldata\n    ) external virtual override {\n        revert(\"receiveCallFromComptroller: Unimplemented for Extension\");\n    }\n\n    /// @notice Allows extension to run logic during fund configuration\n    /// @dev Unimplemented by default, may be overridden.\n    function setConfigForFund(\n        address,\n        address,\n        bytes calldata\n    ) external virtual override {\n        return;\n    }\n\n    /// @dev Helper to store the validated ComptrollerProxy-VaultProxy relation\n    function __setValidatedVaultProxy(address _comptrollerProxy, address _vaultProxy) internal {\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = _vaultProxy;\n\n        emit ValidatedVaultProxySetForFund(_comptrollerProxy, _vaultProxy);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return vaultProxy_ The VaultProxy of the fund\n    function getVaultProxyForFund(address _comptrollerProxy)\n        public\n        view\n        returns (address vaultProxy_)\n    {\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/release/extensions/utils/PermissionedVaultActionMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../core/fund/comptroller/IComptroller.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title PermissionedVaultActionMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin contract for extensions that can make permissioned vault calls\nabstract contract PermissionedVaultActionMixin {\n    /// @notice Adds an external position to active external positions\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _externalPosition The external position to be added\n    function __addExternalPosition(address _comptrollerProxy, address _externalPosition) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.AddExternalPosition,\n            abi.encode(_externalPosition)\n        );\n    }\n\n    /// @notice Adds a tracked asset\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to add\n    function __addTrackedAsset(address _comptrollerProxy, address _asset) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.AddTrackedAsset,\n            abi.encode(_asset)\n        );\n    }\n\n    /// @notice Grants an allowance to a spender to use a fund's asset\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset for which to grant an allowance\n    /// @param _target The spender of the allowance\n    /// @param _amount The amount of the allowance\n    function __approveAssetSpender(\n        address _comptrollerProxy,\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.ApproveAssetSpender,\n            abi.encode(_asset, _target, _amount)\n        );\n    }\n\n    /// @notice Burns fund shares for a particular account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _target The account for which to burn shares\n    /// @param _amount The amount of shares to burn\n    function __burnShares(\n        address _comptrollerProxy,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.BurnShares,\n            abi.encode(_target, _amount)\n        );\n    }\n\n    /// @notice Executes a callOnExternalPosition\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _data The encoded data for the call\n    function __callOnExternalPosition(address _comptrollerProxy, bytes memory _data) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.CallOnExternalPosition,\n            _data\n        );\n    }\n\n    /// @notice Mints fund shares to a particular account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _target The account to which to mint shares\n    /// @param _amount The amount of shares to mint\n    function __mintShares(\n        address _comptrollerProxy,\n        address _target,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.MintShares,\n            abi.encode(_target, _amount)\n        );\n    }\n\n    /// @notice Removes an external position from the vaultProxy\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _externalPosition The ExternalPosition to remove\n    function __removeExternalPosition(address _comptrollerProxy, address _externalPosition)\n        internal\n    {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.RemoveExternalPosition,\n            abi.encode(_externalPosition)\n        );\n    }\n\n    /// @notice Removes a tracked asset\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to remove\n    function __removeTrackedAsset(address _comptrollerProxy, address _asset) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.RemoveTrackedAsset,\n            abi.encode(_asset)\n        );\n    }\n\n    /// @notice Transfers fund shares from one account to another\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _from The account from which to transfer shares\n    /// @param _to The account to which to transfer shares\n    /// @param _amount The amount of shares to transfer\n    function __transferShares(\n        address _comptrollerProxy,\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal {\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.TransferShares,\n            abi.encode(_from, _to, _amount)\n        );\n    }\n\n    /// @notice Withdraws an asset from the VaultProxy to a given account\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset to withdraw\n    /// @param _target The account to which to withdraw the asset\n    /// @param _amount The amount of asset to withdraw\n    function __withdrawAssetTo(\n        address _comptrollerProxy,\n        address _asset,\n        address _target,\n        uint256 _amount\n    ) internal {\n        console.log(\"__preProcessCoI:__withdrawAssetTo for _asset  %s\", _asset);\n        console.log(\"__preProcessCoI:__withdrawAssetTo for _target  %s\", _target);\n        console.log(\"__preProcessCoI:__withdrawAssetTo for _amount  %d\", _amount);\n        console.log(\n            \"__preProcessCoI:IVault.VaultAction.WithdrawAssetTo   %d\",\n            uint256(IVault.VaultAction.WithdrawAssetTo)\n        );\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\n            IVault.VaultAction.WithdrawAssetTo,\n            abi.encode(_asset, _target, _amount)\n        );\n        console.log(\"__preProcessCoI: after permissionedVaultAction   %d\", _amount);\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/IFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IFeeManager.sol\";\n\n/// @title Fee Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all fees\ninterface IFee {\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\n\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData) external;\n\n    function payout(address _comptrollerProxy, address _vaultProxy)\n        external\n        returns (bool isPayable_);\n\n    function getRecipientForFund(address _comptrollerProxy)\n        external\n        view\n        returns (address recipient_);\n\n    function settle(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    )\n        external\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address payer_,\n            uint256 sharesDue_\n        );\n\n    function settlesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        returns (bool settles_, bool usesGav_);\n\n    function update(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    ) external;\n\n    function updatesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        returns (bool updates_, bool usesGav_);\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/PricelessAssetBypassMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../../../../core/fund/vault/VaultLib.sol\";\nimport \"../../../../infrastructure/value-interpreter/ValueInterpreter.sol\";\n\n/// @title PricelessAssetBypassMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin that facilitates timelocked actions for an asset that does not have a valid price\nabstract contract PricelessAssetBypassMixin {\n    using SafeMath for uint256;\n\n    event PricelessAssetBypassed(address indexed comptrollerProxy, address indexed asset);\n\n    event PricelessAssetTimelockStarted(address indexed comptrollerProxy, address indexed asset);\n\n    uint256 private immutable PRICELESS_ASSET_BYPASS_TIMELOCK;\n    uint256 private immutable PRICELESS_ASSET_BYPASS_TIME_LIMIT;\n    address private immutable PRICELESS_ASSET_BYPASS_VALUE_INTERPRETER;\n    address private immutable PRICELESS_ASSET_BYPASS_WETH_TOKEN;\n\n    mapping(address => mapping(address => uint256))\n        private comptrollerProxyToAssetToBypassWindowStart;\n\n    constructor(\n        address _valueInterpreter,\n        address _wethToken,\n        uint256 _timelock,\n        uint256 _timeLimit\n    ) public {\n        PRICELESS_ASSET_BYPASS_TIMELOCK = _timelock;\n        PRICELESS_ASSET_BYPASS_TIME_LIMIT = _timeLimit;\n        PRICELESS_ASSET_BYPASS_VALUE_INTERPRETER = _valueInterpreter;\n        PRICELESS_ASSET_BYPASS_WETH_TOKEN = _wethToken;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Starts the timelock period for an asset without a valid price\n    /// @param _asset The asset for which to start the timelock period\n    /// @dev This function must be called via ComptrollerProxy.vaultCallOnContract().\n    /// This allows the function to be gas relay-able.\n    /// It also means that the originator must be the owner.\n    function startAssetBypassTimelock(address _asset) external {\n        // No need to validate whether the VaultProxy is an Enzyme contract\n        address comptrollerProxy = VaultLib(msg.sender).getAccessor();\n        require(\n            msg.sender == ComptrollerLib(comptrollerProxy).getVaultProxy(),\n            \"startAssetBypassTimelock: Sender is not the VaultProxy of the associated ComptrollerProxy\"\n        );\n\n        try\n            ValueInterpreter(getPricelessAssetBypassValueInterpreter()).calcCanonicalAssetValue(\n                _asset,\n                1, // Any value >0 will attempt to retrieve a rate\n                getPricelessAssetBypassWethToken() // Any valid asset would do\n            )\n         {\n            revert(\"startAssetBypassTimelock: Asset has a price\");\n        } catch {\n            comptrollerProxyToAssetToBypassWindowStart[comptrollerProxy][_asset] = block\n                .timestamp\n                .add(getPricelessAssetBypassTimelock());\n\n            emit PricelessAssetTimelockStarted(comptrollerProxy, _asset);\n        }\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether an asset is bypassable (if still without a valid price) for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset for which to check if it is bypassable\n    /// @return isBypassable_ True if the asset is bypassable\n    function assetIsBypassableForFund(address _comptrollerProxy, address _asset)\n        public\n        view\n        returns (bool isBypassable_)\n    {\n        uint256 windowStart = getAssetBypassWindowStartForFund(_comptrollerProxy, _asset);\n\n        return\n            windowStart <= block.timestamp &&\n            windowStart.add(getPricelessAssetBypassTimeLimit()) >= block.timestamp;\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Helper to execute __calcValueExcludingBypassablePricelessAsset() for an array of base asset amounts\n    function __calcTotalValueExlcudingBypassablePricelessAssets(\n        address _comptrollerProxy,\n        address[] memory _baseAssets,\n        uint256[] memory _baseAssetAmounts,\n        address _quoteAsset\n    ) internal returns (uint256 value_) {\n        for (uint256 i; i < _baseAssets.length; i++) {\n            value_ = value_.add(\n                __calcValueExcludingBypassablePricelessAsset(\n                    _comptrollerProxy,\n                    _baseAssets[i],\n                    _baseAssetAmounts[i],\n                    _quoteAsset\n                )\n            );\n        }\n    }\n\n    /// @dev Helper to calculate the value of a base asset amount in terms of a quote asset,\n    /// returning a value of `0` for an asset without a valid price that is within its bypass window\n    function __calcValueExcludingBypassablePricelessAsset(\n        address _comptrollerProxy,\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        address _quoteAsset\n    ) internal returns (uint256 value_) {\n        try\n            ValueInterpreter(getPricelessAssetBypassValueInterpreter()).calcCanonicalAssetValue(\n                _baseAsset,\n                _baseAssetAmount,\n                _quoteAsset\n            )\n        returns (uint256 result) {\n            return result;\n        } catch {\n            require(\n                assetIsBypassableForFund(_comptrollerProxy, _baseAsset),\n                \"__calcValueExcludingBypassablePricelessAsset: Invalid asset not bypassable\"\n            );\n\n            emit PricelessAssetBypassed(_comptrollerProxy, _baseAsset);\n        }\n\n        return 0;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the timestamp from which an asset without a valid price can be considered to be valued at `0`\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _asset The asset\n    /// @return windowStart_ The timestamp\n    function getAssetBypassWindowStartForFund(address _comptrollerProxy, address _asset)\n        public\n        view\n        returns (uint256 windowStart_)\n    {\n        return comptrollerProxyToAssetToBypassWindowStart[_comptrollerProxy][_asset];\n    }\n\n    /// @notice Gets the `PRICELESS_ASSET_BYPASS_TIME_LIMIT` variable\n    /// @return timeLimit_ The `PRICELESS_ASSET_BYPASS_TIME_LIMIT` variable value\n    function getPricelessAssetBypassTimeLimit() public view returns (uint256 timeLimit_) {\n        return PRICELESS_ASSET_BYPASS_TIME_LIMIT;\n    }\n\n    /// @notice Gets the `PRICELESS_ASSET_BYPASS_TIMELOCK` variable\n    /// @return timelock_ The `PRICELESS_ASSET_BYPASS_TIMELOCK` variable value\n    function getPricelessAssetBypassTimelock() public view returns (uint256 timelock_) {\n        return PRICELESS_ASSET_BYPASS_TIMELOCK;\n    }\n\n    /// @notice Gets the `PRICELESS_ASSET_BYPASS_VALUE_INTERPRETER` variable\n    /// @return valueInterpreter_ The `PRICELESS_ASSET_BYPASS_VALUE_INTERPRETER` variable value\n    function getPricelessAssetBypassValueInterpreter()\n        public\n        view\n        returns (address valueInterpreter_)\n    {\n        return PRICELESS_ASSET_BYPASS_VALUE_INTERPRETER;\n    }\n\n    /// @notice Gets the `PRICELESS_ASSET_BYPASS_WETH_TOKEN` variable\n    /// @return wethToken_ The `PRICELESS_ASSET_BYPASS_WETH_TOKEN` variable value\n    function getPricelessAssetBypassWethToken() public view returns (address wethToken_) {\n        return PRICELESS_ASSET_BYPASS_WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/test/TestPricelessAssetBypassMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/extensions/policy-manager/policies/utils/PricelessAssetBypassMixin.sol\";\n\n/// @title TestPricelessAssetBypassMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of PricelessAssetBypassMixin\ncontract TestPricelessAssetBypassMixin is PricelessAssetBypassMixin {\n    constructor(\n        address _valueInterpreter,\n        address _wethToken,\n        uint256 _timelock,\n        uint256 _timeLimit\n    ) public PricelessAssetBypassMixin(_valueInterpreter, _wethToken, _timelock, _timeLimit) {}\n\n    function calcTotalValueExlcudingBypassablePricelessAssets(\n        address _comptrollerProxy,\n        address[] memory _baseAssets,\n        uint256[] memory _baseAssetAmounts,\n        address _quoteAsset\n    ) external returns (uint256 value_) {\n        return\n            __calcTotalValueExlcudingBypassablePricelessAssets(\n                _comptrollerProxy,\n                _baseAssets,\n                _baseAssetAmounts,\n                _quoteAsset\n            );\n    }\n\n    function calcValueExcludingBypassablePricelessAsset(\n        address _comptrollerProxy,\n        address _baseAsset,\n        uint256 _baseAssetAmount,\n        address _quoteAsset\n    ) external returns (uint256 value_) {\n        return\n            __calcValueExcludingBypassablePricelessAsset(\n                _comptrollerProxy,\n                _baseAsset,\n                _baseAssetAmount,\n                _quoteAsset\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/OnlyUntrackDustOrPricelessAssetsPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../utils/DustEvaluatorMixin.sol\";\nimport \"../utils/PolicyBase.sol\";\nimport \"../utils/PricelessAssetBypassMixin.sol\";\n\n/// @title OnlyUntrackDustOrPricelessAssetsPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that only allows untracking assets whose value can be considered negligible,\n/// or assets that do not have a valid price and for which the manager has signaled prior intent to remove\ncontract OnlyUntrackDustOrPricelessAssetsPolicy is\n    PolicyBase,\n    DustEvaluatorMixin,\n    PricelessAssetBypassMixin\n{\n    constructor(\n        address _policyManager,\n        address _fundDeployer,\n        address _valueInterpreter,\n        address _wethToken,\n        uint256 _pricelessAssetBypassTimelock,\n        uint256 _pricelessAssetBypassTimeLimit\n    )\n        public\n        PolicyBase(_policyManager)\n        DustEvaluatorMixin(_fundDeployer)\n        PricelessAssetBypassMixin(\n            _valueInterpreter,\n            _wethToken,\n            _pricelessAssetBypassTimelock,\n            _pricelessAssetBypassTimeLimit\n        )\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial policy settings for a fund\n    function addFundSettings(address, bytes calldata) external override {\n        // Not implemented\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ONLY_UNTRACK_DUST_OR_PRICELESS_ASSETS\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.RemoveTrackedAssets;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary as no state is updated,\n    /// but is cheap and nice-to-have since an event is fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override onlyPolicyManager returns (bool isValid_) {\n        (, address[] memory assets) = __decodeRemoveTrackedAssetsValidationData(_encodedArgs);\n\n        address vaultProxy = ComptrollerLib(_comptrollerProxy).getVaultProxy();\n        for (uint256 i; i < assets.length; i++) {\n            uint256 amount = ERC20(assets[i]).balanceOf(vaultProxy);\n            uint256 valueInWeth = __calcValueExcludingBypassablePricelessAsset(\n                _comptrollerProxy,\n                assets[i],\n                amount,\n                getPricelessAssetBypassWethToken()\n            );\n\n            if (!__isDust(valueInWeth)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/DustEvaluatorMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\n\n/// @title DustEvaluatorMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mixin used to evaluate where an amount of a given asset can be considered \"dust,\"\n/// i.e., of negligible value\nabstract contract DustEvaluatorMixin is FundDeployerOwnerMixin {\n    event DustToleranceInWethSet(uint256 nextDustToleranceInWeth);\n\n    uint256 private dustToleranceInWeth;\n\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\n\n    /// @notice Sets the dustToleranceInWeth variable value\n    /// @param _nextDustToleranceInWeth The next dustToleranceInWeth value\n    function setDustToleranceInWeth(uint256 _nextDustToleranceInWeth)\n        external\n        onlyFundDeployerOwner\n    {\n        dustToleranceInWeth = _nextDustToleranceInWeth;\n\n        emit DustToleranceInWethSet(_nextDustToleranceInWeth);\n    }\n\n    /// @dev Helper to evaluate whether an amount of WETH is dust\n    function __isDust(uint256 _wethAmount) internal view returns (bool isDust_) {\n        return _wethAmount <= getDustToleranceInWeth();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `dustToleranceInWeth` variable\n    /// @return dustToleranceInWeth_ The `dustToleranceInWeth` variable value\n    function getDustToleranceInWeth() public view returns (uint256 dustToleranceInWeth_) {\n        return dustToleranceInWeth;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/PolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../IPolicy.sol\";\n\n/// @title PolicyBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Abstract base contract for all policies\nabstract contract PolicyBase is IPolicy {\n    address internal immutable POLICY_MANAGER;\n\n    modifier onlyPolicyManager {\n        require(msg.sender == POLICY_MANAGER, \"Only the PolicyManager can make this call\");\n        _;\n    }\n\n    constructor(address _policyManager) public {\n        POLICY_MANAGER = _policyManager;\n    }\n\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\n    /// @dev Unimplemented by default, can be overridden by the policy\n    function activateForFund(address) external virtual override {\n        return;\n    }\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    /// @dev False by default, can be overridden by the policy\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return false;\n    }\n\n    /// @notice Updates the policy settings for a fund\n    /// @dev Disallowed by default, can be overridden by the policy\n    function updateFundSettings(address, bytes calldata) external virtual override {\n        revert(\"updateFundSettings: Updates not allowed for this policy\");\n    }\n\n    //////////////////////////////\n    // VALIDATION DATA DECODING //\n    //////////////////////////////\n\n    /// @dev Helper to parse validation arguments from encoded data for AddTrackedAssets policy hook\n    function __decodeAddTrackedAssetsValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (address caller_, address[] memory assets_)\n    {\n        return abi.decode(_validationData, (address, address[]));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for CreateExternalPosition policy hook\n    function __decodeCreateExternalPositionValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address caller_,\n            uint256 typeId_,\n            bytes memory initializationData_\n        )\n    {\n        return abi.decode(_validationData, (address, uint256, bytes));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for PreTransferShares policy hook\n    function __decodePreTransferSharesValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address sender_,\n            address recipient_,\n            uint256 amount_\n        )\n    {\n        return abi.decode(_validationData, (address, address, uint256));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for PostBuyShares policy hook\n    function __decodePostBuySharesValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address buyer_,\n            uint256 investmentAmount_,\n            uint256 sharesIssued_,\n            uint256 gav_\n        )\n    {\n        return abi.decode(_validationData, (address, uint256, uint256, uint256));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for PostCallOnExternalPosition policy hook\n    function __decodePostCallOnExternalPositionValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address caller_,\n            address externalPosition_,\n            address[] memory assetsToTransfer_,\n            uint256[] memory amountsToTransfer_,\n            address[] memory assetsToReceive_,\n            bytes memory encodedActionData_\n        )\n    {\n        return\n            abi.decode(\n                _validationData,\n                (address, address, address[], uint256[], address[], bytes)\n            );\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for PostCallOnIntegration policy hook\n    function __decodePostCallOnIntegrationValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address caller_,\n            address adapter_,\n            bytes4 selector_,\n            address[] memory incomingAssets_,\n            uint256[] memory incomingAssetAmounts_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_\n        )\n    {\n        return\n            abi.decode(\n                _validationData,\n                (address, address, bytes4, address[], uint256[], address[], uint256[])\n            );\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for ReactivateExternalPosition policy hook\n    function __decodeReactivateExternalPositionValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (address caller_, address externalPosition_)\n    {\n        return abi.decode(_validationData, (address, address));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for RedeemSharesForSpecificAssets policy hook\n    function __decodeRedeemSharesForSpecificAssetsValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (\n            address redeemer_,\n            address recipient_,\n            uint256 sharesToRedeemPostFees_,\n            address[] memory assets_,\n            uint256[] memory assetAmounts_,\n            uint256 gavPreRedeem_\n        )\n    {\n        return\n            abi.decode(\n                _validationData,\n                (address, address, uint256, address[], uint256[], uint256)\n            );\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for RemoveExternalPosition policy hook\n    function __decodeRemoveExternalPositionValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (address caller_, address externalPosition_)\n    {\n        return abi.decode(_validationData, (address, address));\n    }\n\n    /// @dev Helper to parse validation arguments from encoded data for RemoveTrackedAssets policy hook\n    function __decodeRemoveTrackedAssetsValidationData(bytes memory _validationData)\n        internal\n        pure\n        returns (address caller_, address[] memory assets_)\n    {\n        return abi.decode(_validationData, (address, address[]));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `POLICY_MANAGER` variable value\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\n    function getPolicyManager() external view returns (address policyManager_) {\n        return POLICY_MANAGER;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/IPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IPolicyManager.sol\";\n\n/// @title Policy Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IPolicy {\n    function activateForFund(address _comptrollerProxy) external;\n\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings) external;\n\n    function canDisable() external pure returns (bool canDisable_);\n\n    function identifier() external pure returns (string memory identifier_);\n\n    function implementedHooks()\n        external\n        pure\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_);\n\n    function updateFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external;\n\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook _hook,\n        bytes calldata _encodedArgs\n    ) external returns (bool isValid_);\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/new-shareholders/MinMaxInvestmentPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/PolicyBase.sol\";\n\n/// @title MinMaxInvestmentPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that restricts the amount of the fund's denomination asset that a user can\n/// send in a single call to buy shares in a fund\ncontract MinMaxInvestmentPolicy is PolicyBase {\n    event FundSettingsSet(\n        address indexed comptrollerProxy,\n        uint256 minInvestmentAmount,\n        uint256 maxInvestmentAmount\n    );\n\n    struct FundSettings {\n        uint256 minInvestmentAmount;\n        uint256 maxInvestmentAmount;\n    }\n\n    mapping(address => FundSettings) private comptrollerProxyToFundSettings;\n\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\n\n    /// @notice Adds the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        __setFundSettings(_comptrollerProxy, _encodedSettings);\n    }\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return true;\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifer string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"MIN_MAX_INVESTMENT\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostBuyShares;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Updates the policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function updateFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        __setFundSettings(_comptrollerProxy, _encodedSettings);\n    }\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _investmentAmount The investment amount for which to check the rule\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, uint256 _investmentAmount)\n        public\n        view\n        returns (bool isValid_)\n    {\n        uint256 minInvestmentAmount = comptrollerProxyToFundSettings[_comptrollerProxy]\n            .minInvestmentAmount;\n        uint256 maxInvestmentAmount = comptrollerProxyToFundSettings[_comptrollerProxy]\n            .maxInvestmentAmount;\n\n        // Both minInvestmentAmount and maxInvestmentAmount can be 0 in order to close the fund\n        // temporarily\n        if (minInvestmentAmount == 0) {\n            return _investmentAmount <= maxInvestmentAmount;\n        } else if (maxInvestmentAmount == 0) {\n            return _investmentAmount >= minInvestmentAmount;\n        }\n        return\n            _investmentAmount >= minInvestmentAmount && _investmentAmount <= maxInvestmentAmount;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, uint256 investmentAmount, , ) = __decodePostBuySharesValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, investmentAmount);\n    }\n\n    /// @dev Helper to set the policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function __setFundSettings(address _comptrollerProxy, bytes memory _encodedSettings) private {\n        (uint256 minInvestmentAmount, uint256 maxInvestmentAmount) = abi.decode(\n            _encodedSettings,\n            (uint256, uint256)\n        );\n\n        require(\n            maxInvestmentAmount == 0 || minInvestmentAmount < maxInvestmentAmount,\n            \"__setFundSettings: minInvestmentAmount must be less than maxInvestmentAmount\"\n        );\n\n        comptrollerProxyToFundSettings[_comptrollerProxy]\n            .minInvestmentAmount = minInvestmentAmount;\n        comptrollerProxyToFundSettings[_comptrollerProxy]\n            .maxInvestmentAmount = maxInvestmentAmount;\n\n        emit FundSettingsSet(_comptrollerProxy, minInvestmentAmount, maxInvestmentAmount);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the min and max investment amount for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return fundSettings_ The fund settings\n    function getFundSettings(address _comptrollerProxy)\n        external\n        view\n        returns (FundSettings memory fundSettings_)\n    {\n        return comptrollerProxyToFundSettings[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/current-shareholders/MinAssetBalancesPostRedemptionPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../utils/PolicyBase.sol\";\n\n/// @title MinAssetBalancesPostRedemptionPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that sets min remaining balance limits on assets specified during specific assets redemption\ncontract MinAssetBalancesPostRedemptionPolicy is PolicyBase {\n    event MinAssetBalanceAddedForFund(\n        address indexed comptrollerProxy,\n        address indexed asset,\n        uint256 minBalance\n    );\n\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\n\n    mapping(address => mapping(address => uint256)) private comptrollerProxyToAssetToMinBalance;\n\n    /// @notice Adds the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    /// @dev Most funds that use this policy will likely not allow any external positions.\n    /// Does not prohibit specifying not-yet-defined external position type ids.\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        (address[] memory assets, uint256[] memory minBalances) = abi.decode(\n            _encodedSettings,\n            (address[], uint256[])\n        );\n        require(assets.length == minBalances.length, \"addFundSettings: Unequal array lengths\");\n\n        for (uint256 i; i < assets.length; i++) {\n            comptrollerProxyToAssetToMinBalance[_comptrollerProxy][assets[i]] = minBalances[i];\n\n            emit MinAssetBalanceAddedForFund(_comptrollerProxy, assets[i], minBalances[i]);\n        }\n    }\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return true;\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"MIN_ASSET_BALANCES_POST_REDEMPTION\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.RedeemSharesForSpecificAssets;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, , , address[] memory assets, , ) = __decodeRedeemSharesForSpecificAssetsValidationData(\n            _encodedArgs\n        );\n\n        address vaultProxy = ComptrollerLib(_comptrollerProxy).getVaultProxy();\n        for (uint256 i; i < assets.length; i++) {\n            if (\n                ERC20(assets[i]).balanceOf(vaultProxy) <\n                getMinAssetBalanceForFund(_comptrollerProxy, assets[i])\n            ) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the minimum asset balance that must remain in a fund after specific asset redemption\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _asset The asset\n    /// @return minBalance_ The minimum balance\n    function getMinAssetBalanceForFund(address _comptrollerProxy, address _asset)\n        public\n        view\n        returns (uint256 minBalance_)\n    {\n        return comptrollerProxyToAssetToMinBalance[_comptrollerProxy][_asset];\n    }\n}\n"
    },
    "contracts/release/peripheral/UnpermissionedActionsWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../extensions/fee-manager/FeeManager.sol\";\n\n/// @title UnpermissionedActionsWrapper Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Logic related to wrapping actions that do not need access control\ncontract UnpermissionedActionsWrapper {\n    address private immutable FEE_MANAGER;\n\n    constructor(address _feeManager) public {\n        FEE_MANAGER = _feeManager;\n    }\n\n    /// @notice Gets all fees that implement the `Continuous` fee hook for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return continuousFees_ The fees that implement the `Continuous` fee hook\n    function getContinuousFeesForFund(address _comptrollerProxy)\n        external\n        view\n        returns (address[] memory continuousFees_)\n    {\n        FeeManager feeManagerContract = FeeManager(getFeeManager());\n\n        address[] memory fees = feeManagerContract.getEnabledFeesForFund(_comptrollerProxy);\n\n        // Count the continuous fees\n        uint256 continuousFeesCount;\n        bool[] memory implementsContinuousHook = new bool[](fees.length);\n        for (uint256 i; i < fees.length; i++) {\n            (bool settles, ) = IFee(fees[i]).settlesOnHook(IFeeManager.FeeHook.Continuous);\n            if (settles) {\n                continuousFeesCount++;\n                implementsContinuousHook[i] = true;\n            }\n        }\n\n        // Return early if no continuous fees\n        if (continuousFeesCount == 0) {\n            return new address[](0);\n        }\n\n        // Create continuous fees array\n        continuousFees_ = new address[](continuousFeesCount);\n        uint256 continuousFeesIndex;\n        for (uint256 i; i < fees.length; i++) {\n            if (implementsContinuousHook[i]) {\n                continuousFees_[continuousFeesIndex] = fees[i];\n                continuousFeesIndex++;\n            }\n        }\n\n        return continuousFees_;\n    }\n\n    /// @notice Invokes the Continuous fee hook on all specified fees, and then attempts to payout\n    /// any shares outstanding on those fees\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _fees The fees for which to run these actions\n    /// @dev This is just a wrapper to execute two callOnExtension() actions atomically, in sequence.\n    /// The caller must pass in the fees that they want to run this logic on.\n    function invokeContinuousFeeHookAndPayoutSharesOutstandingForFund(\n        address _comptrollerProxy,\n        address[] calldata _fees\n    ) external {\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\n\n        comptrollerProxyContract.callOnExtension(getFeeManager(), 0, \"\");\n        comptrollerProxyContract.callOnExtension(getFeeManager(), 1, abi.encode(_fees));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FEE_MANAGER` variable\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    function getFeeManager() public view returns (address feeManager_) {\n        return FEE_MANAGER;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/math/SignedSafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../FeeManager.sol\";\nimport \"./utils/FeeBase.sol\";\nimport \"./utils/UpdatableFeeRecipientBase.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title PerformanceFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A performance-based fee with configurable rate and crystallization period, using\n/// a high watermark\n/// @dev This contract assumes that all shares in the VaultProxy are shares outstanding,\n/// which is fine for this release. Even if they are not, they are still shares that\n/// are only claimable by the fund owner.\ncontract PerformanceFee is FeeBase, UpdatableFeeRecipientBase {\n    using SafeMath for uint256;\n    using SignedSafeMath for int256;\n\n    event ActivatedForFund(address indexed comptrollerProxy, uint256 highWaterMark);\n\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate, uint256 period);\n\n    event LastSharePriceUpdated(\n        address indexed comptrollerProxy,\n        uint256 prevSharePrice,\n        uint256 nextSharePrice\n    );\n\n    event PaidOut(\n        address indexed comptrollerProxy,\n        uint256 prevHighWaterMark,\n        uint256 nextHighWaterMark,\n        uint256 aggregateValueDue\n    );\n\n    event PerformanceUpdated(\n        address indexed comptrollerProxy,\n        uint256 prevAggregateValueDue,\n        uint256 nextAggregateValueDue,\n        int256 sharesOutstandingDiff\n    );\n\n    struct FeeInfo {\n        uint16 rate;\n        uint64 period;\n        uint64 activated;\n        uint64 lastPaid;\n        uint256 highWaterMark;\n        uint256 lastSharePrice;\n        uint256 aggregateValueDue;\n    }\n\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\n    uint256 private constant SHARE_UNIT = 10**18;\n\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\n\n    constructor(address _feeManager) public FeeBase(_feeManager) {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Activates the fee for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    function activateForFund(address _comptrollerProxy, address) external override onlyFeeManager {\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\n\n        // We must not force asset finality, otherwise funds that have Synths as tracked assets\n        // would be susceptible to a DoS attack when attempting to migrate to a release that uses\n        // this fee: an attacker trades a negligible amount of a tracked Synth with the VaultProxy\n        // as the recipient, thus causing `calcGrossShareValue(true)` to fail.\n        uint256 grossSharePrice = ComptrollerLib(_comptrollerProxy).calcGrossShareValue(false);\n\n        feeInfo.highWaterMark = grossSharePrice;\n        feeInfo.lastSharePrice = grossSharePrice;\n        feeInfo.activated = uint64(block.timestamp);\n\n        emit ActivatedForFund(_comptrollerProxy, grossSharePrice);\n    }\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    /// @dev `highWaterMark`, `lastSharePrice`, and `activated` are set during activation\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        external\n        override\n        onlyFeeManager\n    {\n        console.log(\"PerformaceFee:addFundSettings:begin\");\n        console.logBytes(_settingsData);\n        (uint16 feeRate, uint64 feePeriod, address recipient) = abi.decode(\n            _settingsData,\n            (uint16, uint64, address)\n        );\n        console.log(\"PerformaceFee:addFundSettings:feeRate:%d\", feeRate);\n        console.log(\"PerformaceFee:addFundSettings:feePeriod:%d\", feePeriod);\n        console.log(\"PerformaceFee:addFundSettings:recipient:%s\", recipient);\n\n        require(feeRate > 0, \"addFundSettings: feeRate must be greater than 0\");\n        // Unlike most other fees, there could be a case for using a rate of exactly 100%,\n        // i.e., pay out all profits to a specified recipient\n        require(feeRate <= ONE_HUNDRED_PERCENT, \"addFundSettings: feeRate max exceeded\");\n        require(feePeriod > 0, \"addFundSettings: feePeriod must be greater than 0\");\n        console.log(\"PerformaceFee:addFundSettings afre requires\");\n\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\n            rate: feeRate,\n            period: feePeriod,\n            activated: 0,\n            lastPaid: 0,\n            highWaterMark: 0,\n            lastSharePrice: 0,\n            aggregateValueDue: 0\n        });\n        console.log(\"PerformaceFee:addFundSettings after comptrollerProxyToFeeInfo\");\n\n        emit FundSettingsAdded(_comptrollerProxy, feeRate, feePeriod);\n        console.log(\"PerformaceFee:addFundSettings after FundSettingsAdded\");\n\n        if (recipient != address(0)) {\n            __setRecipientForFund(_comptrollerProxy, recipient);\n        }\n    }\n\n    /// @notice Checks whether the shares outstanding for the fee can be paid out, and updates\n    /// the info for the fee's last payout\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return isPayable_ True if shares outstanding can be paid out\n    function payout(address _comptrollerProxy, address)\n        external\n        override\n        onlyFeeManager\n        returns (bool isPayable_)\n    {\n        if (!payoutAllowed(_comptrollerProxy)) {\n            return false;\n        }\n\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\n        feeInfo.lastPaid = uint64(block.timestamp);\n\n        uint256 prevHighWaterMark = feeInfo.highWaterMark;\n        uint256 nextHighWaterMark = __calcUint256Max(feeInfo.lastSharePrice, prevHighWaterMark);\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\n\n        // Update state as necessary\n        if (prevAggregateValueDue > 0) {\n            feeInfo.aggregateValueDue = 0;\n        }\n        if (nextHighWaterMark > prevHighWaterMark) {\n            feeInfo.highWaterMark = nextHighWaterMark;\n        }\n\n        emit PaidOut(\n            _comptrollerProxy,\n            prevHighWaterMark,\n            nextHighWaterMark,\n            prevAggregateValueDue\n        );\n\n        return true;\n    }\n\n    /// @notice Settles the fee and calculates shares due\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _gav The GAV of the fund\n    /// @return settlementType_ The type of settlement\n    /// @return (unused) The payer of shares due\n    /// @return sharesDue_ The amount of shares due\n    function settle(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook,\n        bytes calldata,\n        uint256 _gav\n    )\n        external\n        override\n        onlyFeeManager\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address,\n            uint256 sharesDue_\n        )\n    {\n        if (_gav == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        }\n\n        int256 settlementSharesDue = __settleAndUpdatePerformance(\n            _comptrollerProxy,\n            _vaultProxy,\n            _gav\n        );\n        if (settlementSharesDue == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        } else if (settlementSharesDue > 0) {\n            // Settle by minting shares outstanding for custody\n            return (\n                IFeeManager.SettlementType.MintSharesOutstanding,\n                address(0),\n                uint256(settlementSharesDue)\n            );\n        } else {\n            // Settle by burning from shares outstanding\n            return (\n                IFeeManager.SettlementType.BurnSharesOutstanding,\n                address(0),\n                uint256(-settlementSharesDue)\n            );\n        }\n    }\n\n    /// @notice Gets whether the fee settles and requires GAV on a particular hook\n    /// @param _hook The FeeHook\n    /// @return settles_ True if the fee settles on the _hook\n    /// @return usesGav_ True if the fee uses GAV during settle() for the _hook\n    function settlesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        override\n        returns (bool settles_, bool usesGav_)\n    {\n        if (\n            _hook == IFeeManager.FeeHook.PreBuyShares ||\n            _hook == IFeeManager.FeeHook.PreRedeemShares ||\n            _hook == IFeeManager.FeeHook.Continuous\n        ) {\n            return (true, true);\n        }\n\n        return (false, false);\n    }\n\n    /// @notice Updates the fee state after all fees have finished settle()\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _hook The FeeHook being executed\n    /// @param _settlementData Encoded args to use in calculating the settlement\n    /// @param _gav The GAV of the fund\n    function update(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes calldata _settlementData,\n        uint256 _gav\n    ) external override onlyFeeManager {\n        uint256 prevSharePrice = comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice;\n        uint256 nextSharePrice = __calcNextSharePrice(\n            _comptrollerProxy,\n            _vaultProxy,\n            _hook,\n            _settlementData,\n            _gav\n        );\n\n        if (nextSharePrice == prevSharePrice) {\n            return;\n        }\n\n        comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice = nextSharePrice;\n\n        emit LastSharePriceUpdated(_comptrollerProxy, prevSharePrice, nextSharePrice);\n    }\n\n    /// @notice Gets whether the fee updates and requires GAV on a particular hook\n    /// @param _hook The FeeHook\n    /// @return updates_ True if the fee updates on the _hook\n    /// @return usesGav_ True if the fee uses GAV during update() for the _hook\n    function updatesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        override\n        returns (bool updates_, bool usesGav_)\n    {\n        if (\n            _hook == IFeeManager.FeeHook.PostBuyShares ||\n            _hook == IFeeManager.FeeHook.PreRedeemShares ||\n            _hook == IFeeManager.FeeHook.Continuous\n        ) {\n            return (true, true);\n        }\n\n        return (false, false);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return recipient_ The recipient\n    function getRecipientForFund(address _comptrollerProxy)\n        public\n        view\n        override(FeeBase, SettableFeeRecipientBase)\n        returns (address recipient_)\n    {\n        return SettableFeeRecipientBase.getRecipientForFund(_comptrollerProxy);\n    }\n\n    /// @notice Checks whether the shares outstanding can be paid out\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return payoutAllowed_ True if the fee payment is due\n    /// @dev Payout is allowed if fees have not yet been settled in a crystallization period,\n    /// and at least 1 crystallization period has passed since activation\n    function payoutAllowed(address _comptrollerProxy) public view returns (bool payoutAllowed_) {\n        FeeInfo memory feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\n        uint256 period = feeInfo.period;\n\n        uint256 timeSinceActivated = block.timestamp.sub(feeInfo.activated);\n\n        // Check if at least 1 crystallization period has passed since activation\n        if (timeSinceActivated < period) {\n            return false;\n        }\n\n        // Check that a full crystallization period has passed since the last payout\n        uint256 timeSincePeriodStart = timeSinceActivated % period;\n        uint256 periodStart = block.timestamp.sub(timeSincePeriodStart);\n        return feeInfo.lastPaid < periodStart;\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to calculate the aggregated value accumulated to a fund since the last\n    /// settlement (happening at investment/redemption)\n    /// Validated:\n    /// _netSharesSupply > 0\n    /// _sharePriceWithoutPerformance != _prevSharePrice\n    function __calcAggregateValueDue(\n        uint256 _netSharesSupply,\n        uint256 _sharePriceWithoutPerformance,\n        uint256 _prevSharePrice,\n        uint256 _prevAggregateValueDue,\n        uint256 _feeRate,\n        uint256 _highWaterMark\n    ) private pure returns (uint256) {\n        int256 superHWMValueSinceLastSettled = (\n            int256(__calcUint256Max(_highWaterMark, _sharePriceWithoutPerformance)).sub(\n                int256(__calcUint256Max(_highWaterMark, _prevSharePrice))\n            )\n        )\n            .mul(int256(_netSharesSupply))\n            .div(int256(SHARE_UNIT));\n\n        int256 valueDueSinceLastSettled = superHWMValueSinceLastSettled.mul(int256(_feeRate)).div(\n            int256(ONE_HUNDRED_PERCENT)\n        );\n\n        return\n            uint256(\n                __calcInt256Max(0, int256(_prevAggregateValueDue).add(valueDueSinceLastSettled))\n            );\n    }\n\n    /// @dev Helper to calculate the max of two int values\n    function __calcInt256Max(int256 _a, int256 _b) private pure returns (int256) {\n        if (_a >= _b) {\n            return _a;\n        }\n\n        return _b;\n    }\n\n    /// @dev Helper to calculate the next `lastSharePrice` value\n    function __calcNextSharePrice(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook _hook,\n        bytes memory _settlementData,\n        uint256 _gav\n    ) private view returns (uint256 nextSharePrice_) {\n        uint256 denominationAssetUnit = 10 **\n            uint256(ERC20(ComptrollerLib(_comptrollerProxy).getDenominationAsset()).decimals());\n        if (_gav == 0) {\n            return denominationAssetUnit;\n        }\n\n        // Get shares outstanding via VaultProxy balance and calc shares supply to get net shares supply\n        ERC20 vaultProxyContract = ERC20(_vaultProxy);\n        uint256 totalSharesSupply = vaultProxyContract.totalSupply();\n        uint256 nextNetSharesSupply = totalSharesSupply.sub(\n            vaultProxyContract.balanceOf(_vaultProxy)\n        );\n        if (nextNetSharesSupply == 0) {\n            return denominationAssetUnit;\n        }\n\n        uint256 nextGav = _gav;\n\n        // For both Continuous and BuySharesCompleted hooks, _gav and shares supply will not change,\n        // we only need additional calculations for PreRedeemShares\n        if (_hook == IFeeManager.FeeHook.PreRedeemShares) {\n            (, uint256 sharesDecrease, ) = __decodePreRedeemSharesSettlementData(_settlementData);\n\n            // Shares have not yet been burned\n            nextNetSharesSupply = nextNetSharesSupply.sub(sharesDecrease);\n            if (nextNetSharesSupply == 0) {\n                return denominationAssetUnit;\n            }\n\n            // Assets have not yet been withdrawn\n            uint256 gavDecrease = _gav.mul(sharesDecrease).div(totalSharesSupply);\n\n            nextGav = nextGav.sub(gavDecrease);\n            if (nextGav == 0) {\n                return denominationAssetUnit;\n            }\n        }\n\n        return nextGav.mul(SHARE_UNIT).div(nextNetSharesSupply);\n    }\n\n    /// @dev Helper to calculate the performance metrics for a fund.\n    /// Validated:\n    /// _totalSharesSupply > 0\n    /// _gav > 0\n    /// _totalSharesSupply != _totalSharesOutstanding\n    function __calcPerformance(\n        address _comptrollerProxy,\n        uint256 _totalSharesSupply,\n        uint256 _totalSharesOutstanding,\n        uint256 _prevAggregateValueDue,\n        FeeInfo memory feeInfo,\n        uint256 _gav\n    ) private view returns (uint256 nextAggregateValueDue_, int256 sharesDue_) {\n        // Use the 'shares supply net shares outstanding' for performance calcs.\n        // Cannot be 0, as _totalSharesSupply != _totalSharesOutstanding\n        uint256 netSharesSupply = _totalSharesSupply.sub(_totalSharesOutstanding);\n        uint256 sharePriceWithoutPerformance = _gav.mul(SHARE_UNIT).div(netSharesSupply);\n\n        // If gross share price has not changed, can exit early\n        uint256 prevSharePrice = feeInfo.lastSharePrice;\n        if (sharePriceWithoutPerformance == prevSharePrice) {\n            return (_prevAggregateValueDue, 0);\n        }\n\n        nextAggregateValueDue_ = __calcAggregateValueDue(\n            netSharesSupply,\n            sharePriceWithoutPerformance,\n            prevSharePrice,\n            _prevAggregateValueDue,\n            feeInfo.rate,\n            feeInfo.highWaterMark\n        );\n\n        sharesDue_ = __calcSharesDue(\n            _comptrollerProxy,\n            netSharesSupply,\n            _gav,\n            nextAggregateValueDue_\n        );\n\n        return (nextAggregateValueDue_, sharesDue_);\n    }\n\n    /// @dev Helper to calculate sharesDue during settlement.\n    /// Validated:\n    /// _netSharesSupply > 0\n    /// _gav > 0\n    function __calcSharesDue(\n        address _comptrollerProxy,\n        uint256 _netSharesSupply,\n        uint256 _gav,\n        uint256 _nextAggregateValueDue\n    ) private view returns (int256 sharesDue_) {\n        // _nextAggregateValueDue should never be greater than _gav, as the max fee rate is 100%\n        uint256 sharesDueForAggregateValueDue = _nextAggregateValueDue.mul(_netSharesSupply).div(\n            _gav.sub(_nextAggregateValueDue)\n        );\n\n        // Shares due is the +/- diff or the total shares outstanding already minted\n        return\n            int256(sharesDueForAggregateValueDue).sub(\n                int256(\n                    FeeManager(FEE_MANAGER).getFeeSharesOutstandingForFund(\n                        _comptrollerProxy,\n                        address(this)\n                    )\n                )\n            );\n    }\n\n    /// @dev Helper to calculate the max of two uint values\n    function __calcUint256Max(uint256 _a, uint256 _b) private pure returns (uint256) {\n        if (_a >= _b) {\n            return _a;\n        }\n\n        return _b;\n    }\n\n    /// @dev Helper to settle the fee and update performance state.\n    /// Validated:\n    /// _gav > 0\n    function __settleAndUpdatePerformance(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        uint256 _gav\n    ) private returns (int256 sharesDue_) {\n        ERC20 sharesTokenContract = ERC20(_vaultProxy);\n\n        uint256 totalSharesSupply = sharesTokenContract.totalSupply();\n        if (totalSharesSupply == 0) {\n            return 0;\n        }\n\n        uint256 totalSharesOutstanding = sharesTokenContract.balanceOf(_vaultProxy);\n        if (totalSharesOutstanding == totalSharesSupply) {\n            return 0;\n        }\n\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\n\n        uint256 nextAggregateValueDue;\n        (nextAggregateValueDue, sharesDue_) = __calcPerformance(\n            _comptrollerProxy,\n            totalSharesSupply,\n            totalSharesOutstanding,\n            prevAggregateValueDue,\n            feeInfo,\n            _gav\n        );\n        if (nextAggregateValueDue == prevAggregateValueDue) {\n            return 0;\n        }\n\n        // Update fee state\n        feeInfo.aggregateValueDue = nextAggregateValueDue;\n\n        emit PerformanceUpdated(\n            _comptrollerProxy,\n            prevAggregateValueDue,\n            nextAggregateValueDue,\n            sharesDue_\n        );\n\n        return sharesDue_;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the feeInfo for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract of the fund\n    /// @return feeInfo_ The feeInfo\n    function getFeeInfoForFund(address _comptrollerProxy)\n        external\n        view\n        returns (FeeInfo memory feeInfo_)\n    {\n        return comptrollerProxyToFeeInfo[_comptrollerProxy];\n    }\n}\n"
    },
    "@openzeppelin/contracts/math/SignedSafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\n/**\n * @title SignedSafeMath\n * @dev Signed math operations with safety checks that revert on error.\n */\nlibrary SignedSafeMath {\n    int256 constant private _INT256_MIN = -2**255;\n\n    /**\n     * @dev Returns the multiplication of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(int256 a, int256 b) internal pure returns (int256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        require(!(a == -1 && b == _INT256_MIN), \"SignedSafeMath: multiplication overflow\");\n\n        int256 c = a * b;\n        require(c / a == b, \"SignedSafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two signed integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(int256 a, int256 b) internal pure returns (int256) {\n        require(b != 0, \"SignedSafeMath: division by zero\");\n        require(!(b == -1 && a == _INT256_MIN), \"SignedSafeMath: division overflow\");\n\n        int256 c = a / b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a - b;\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \"SignedSafeMath: subtraction overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two signed integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(int256 a, int256 b) internal pure returns (int256) {\n        int256 c = a + b;\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \"SignedSafeMath: addition overflow\");\n\n        return c;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/FeeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../IFee.sol\";\n\n/// @title FeeBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Abstract base contract for all fees\nabstract contract FeeBase is IFee {\n    address internal immutable FEE_MANAGER;\n\n    modifier onlyFeeManager {\n        require(msg.sender == FEE_MANAGER, \"Only the FeeManger can make this call\");\n        _;\n    }\n\n    constructor(address _feeManager) public {\n        FEE_MANAGER = _feeManager;\n    }\n\n    /// @notice Allows Fee to run logic during fund activation\n    /// @dev Unimplemented by default, may be overrode.\n    function activateForFund(address, address) external virtual override {\n        return;\n    }\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @dev address(0) signifies the VaultProxy owner.\n    /// Returns address(0) by default, can be overridden by fee.\n    function getRecipientForFund(address)\n        external\n        view\n        virtual\n        override\n        returns (address recipient_)\n    {\n        return address(0);\n    }\n\n    /// @notice Runs payout logic for a fee that utilizes shares outstanding as its settlement type\n    /// @dev Returns false by default, can be overridden by fee\n    function payout(address, address) external virtual override returns (bool) {\n        return false;\n    }\n\n    /// @notice Update fee state after all settlement has occurred during a given fee hook\n    /// @dev Unimplemented by default, can be overridden by fee\n    function update(\n        address,\n        address,\n        IFeeManager.FeeHook,\n        bytes calldata,\n        uint256\n    ) external virtual override {\n        return;\n    }\n\n    /// @notice Gets whether the fee updates and requires GAV on a particular hook\n    /// @return updates_ True if the fee updates on the _hook\n    /// @return usesGav_ True if the fee uses GAV during update() for the _hook\n    /// @dev Returns false values by default, can be overridden by fee\n    function updatesOnHook(IFeeManager.FeeHook)\n        external\n        view\n        virtual\n        override\n        returns (bool updates_, bool usesGav_)\n    {\n        return (false, false);\n    }\n\n    /// @notice Helper to parse settlement arguments from encoded data for PreBuyShares fee hook\n    function __decodePreBuySharesSettlementData(bytes memory _settlementData)\n        internal\n        pure\n        returns (address buyer_, uint256 investmentAmount_)\n    {\n        return abi.decode(_settlementData, (address, uint256));\n    }\n\n    /// @notice Helper to parse settlement arguments from encoded data for PreRedeemShares fee hook\n    function __decodePreRedeemSharesSettlementData(bytes memory _settlementData)\n        internal\n        pure\n        returns (\n            address redeemer_,\n            uint256 sharesQuantity_,\n            bool forSpecificAssets_\n        )\n    {\n        return abi.decode(_settlementData, (address, uint256, bool));\n    }\n\n    /// @notice Helper to parse settlement arguments from encoded data for PostBuyShares fee hook\n    function __decodePostBuySharesSettlementData(bytes memory _settlementData)\n        internal\n        pure\n        returns (\n            address buyer_,\n            uint256 investmentAmount_,\n            uint256 sharesIssued_\n        )\n    {\n        return abi.decode(_settlementData, (address, uint256, uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FEE_MANAGER` variable\n    /// @return feeManager_ The `FEE_MANAGER` variable value\n    function getFeeManager() external view returns (address feeManager_) {\n        return FEE_MANAGER;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/UpdatableFeeRecipientBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../../../../core/fund/vault/VaultLib.sol\";\nimport \"./SettableFeeRecipientBase.sol\";\n\n/// @title UpdatableFeeRecipientBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A base contract that provides an updatable fee recipient for the inheriting fee\nabstract contract UpdatableFeeRecipientBase is SettableFeeRecipientBase {\n    /// @notice Sets the fee recipient for the given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @param _recipient The fee recipient\n    function setRecipientForFund(address _comptrollerProxy, address _recipient) external {\n        require(\n            msg.sender ==\n                VaultLib(payable(ComptrollerLib(_comptrollerProxy).getVaultProxy())).getOwner(),\n            \"__setRecipientForFund: Only vault owner callable\"\n        );\n\n        __setRecipientForFund(_comptrollerProxy, _recipient);\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/SettableFeeRecipientBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title SettableFeeRecipientBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A base contract to set and get a fee recipient for the inheriting fee\nabstract contract SettableFeeRecipientBase {\n    event RecipientSetForFund(address indexed comptrollerProxy, address indexed recipient);\n\n    mapping(address => address) private comptrollerProxyToRecipient;\n\n    /// @dev Helper to set a fee recipient\n    function __setRecipientForFund(address _comptrollerProxy, address _recipient) internal {\n        comptrollerProxyToRecipient[_comptrollerProxy] = _recipient;\n\n        emit RecipientSetForFund(_comptrollerProxy, _recipient);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return recipient_ The recipient\n    /// @dev address(0) signifies the VaultProxy owner\n    function getRecipientForFund(address _comptrollerProxy)\n        public\n        view\n        virtual\n        returns (address recipient_)\n    {\n        return comptrollerProxyToRecipient[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/test/TestUpdatableFeeRecipientBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/extensions/fee-manager/fees/utils/UpdatableFeeRecipientBase.sol\";\n\n/// @title TestUpdatableFeeRecipientBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of UpdatableFeeRecipientBase\ncontract TestUpdatableFeeRecipientBase is UpdatableFeeRecipientBase {\n\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/ManagementFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../core/fund/vault/VaultLib.sol\";\nimport \"../../../utils/MakerDaoMath.sol\";\nimport \"./utils/FeeBase.sol\";\nimport \"./utils/UpdatableFeeRecipientBase.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title ManagementFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A management fee with a configurable annual rate\ncontract ManagementFee is FeeBase, UpdatableFeeRecipientBase, MakerDaoMath {\n    using SafeMath for uint256;\n\n    event ActivatedForMigratedFund(address indexed comptrollerProxy);\n\n    event FundSettingsAdded(address indexed comptrollerProxy, uint128 scaledPerSecondRate);\n\n    event Settled(\n        address indexed comptrollerProxy,\n        uint256 sharesQuantity,\n        uint256 secondsSinceSettlement\n    );\n\n    struct FeeInfo {\n        // The scaled rate representing 99.99% is under 10^28,\n        // thus `uint128 scaledPerSecondRate` is sufficient for any reasonable fee rate\n        uint128 scaledPerSecondRate;\n        uint128 lastSettled;\n    }\n\n    uint256 private constant RATE_SCALE_BASE = 10**27;\n\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\n\n    constructor(address _feeManager) public FeeBase(_feeManager) {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Activates the fee for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    function activateForFund(address _comptrollerProxy, address _vaultProxy)\n        external\n        override\n        onlyFeeManager\n    {\n        // It is only necessary to set `lastSettled` for a migrated fund\n        if (VaultLib(payable(_vaultProxy)).totalSupply() > 0) {\n            comptrollerProxyToFeeInfo[_comptrollerProxy].lastSettled = uint128(block.timestamp);\n\n            emit ActivatedForMigratedFund(_comptrollerProxy);\n        }\n    }\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        external\n        override\n        onlyFeeManager\n    {\n        console.log(\"ManagementFee:addFundSettings\");\n        console.logBytes(_settingsData);\n        (uint128 scaledPerSecondRate, address recipient) = abi.decode(\n            _settingsData,\n            (uint128, address)\n        );\n        console.log(\"ManagementFee:addFundSettings:scaledPerSecondRate:%d\", scaledPerSecondRate);\n        console.log(\"ManagementFee:addFundSettings:recipient:%s\", recipient);\n\n        require(\n            scaledPerSecondRate > 0,\n            \"addFundSettings: scaledPerSecondRate must be greater than 0\"\n        );\n        console.log(\"ManagementFee:addFundSettings:after require\");\n\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\n            scaledPerSecondRate: scaledPerSecondRate,\n            lastSettled: 0\n        });\n        console.log(\"ManagementFee:addFundSettings:comptrollerProxyToFeeInfo\");\n\n        emit FundSettingsAdded(_comptrollerProxy, scaledPerSecondRate);\n        console.log(\"ManagementFee:addFundSettings:FundSettingsAdded\");\n\n        if (recipient != address(0)) {\n            console.log(\"ManagementFee:addFundSettings:__setRecipientForFund begin\");\n            __setRecipientForFund(_comptrollerProxy, recipient);\n            console.log(\"ManagementFee:addFundSettings:__setRecipientForFund end\");\n        }\n    }\n\n    /// @notice Settle the fee and calculate shares due\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return settlementType_ The type of settlement\n    /// @return (unused) The payer of shares due\n    /// @return sharesDue_ The amount of shares due\n    function settle(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        IFeeManager.FeeHook,\n        bytes calldata,\n        uint256\n    )\n        external\n        override\n        onlyFeeManager\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address,\n            uint256 sharesDue_\n        )\n    {\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\n\n        // If this fee was settled in the current block, we can return early\n        uint256 secondsSinceSettlement = block.timestamp.sub(feeInfo.lastSettled);\n        if (secondsSinceSettlement == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        }\n\n        // If there are shares issued for the fund, calculate the shares due\n        VaultLib vaultProxyContract = VaultLib(payable(_vaultProxy));\n        uint256 sharesSupply = vaultProxyContract.totalSupply();\n        if (sharesSupply > 0) {\n            // This assumes that all shares in the VaultProxy are shares outstanding,\n            // which is fine for this release. Even if they are not, they are still shares that\n            // are only claimable by the fund owner.\n            uint256 netSharesSupply = sharesSupply.sub(vaultProxyContract.balanceOf(_vaultProxy));\n            if (netSharesSupply > 0) {\n                sharesDue_ = netSharesSupply\n                    .mul(\n                    __rpow(feeInfo.scaledPerSecondRate, secondsSinceSettlement, RATE_SCALE_BASE)\n                        .sub(RATE_SCALE_BASE)\n                )\n                    .div(RATE_SCALE_BASE);\n            }\n        }\n\n        // Must settle even when no shares are due, for the case that settlement is being\n        // done when there are no shares in the fund (i.e. at the first investment, or at the\n        // first investment after all shares have been redeemed)\n        comptrollerProxyToFeeInfo[_comptrollerProxy].lastSettled = uint128(block.timestamp);\n        emit Settled(_comptrollerProxy, sharesDue_, secondsSinceSettlement);\n\n        if (sharesDue_ == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        }\n\n        return (IFeeManager.SettlementType.Mint, address(0), sharesDue_);\n    }\n\n    /// @notice Gets whether the fee settles and requires GAV on a particular hook\n    /// @param _hook The FeeHook\n    /// @return settles_ True if the fee settles on the _hook\n    /// @return usesGav_ True if the fee uses GAV during settle() for the _hook\n    function settlesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        override\n        returns (bool settles_, bool usesGav_)\n    {\n        if (\n            _hook == IFeeManager.FeeHook.PreBuyShares ||\n            _hook == IFeeManager.FeeHook.PreRedeemShares ||\n            _hook == IFeeManager.FeeHook.Continuous\n        ) {\n            return (true, false);\n        }\n\n        return (false, false);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return recipient_ The recipient\n    function getRecipientForFund(address _comptrollerProxy)\n        public\n        view\n        override(FeeBase, SettableFeeRecipientBase)\n        returns (address recipient_)\n    {\n        return SettableFeeRecipientBase.getRecipientForFund(_comptrollerProxy);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the feeInfo for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract of the fund\n    /// @return feeInfo_ The feeInfo\n    function getFeeInfoForFund(address _comptrollerProxy)\n        external\n        view\n        returns (FeeInfo memory feeInfo_)\n    {\n        return comptrollerProxyToFeeInfo[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/release/utils/MakerDaoMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\n// Copyright (C) 2018 Rain <rainbreak@riseup.net>\n//\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public License\n// along with this program.  If not, see <https://www.gnu.org/licenses/>.\n\npragma solidity 0.6.12;\n\n/// @title MakerDaoMath Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Helper functions for math operations adapted from MakerDao contracts\nabstract contract MakerDaoMath {\n    /// @dev Performs scaled, fixed-point exponentiation.\n    /// Verbatim code, adapted to our style guide for variable naming only, see:\n    /// https://github.com/makerdao/dss/blob/master/src/pot.sol#L83-L105\n    // prettier-ignore\n    function __rpow(uint256 _x, uint256 _n, uint256 _base) internal pure returns (uint256 z_) {\n        assembly {\n            switch _x case 0 {switch _n case 0 {z_ := _base} default {z_ := 0}}\n            default {\n                switch mod(_n, 2) case 0 { z_ := _base } default { z_ := _x }\n                let half := div(_base, 2)\n                for { _n := div(_n, 2) } _n { _n := div(_n,2) } {\n                    let xx := mul(_x, _x)\n                    if iszero(eq(div(xx, _x), _x)) { revert(0,0) }\n                    let xxRound := add(xx, half)\n                    if lt(xxRound, xx) { revert(0,0) }\n                    _x := div(xxRound, _base)\n                    if mod(_n,2) {\n                        let zx := mul(z_, _x)\n                        if and(iszero(iszero(_x)), iszero(eq(div(zx, _x), z_))) { revert(0,0) }\n                        let zxRound := add(zx, half)\n                        if lt(zxRound, zx) { revert(0,0) }\n                        z_ := div(zxRound, _base)\n                    }\n                }\n            }\n        }\n\n        return z_;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/ExitRateFeeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./FeeBase.sol\";\n\n/// @title ExitRateFeeBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Calculates a fee based on a rate to be charged to an investor upon exiting a fund\nabstract contract ExitRateFeeBase is FeeBase {\n    using SafeMath for uint256;\n\n    event FundSettingsAdded(\n        address indexed comptrollerProxy,\n        uint256 inKindRate,\n        uint256 specificAssetsRate\n    );\n\n    event Settled(\n        address indexed comptrollerProxy,\n        address indexed payer,\n        uint256 sharesQuantity,\n        bool indexed forSpecificAssets\n    );\n\n    struct FeeInfo {\n        uint16 inKindRate;\n        uint16 specificAssetsRate;\n    }\n\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\n    IFeeManager.SettlementType private immutable SETTLEMENT_TYPE;\n\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\n\n    constructor(address _feeManager, IFeeManager.SettlementType _settlementType)\n        public\n        FeeBase(_feeManager)\n    {\n        require(\n            _settlementType == IFeeManager.SettlementType.Burn ||\n                _settlementType == IFeeManager.SettlementType.Direct,\n            \"constructor: Invalid _settlementType\"\n        );\n        SETTLEMENT_TYPE = _settlementType;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        public\n        virtual\n        override\n        onlyFeeManager\n    {\n        (uint16 inKindRate, uint16 specificAssetsRate) = abi.decode(\n            _settingsData,\n            (uint16, uint16)\n        );\n        require(inKindRate < ONE_HUNDRED_PERCENT, \"addFundSettings: inKindRate max exceeded\");\n        require(\n            specificAssetsRate < ONE_HUNDRED_PERCENT,\n            \"addFundSettings: specificAssetsRate max exceeded\"\n        );\n\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\n            inKindRate: inKindRate,\n            specificAssetsRate: specificAssetsRate\n        });\n\n        emit FundSettingsAdded(_comptrollerProxy, inKindRate, specificAssetsRate);\n    }\n\n    /// @notice Settles the fee\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settlementData Encoded args to use in calculating the settlement\n    /// @return settlementType_ The type of settlement\n    /// @return payer_ The payer of shares due\n    /// @return sharesDue_ The amount of shares due\n    function settle(\n        address _comptrollerProxy,\n        address,\n        IFeeManager.FeeHook,\n        bytes calldata _settlementData,\n        uint256\n    )\n        external\n        override\n        onlyFeeManager\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address payer_,\n            uint256 sharesDue_\n        )\n    {\n        bool forSpecificAssets;\n        uint256 sharesRedeemed;\n        (payer_, sharesRedeemed, forSpecificAssets) = __decodePreRedeemSharesSettlementData(\n            _settlementData\n        );\n\n        uint256 rate;\n        if (forSpecificAssets) {\n            rate = getSpecificAssetsRateForFund(_comptrollerProxy);\n        } else {\n            rate = getInKindRateForFund(_comptrollerProxy);\n        }\n\n        sharesDue_ = sharesRedeemed.mul(rate).div(ONE_HUNDRED_PERCENT);\n\n        if (sharesDue_ == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        }\n\n        emit Settled(_comptrollerProxy, payer_, sharesDue_, forSpecificAssets);\n\n        return (getSettlementType(), payer_, sharesDue_);\n    }\n\n    /// @notice Gets whether the fee settles and requires GAV on a particular hook\n    /// @param _hook The FeeHook\n    /// @return settles_ True if the fee settles on the _hook\n    /// @return usesGav_ True if the fee uses GAV during settle() for the _hook\n    function settlesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        override\n        returns (bool settles_, bool usesGav_)\n    {\n        if (_hook == IFeeManager.FeeHook.PreRedeemShares) {\n            return (true, false);\n        }\n\n        return (false, false);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the fee rate for an in-kind redemption\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return rate_ The fee rate\n    function getInKindRateForFund(address _comptrollerProxy) public view returns (uint256 rate_) {\n        return comptrollerProxyToFeeInfo[_comptrollerProxy].inKindRate;\n    }\n\n    /// @notice Gets the `SETTLEMENT_TYPE` variable\n    /// @return settlementType_ The `SETTLEMENT_TYPE` variable value\n    function getSettlementType() public view returns (IFeeManager.SettlementType settlementType_) {\n        return SETTLEMENT_TYPE;\n    }\n\n    /// @notice Gets the fee rate for a specific assets redemption\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return rate_ The fee rate\n    function getSpecificAssetsRateForFund(address _comptrollerProxy)\n        public\n        view\n        returns (uint256 rate_)\n    {\n        return comptrollerProxyToFeeInfo[_comptrollerProxy].specificAssetsRate;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/ExitRateDirectFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/ExitRateFeeBase.sol\";\nimport \"./utils/UpdatableFeeRecipientBase.sol\";\n\n/// @title ExitRateDirectFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An ExitRateFee that transfers the fee shares to a recipient\ncontract ExitRateDirectFee is ExitRateFeeBase, UpdatableFeeRecipientBase {\n    constructor(address _feeManager)\n        public\n        ExitRateFeeBase(_feeManager, IFeeManager.SettlementType.Direct)\n    {}\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    /// @dev onlyFeeManager validated by parent\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        public\n        override\n    {\n        super.addFundSettings(_comptrollerProxy, _settingsData);\n\n        (, , address recipient) = abi.decode(_settingsData, (uint256, uint256, address));\n\n        if (recipient != address(0)) {\n            __setRecipientForFund(_comptrollerProxy, recipient);\n        }\n    }\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return recipient_ The recipient\n    function getRecipientForFund(address _comptrollerProxy)\n        public\n        view\n        override(FeeBase, SettableFeeRecipientBase)\n        returns (address recipient_)\n    {\n        return SettableFeeRecipientBase.getRecipientForFund(_comptrollerProxy);\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/AllowedExternalPositionTypesPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../persistent/external-positions/IExternalPositionProxy.sol\";\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../../../../core/fund/vault/VaultLib.sol\";\nimport \"../utils/PolicyBase.sol\";\n\n/// @title AllowedExternalPositionTypesPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits external position types that can be used by a fund\ncontract AllowedExternalPositionTypesPolicy is PolicyBase {\n    event AllowedExternalPositionTypeAddedForFund(\n        address indexed comptrollerProxy,\n        uint256 indexed externalPositionTypeId\n    );\n\n    constructor(address _policyManager) public PolicyBase(_policyManager) {}\n\n    mapping(address => mapping(uint256 => bool))\n        private comptrollerProxyToExternalPositionTypeToIsAllowed;\n\n    /// @notice Validates and initializes a policy as necessary prior to fund activation\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    function activateForFund(address _comptrollerProxy) external override onlyPolicyManager {\n        address[] memory activeExternalPositions = VaultLib(\n            payable(ComptrollerLib(_comptrollerProxy).getVaultProxy())\n        )\n            .getActiveExternalPositions();\n        for (uint256 i; i < activeExternalPositions.length; i++) {\n            require(\n                externalPositionTypeIsAllowedForFund(\n                    _comptrollerProxy,\n                    IExternalPositionProxy(activeExternalPositions[i]).getExternalPositionType()\n                ),\n                \"activateForFund: Disallowed ExternalPositionType\"\n            );\n        }\n    }\n\n    /// @notice Adds the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    /// @dev Most funds that use this policy will likely not allow any external positions.\n    /// Does not prohibit specifying not-yet-defined external position type ids.\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        uint256[] memory allowedExternalPositionTypeIds = abi.decode(\n            _encodedSettings,\n            (uint256[])\n        );\n        for (uint256 i; i < allowedExternalPositionTypeIds.length; i++) {\n            comptrollerProxyToExternalPositionTypeToIsAllowed[_comptrollerProxy][allowedExternalPositionTypeIds[i]] = true;\n\n            emit AllowedExternalPositionTypeAddedForFund(\n                _comptrollerProxy,\n                allowedExternalPositionTypeIds[i]\n            );\n        }\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_EXTERNAL_POSITION_TYPES\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](2);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.CreateExternalPosition;\n        implementedHooks_[1] = IPolicyManager.PolicyHook.ReactivateExternalPosition;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _hook The PolicyHook\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook _hook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        uint256 externalPositionTypeId;\n        if (_hook == IPolicyManager.PolicyHook.CreateExternalPosition) {\n            (, externalPositionTypeId, ) = __decodeCreateExternalPositionValidationData(\n                _encodedArgs\n            );\n        } else {\n            // PolicyHook.ReactivateExternalPosition\n            (, address externalPosition) = __decodeReactivateExternalPositionValidationData(\n                _encodedArgs\n            );\n            externalPositionTypeId = IExternalPositionProxy(externalPosition)\n                .getExternalPositionType();\n        }\n\n        return externalPositionTypeIsAllowedForFund(_comptrollerProxy, externalPositionTypeId);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Checks whether a given external position type is allowed by a given fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _externalPositionTypeId The external position type id\n    /// @return isAllowed_ True if the external position type is allowed\n    function externalPositionTypeIsAllowedForFund(\n        address _comptrollerProxy,\n        uint256 _externalPositionTypeId\n    ) public view returns (bool isAllowed_) {\n        return\n            comptrollerProxyToExternalPositionTypeToIsAllowed[_comptrollerProxy][_externalPositionTypeId];\n    }\n}\n"
    },
    "contracts/persistent/external-positions/IExternalPositionProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExternalPositionProxy interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An interface for publicly accessible functions on the ExternalPositionProxy\ninterface IExternalPositionProxy {\n    function getExternalPositionType() external view returns (uint256);\n\n    function getVaultProxy() external view returns (address);\n}\n"
    },
    "contracts/release/extensions/external-position-manager/ExternalPositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    \n    (c) Enzyme Council <council@enzyme.finance>\n    \n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../persistent/external-positions/ExternalPositionFactory.sol\";\nimport \"../../../persistent/external-positions/IExternalPosition.sol\";\nimport \"../../../persistent/external-positions/IExternalPositionProxy.sol\";\nimport \"../policy-manager/IPolicyManager.sol\";\nimport \"../utils/ExtensionBase.sol\";\nimport \"../utils/PermissionedVaultActionMixin.sol\";\nimport \"./external-positions/IExternalPositionParser.sol\";\nimport \"./IExternalPositionManager.sol\";\n\n/// @title ExternalPositionManager\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Extension to handle external position actions for funds\ncontract ExternalPositionManager is\n    IExternalPositionManager,\n    ExtensionBase,\n    PermissionedVaultActionMixin\n{\n    event CallOnExternalPositionExecutedForFund(\n        address indexed caller,\n        address indexed comptrollerProxy,\n        address indexed externalPosition,\n        uint256 actionId,\n        bytes actionArgs,\n        address[] assetsToTransfer,\n        uint256[] amountsToTransfer,\n        address[] assetsToReceive\n    );\n\n    event ExternalPositionDeployedForFund(\n        address indexed comptrollerProxy,\n        address indexed vaultProxy,\n        address externalPosition,\n        uint256 indexed externalPositionTypeId,\n        bytes data\n    );\n\n    event ExternalPositionTypeInfoUpdated(uint256 indexed typeId, address lib, address parser);\n\n    address private immutable EXTERNAL_POSITION_FACTORY;\n    address private immutable POLICY_MANAGER;\n\n    mapping(uint256 => ExternalPositionTypeInfo) private typeIdToTypeInfo;\n\n    constructor(\n        address _fundDeployer,\n        address _externalPositionFactory,\n        address _policyManager\n    ) public ExtensionBase(_fundDeployer) {\n        EXTERNAL_POSITION_FACTORY = _externalPositionFactory;\n        POLICY_MANAGER = _policyManager;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Enables the ExternalPositionManager to be used by a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    function setConfigForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes calldata\n    ) external override onlyFundDeployer {\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\n    }\n\n    ///////////////////////////////\n    // CALL-ON-EXTENSION ACTIONS //\n    ///////////////////////////////\n\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\n    /// @param _caller The user who called for this action\n    /// @param _actionId An ID representing the desired action\n    /// @param _callArgs The encoded args for the action\n    function receiveCallFromComptroller(\n        address _caller,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override {\n        address comptrollerProxy = msg.sender;\n\n        // This validation comes at negligible cost but is not strictly necessary,\n        // as all actions below call permissioned actions on the VaultProxy,\n        // which will fail for an invalid ComptrollerProxy\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\n        require(vaultProxy != address(0), \"receiveCallFromComptroller: Fund is not valid\");\n\n        require(\n            IVault(vaultProxy).canManageAssets(_caller),\n            \"receiveCallFromComptroller: Unauthorized\"\n        );\n\n        // Dispatch the action\n        if (_actionId == uint256(ExternalPositionManagerActions.CreateExternalPosition)) {\n            __createExternalPosition(_caller, comptrollerProxy, vaultProxy, _callArgs);\n        } else if (_actionId == uint256(ExternalPositionManagerActions.CallOnExternalPosition)) {\n            __executeCallOnExternalPosition(_caller, comptrollerProxy, _callArgs);\n        } else if (_actionId == uint256(ExternalPositionManagerActions.RemoveExternalPosition)) {\n            __executeRemoveExternalPosition(_caller, comptrollerProxy, _callArgs);\n        } else if (\n            _actionId == uint256(ExternalPositionManagerActions.ReactivateExternalPosition)\n        ) {\n            __reactivateExternalPosition(_caller, comptrollerProxy, vaultProxy, _callArgs);\n        } else {\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\n        }\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Creates a new external position and links it to the _vaultProxy\n    function __createExternalPosition(\n        address _caller,\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes memory _callArgs\n    ) private {\n        (uint256 typeId, bytes memory initializationData) = abi.decode(\n            _callArgs,\n            (uint256, bytes)\n        );\n\n        address parser = getExternalPositionParserForType(typeId);\n        require(parser != address(0), \"__createExternalPosition: Invalid typeId\");\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.CreateExternalPosition,\n            abi.encode(_caller, typeId, initializationData)\n        );\n\n        // Pass in _vaultProxy in case the external position requires it during init() or further operations\n        bytes memory initArgs = IExternalPositionParser(parser).parseInitArgs(\n            _vaultProxy,\n            initializationData\n        );\n\n        bytes memory constructData = abi.encodeWithSelector(\n            IExternalPosition.init.selector,\n            initArgs\n        );\n\n        address externalPosition = ExternalPositionFactory(EXTERNAL_POSITION_FACTORY).deploy(\n            _vaultProxy,\n            typeId,\n            getExternalPositionLibForType(typeId),\n            constructData\n        );\n\n        emit ExternalPositionDeployedForFund(\n            _comptrollerProxy,\n            _vaultProxy,\n            externalPosition,\n            typeId,\n            initArgs\n        );\n\n        __addExternalPosition(_comptrollerProxy, externalPosition);\n    }\n\n    /// @dev Performs an action on a specific external position\n    function __executeCallOnExternalPosition(\n        address _caller,\n        address _comptrollerProxy,\n        bytes memory _callArgs\n    ) private {\n        (address payable externalPosition, uint256 actionId, bytes memory actionArgs) = abi.decode(\n            _callArgs,\n            (address, uint256, bytes)\n        );\n\n        address parser = getExternalPositionParserForType(\n            IExternalPositionProxy(externalPosition).getExternalPositionType()\n        );\n\n        (\n            address[] memory assetsToTransfer,\n            uint256[] memory amountsToTransfer,\n            address[] memory assetsToReceive\n        ) = IExternalPositionParser(parser).parseAssetsForAction(\n            externalPosition,\n            actionId,\n            actionArgs\n        );\n\n        bytes memory encodedActionData = abi.encode(actionId, actionArgs);\n\n        __callOnExternalPosition(\n            _comptrollerProxy,\n            abi.encode(\n                externalPosition,\n                encodedActionData,\n                assetsToTransfer,\n                amountsToTransfer,\n                assetsToReceive\n            )\n        );\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.PostCallOnExternalPosition,\n            abi.encode(\n                _caller,\n                externalPosition,\n                assetsToTransfer,\n                amountsToTransfer,\n                assetsToReceive,\n                encodedActionData\n            )\n        );\n\n        emit CallOnExternalPositionExecutedForFund(\n            _caller,\n            _comptrollerProxy,\n            externalPosition,\n            actionId,\n            actionArgs,\n            assetsToTransfer,\n            amountsToTransfer,\n            assetsToReceive\n        );\n    }\n\n    /// @dev Removes an external position from the VaultProxy\n    function __executeRemoveExternalPosition(\n        address _caller,\n        address _comptrollerProxy,\n        bytes memory _callArgs\n    ) private {\n        address externalPosition = abi.decode(_callArgs, (address));\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.RemoveExternalPosition,\n            abi.encode(_caller, externalPosition)\n        );\n\n        __removeExternalPosition(_comptrollerProxy, externalPosition);\n    }\n\n    ///@dev Reactivates an existing externalPosition\n    function __reactivateExternalPosition(\n        address _caller,\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes memory _callArgs\n    ) private {\n        address externalPosition = abi.decode(_callArgs, (address));\n\n        require(\n            ExternalPositionFactory(getExternalPositionFactory()).isExternalPositionProxy(\n                externalPosition\n            ),\n            \"__reactivateExternalPosition: Account provided is not a valid external position\"\n        );\n\n        require(\n            IExternalPositionProxy(externalPosition).getVaultProxy() == _vaultProxy,\n            \"__reactivateExternalPosition: External position belongs to a different vault\"\n        );\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.ReactivateExternalPosition,\n            abi.encode(_caller, externalPosition)\n        );\n\n        __addExternalPosition(_comptrollerProxy, externalPosition);\n    }\n\n    ///////////////////////////////////////////\n    // EXTERNAL POSITION TYPES INFO REGISTRY //\n    ///////////////////////////////////////////\n\n    /// @notice Updates the libs and parsers for a set of external position type ids\n    /// @param _typeIds The external position type ids for which to set the libs and parsers\n    /// @param _libs The libs\n    /// @param _parsers The parsers\n    function updateExternalPositionTypesInfo(\n        uint256[] memory _typeIds,\n        address[] memory _libs,\n        address[] memory _parsers\n    ) external onlyFundDeployerOwner {\n        require(\n            _typeIds.length == _parsers.length && _libs.length == _parsers.length,\n            \"updateExternalPositionTypesInfo: Unequal arrays\"\n        );\n\n        for (uint256 i; i < _typeIds.length; i++) {\n            require(\n                _typeIds[i] <\n                    ExternalPositionFactory(getExternalPositionFactory()).getPositionTypeCounter(),\n                \"updateExternalPositionTypesInfo: Type does not exist\"\n            );\n\n            typeIdToTypeInfo[_typeIds[i]] = ExternalPositionTypeInfo({\n                lib: _libs[i],\n                parser: _parsers[i]\n            });\n\n            emit ExternalPositionTypeInfoUpdated(_typeIds[i], _libs[i], _parsers[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `EXTERNAL_POSITION_FACTORY` variable\n    /// @return externalPositionFactory_ The `EXTERNAL_POSITION_FACTORY` variable value\n    function getExternalPositionFactory() public view returns (address externalPositionFactory_) {\n        return EXTERNAL_POSITION_FACTORY;\n    }\n\n    /// @notice Gets the external position library contract for a given type\n    /// @param _typeId The type for which to get the external position library\n    /// @return lib_ The external position library\n    function getExternalPositionLibForType(uint256 _typeId)\n        public\n        view\n        override\n        returns (address lib_)\n    {\n        return typeIdToTypeInfo[_typeId].lib;\n    }\n\n    /// @notice Gets the external position parser contract for a given type\n    /// @param _typeId The type for which to get the external position's parser\n    /// @return parser_ The external position parser\n    function getExternalPositionParserForType(uint256 _typeId)\n        public\n        view\n        returns (address parser_)\n    {\n        return typeIdToTypeInfo[_typeId].parser;\n    }\n\n    /// @notice Gets the `POLICY_MANAGER` variable\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\n    function getPolicyManager() public view returns (address policyManager_) {\n        return POLICY_MANAGER;\n    }\n}\n"
    },
    "contracts/persistent/external-positions/ExternalPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../dispatcher/IDispatcher.sol\";\nimport \"./ExternalPositionProxy.sol\";\n\n/// @title ExternalPositionFactory Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract factory for External Positions\ncontract ExternalPositionFactory {\n    event PositionDeployed(\n        address indexed vaultProxy,\n        uint256 indexed typeId,\n        address indexed constructLib,\n        bytes constructData\n    );\n\n    event PositionDeployerAdded(address positionDeployer);\n\n    event PositionDeployerRemoved(address positionDeployer);\n\n    event PositionTypeAdded(uint256 typeId, string label);\n\n    event PositionTypeLabelUpdated(uint256 indexed typeId, string label);\n\n    address private immutable DISPATCHER;\n\n    uint256 private positionTypeCounter;\n    mapping(uint256 => string) private positionTypeIdToLabel;\n    mapping(address => bool) private accountToIsExternalPositionProxy;\n    mapping(address => bool) private accountToIsPositionDeployer;\n\n    modifier onlyDispatcherOwner {\n        require(\n            msg.sender == IDispatcher(getDispatcher()).getOwner(),\n            \"Only the Dispatcher owner can call this function\"\n        );\n        _;\n    }\n\n    constructor(address _dispatcher) public {\n        DISPATCHER = _dispatcher;\n    }\n\n    /// @notice Creates a new external position proxy and adds it to the list of supported external positions\n    /// @param _constructData Encoded data to be used on the ExternalPositionProxy constructor\n    /// @param _vaultProxy The _vaultProxy owner of the external position\n    /// @param _typeId The type of external position to be created\n    /// @param _constructLib The external position lib contract that will be used on the constructor\n    function deploy(\n        address _vaultProxy,\n        uint256 _typeId,\n        address _constructLib,\n        bytes memory _constructData\n    ) external returns (address externalPositionProxy_) {\n        require(\n            isPositionDeployer(msg.sender),\n            \"deploy: Only a position deployer can call this function\"\n        );\n\n        externalPositionProxy_ = address(\n            new ExternalPositionProxy(_vaultProxy, _typeId, _constructLib, _constructData)\n        );\n\n        accountToIsExternalPositionProxy[externalPositionProxy_] = true;\n\n        emit PositionDeployed(_vaultProxy, _typeId, _constructLib, _constructData);\n\n        return externalPositionProxy_;\n    }\n\n    ////////////////////\n    // TYPES REGISTRY //\n    ////////////////////\n\n    /// @notice Adds a set of new position types\n    /// @param _labels Labels for each new position type\n    function addNewPositionTypes(string[] calldata _labels) external onlyDispatcherOwner {\n        for (uint256 i; i < _labels.length; i++) {\n            uint256 typeId = getPositionTypeCounter();\n            positionTypeCounter++;\n\n            positionTypeIdToLabel[typeId] = _labels[i];\n\n            emit PositionTypeAdded(typeId, _labels[i]);\n        }\n    }\n\n    /// @notice Updates a set of position type labels\n    /// @param _typeIds The position type ids\n    /// @param _labels The updated labels\n    function updatePositionTypeLabels(uint256[] calldata _typeIds, string[] calldata _labels)\n        external\n        onlyDispatcherOwner\n    {\n        require(_typeIds.length == _labels.length, \"updatePositionTypeLabels: Unequal arrays\");\n        for (uint256 i; i < _typeIds.length; i++) {\n            positionTypeIdToLabel[_typeIds[i]] = _labels[i];\n\n            emit PositionTypeLabelUpdated(_typeIds[i], _labels[i]);\n        }\n    }\n\n    /////////////////////////////////\n    // POSITION DEPLOYERS REGISTRY //\n    /////////////////////////////////\n\n    /// @notice Adds a set of new position deployers\n    /// @param _accounts Accounts to be added as position deployers\n    function addPositionDeployers(address[] memory _accounts) external onlyDispatcherOwner {\n        for (uint256 i; i < _accounts.length; i++) {\n            require(\n                !isPositionDeployer(_accounts[i]),\n                \"addPositionDeployers: Account is already a position deployer\"\n            );\n\n            accountToIsPositionDeployer[_accounts[i]] = true;\n\n            emit PositionDeployerAdded(_accounts[i]);\n        }\n    }\n\n    /// @notice Removes a set of existing position deployers\n    /// @param _accounts Existing position deployers to be removed from their role\n    function removePositionDeployers(address[] memory _accounts) external onlyDispatcherOwner {\n        for (uint256 i; i < _accounts.length; i++) {\n            require(\n                isPositionDeployer(_accounts[i]),\n                \"removePositionDeployers: Account is not a position deployer\"\n            );\n\n            accountToIsPositionDeployer[_accounts[i]] = false;\n\n            emit PositionDeployerRemoved(_accounts[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Gets the label for a position type\n    /// @param _typeId The position type id\n    /// @return label_ The label\n    function getLabelForPositionType(uint256 _typeId)\n        external\n        view\n        returns (string memory label_)\n    {\n        return positionTypeIdToLabel[_typeId];\n    }\n\n    /// @notice Checks if an account is an external position proxy\n    /// @param _account The account to check\n    /// @return isExternalPositionProxy_ True if the account is an externalPositionProxy\n    function isExternalPositionProxy(address _account)\n        external\n        view\n        returns (bool isExternalPositionProxy_)\n    {\n        return accountToIsExternalPositionProxy[_account];\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the `positionTypeCounter` variable\n    /// @return positionTypeCounter_ The `positionTypeCounter` variable value\n    function getPositionTypeCounter() public view returns (uint256 positionTypeCounter_) {\n        return positionTypeCounter;\n    }\n\n    /// @notice Checks if an account is a position deployer\n    /// @param _account The account to check\n    /// @return isPositionDeployer_ True if the account is a position deployer\n    function isPositionDeployer(address _account) public view returns (bool isPositionDeployer_) {\n        return accountToIsPositionDeployer[_account];\n    }\n}\n"
    },
    "contracts/release/extensions/external-position-manager/external-positions/IExternalPositionParser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IExternalPositionParser Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Interface for all external position parsers\ninterface IExternalPositionParser {\n    function parseAssetsForAction(\n        address _externalPosition,\n        uint256 _actionId,\n        bytes memory _encodedActionArgs\n    )\n        external\n        returns (\n            address[] memory assetsToTransfer_,\n            uint256[] memory amountsToTransfer_,\n            address[] memory assetsToReceive_\n        );\n\n    function parseInitArgs(address _vaultProxy, bytes memory _initializationData)\n        external\n        returns (bytes memory initArgs_);\n}\n"
    },
    "contracts/persistent/external-positions/ExternalPositionProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../vault/interfaces/IExternalPositionVault.sol\";\nimport \"./IExternalPosition.sol\";\nimport \"./IExternalPositionProxy.sol\";\n\n/// @title ExternalPositionProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy for all external positions, modified from EIP-1822\ncontract ExternalPositionProxy is IExternalPositionProxy {\n    uint256 private immutable EXTERNAL_POSITION_TYPE;\n    address private immutable VAULT_PROXY;\n\n    /// @dev Needed to receive ETH on external positions\n    receive() external payable {}\n\n    constructor(\n        address _vaultProxy,\n        uint256 _typeId,\n        address _constructLib,\n        bytes memory _constructData\n    ) public {\n        VAULT_PROXY = _vaultProxy;\n        EXTERNAL_POSITION_TYPE = _typeId;\n\n        (bool success, bytes memory returnData) = _constructLib.delegatecall(_constructData);\n\n        require(success, string(returnData));\n    }\n\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        address contractLogic = IExternalPositionVault(getVaultProxy())\n            .getExternalPositionLibForType(getExternalPositionType());\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n\n    /// @notice Delegates call to IExternalPosition.receiveCallFromVault\n    /// @param _data The bytes data variable to be decoded at the External Position\n    function receiveCallFromVault(bytes calldata _data) external {\n        require(\n            msg.sender == getVaultProxy(),\n            \"receiveCallFromVault: Only the vault can make this call\"\n        );\n        address contractLogic = IExternalPositionVault(getVaultProxy())\n            .getExternalPositionLibForType(getExternalPositionType());\n        (bool success, bytes memory returnData) = contractLogic.delegatecall(\n            abi.encodeWithSelector(IExternalPosition.receiveCallFromVault.selector, _data)\n        );\n\n        require(success, string(returnData));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `EXTERNAL_POSITION_TYPE` variable\n    /// @return externalPositionType_ The `EXTERNAL_POSITION_TYPE` variable value\n    function getExternalPositionType()\n        public\n        view\n        override\n        returns (uint256 externalPositionType_)\n    {\n        return EXTERNAL_POSITION_TYPE;\n    }\n\n    /// @notice Gets the `VAULT_PROXY` variable\n    /// @return vaultProxy_ The `VAULT_PROXY` variable value\n    function getVaultProxy() public view override returns (address vaultProxy_) {\n        return VAULT_PROXY;\n    }\n}\n"
    },
    "contracts/release/extensions/external-position-manager/external-positions/compound-debt/CompoundDebtPositionParser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/CompoundPriceFeed.sol\";\nimport \"../../../../infrastructure/value-interpreter/ValueInterpreter.sol\";\nimport \"../IExternalPositionParser.sol\";\nimport \"./ICompoundDebtPosition.sol\";\n\npragma solidity 0.6.12;\n\n/// @title CompoundDebtPositionParser\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Parser for Compound Debt Positions\ncontract CompoundDebtPositionParser is IExternalPositionParser {\n    address private immutable COMP_TOKEN;\n    address private immutable COMPOUND_PRICE_FEED;\n    address private immutable VALUE_INTERPRETER;\n\n    constructor(\n        address _compoundPriceFeed,\n        address _compToken,\n        address _valueInterpreter\n    ) public {\n        COMPOUND_PRICE_FEED = _compoundPriceFeed;\n        COMP_TOKEN = _compToken;\n        VALUE_INTERPRETER = _valueInterpreter;\n    }\n\n    /// @notice Parses the assets to send and receive for the callOnExternalPosition\n    /// @param _actionId The _actionId for the callOnExternalPosition\n    /// @param _encodedActionArgs The encoded parameters for the callOnExternalPosition\n    /// @return assetsToTransfer_ The assets to be transfered from the Vault\n    /// @return amountsToTransfer_ The amounts to be transfered from the Vault\n    /// @return assetsToReceive_ The assets to be received at the Vault\n    function parseAssetsForAction(\n        address,\n        uint256 _actionId,\n        bytes memory _encodedActionArgs\n    )\n        external\n        override\n        returns (\n            address[] memory assetsToTransfer_,\n            uint256[] memory amountsToTransfer_,\n            address[] memory assetsToReceive_\n        )\n    {\n        (\n            address[] memory assets,\n            uint256[] memory amounts,\n            bytes memory data\n        ) = __decodeEncodedActionArgs(_encodedActionArgs);\n\n        __validateActionData(_actionId, assets, data);\n\n        if (\n            _actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.AddCollateral) ||\n            _actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.RepayBorrow)\n        ) {\n            assetsToTransfer_ = assets;\n            amountsToTransfer_ = amounts;\n        } else if (\n            _actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.Borrow) ||\n            _actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.RemoveCollateral)\n        ) {\n            assetsToReceive_ = assets;\n        } else if (_actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.ClaimComp)) {\n            assetsToReceive_ = new address[](1);\n            assetsToReceive_[0] = getCompToken();\n        }\n\n        return (assetsToTransfer_, amountsToTransfer_, assetsToReceive_);\n    }\n\n    /// @notice Parse and validate input arguments to be used when initializing a newly-deployed ExternalPositionProxy\n    /// @return initArgs_ Parsed and encoded args for ExternalPositionProxy.init()\n    function parseInitArgs(address, bytes memory)\n        external\n        override\n        returns (bytes memory initArgs_)\n    {\n        return \"\";\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode action args\n    function __decodeEncodedActionArgs(bytes memory _encodeActionArgs)\n        private\n        pure\n        returns (\n            address[] memory assets_,\n            uint256[] memory amounts_,\n            bytes memory data_\n        )\n    {\n        (assets_, amounts_, data_) = abi.decode(_encodeActionArgs, (address[], uint256[], bytes));\n\n        return (assets_, amounts_, data_);\n    }\n\n    /// @dev Runs validations before running a callOnExternalPosition.\n    function __validateActionData(\n        uint256 _actionId,\n        address[] memory _assets,\n        bytes memory _data\n    ) private view {\n        // Borrow and RepayBorrow actions make use of cTokens, that also need to be validated\n        if (_actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.Borrow)) {\n            for (uint256 i; i < _assets.length; i++) {\n                require(\n                    IValueInterpreter(getValueInterpreter()).isSupportedAsset(_assets[i]),\n                    \"__validateActionData: Unsupported asset\"\n                );\n            }\n            __validateCTokens(abi.decode(_data, (address[])), _assets);\n        } else if (\n            _actionId == uint256(ICompoundDebtPosition.ExternalPositionActions.RepayBorrow)\n        ) {\n            __validateCTokens(abi.decode(_data, (address[])), _assets);\n        }\n    }\n\n    /// @dev Validates a set of cTokens and the underlying tokens\n    function __validateCTokens(address[] memory _cTokens, address[] memory _tokens) private view {\n        require(\n            _cTokens.length == _tokens.length,\n            \"__validateCTokens: Unequal assets and cTokens length\"\n        );\n\n        for (uint256 i; i < _cTokens.length; i++) {\n            require(\n                CompoundPriceFeed(getCompoundPriceFeed()).getTokenFromCToken(_cTokens[i]) ==\n                    _tokens[i],\n                \"__validateCTokens: Bad token cToken pair\"\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `COMPOUND_PRICE_FEED` variable\n    /// @return compoundPriceFeed_ The `COMPOUND_PRICE_FEED` variable value\n    function getCompoundPriceFeed() public view returns (address compoundPriceFeed_) {\n        return COMPOUND_PRICE_FEED;\n    }\n\n    /// @notice Gets the `COMP_TOKEN` variable\n    /// @return compToken_ The `COMP_TOKEN` variable value\n    function getCompToken() public view returns (address compToken_) {\n        return COMP_TOKEN;\n    }\n\n    /// @notice Gets the `VALUE_INTERPRETER` variable\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\n        return VALUE_INTERPRETER;\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/CompoundPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../interfaces/ICERC20.sol\";\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../IDerivativePriceFeed.sol\";\n\n/// @title CompoundPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for Compound Tokens (cTokens)\ncontract CompoundPriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event CTokenAdded(address indexed cToken, address indexed token);\n\n    uint256 private constant CTOKEN_RATE_DIVISOR = 10**18;\n\n    mapping(address => address) private cTokenToToken;\n\n    constructor(\n        address _fundDeployer,\n        address _weth,\n        address _ceth\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        // Set cEth\n        cTokenToToken[_ceth] = _weth;\n        emit CTokenAdded(_ceth, _weth);\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        underlyings_ = new address[](1);\n        underlyings_[0] = cTokenToToken[_derivative];\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\n\n        underlyingAmounts_ = new uint256[](1);\n        // Returns a rate scaled to 10^18\n        underlyingAmounts_[0] = _derivativeAmount\n            .mul(ICERC20(_derivative).exchangeRateStored())\n            .div(CTOKEN_RATE_DIVISOR);\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\n        return cTokenToToken[_asset] != address(0);\n    }\n\n    //////////////////////\n    // CTOKENS REGISTRY //\n    //////////////////////\n\n    /// @notice Adds cTokens to the price feed\n    /// @param _cTokens cTokens to add\n    /// @dev Only allows CERC20 tokens. CEther is set in the constructor.\n    function addCTokens(address[] calldata _cTokens) external onlyFundDeployerOwner {\n        require(_cTokens.length > 0, \"addCTokens: Empty _cTokens\");\n\n        for (uint256 i; i < _cTokens.length; i++) {\n            require(cTokenToToken[_cTokens[i]] == address(0), \"addCTokens: Value already set\");\n\n            address token = ICERC20(_cTokens[i]).underlying();\n            cTokenToToken[_cTokens[i]] = token;\n\n            emit CTokenAdded(_cTokens[i], token);\n        }\n    }\n\n    ////////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Returns the underlying asset of a given cToken\n    /// @param _cToken The cToken for which to get the underlying asset\n    /// @return token_ The underlying token\n    function getTokenFromCToken(address _cToken) public view returns (address token_) {\n        return cTokenToToken[_cToken];\n    }\n}\n"
    },
    "contracts/release/extensions/external-position-manager/external-positions/compound-debt/ICompoundDebtPosition.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\nimport \"../../../../../persistent/external-positions/IExternalPosition.sol\";\n\npragma solidity 0.6.12;\n\n/// @title ICompoundDebtPosition Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICompoundDebtPosition is IExternalPosition {\n    enum ExternalPositionActions {AddCollateral, RemoveCollateral, Borrow, RepayBorrow, ClaimComp}\n}\n"
    },
    "contracts/release/interfaces/ICERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity ^0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title ICERC20 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for interactions with Compound tokens (cTokens)\ninterface ICERC20 is IERC20 {\n    function accrueInterest() external returns (uint256);\n\n    function borrow(uint256) external returns (uint256);\n\n    function borrowBalanceStored(address) external view returns (uint256);\n\n    function decimals() external view returns (uint8);\n\n    function mint(uint256) external returns (uint256);\n\n    function redeem(uint256) external returns (uint256);\n\n    function repayBorrow(uint256) external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function underlying() external returns (address);\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/GasRelayPaymasterLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../interfaces/IGsnRelayHub.sol\";\nimport \"../../interfaces/IGsnTypes.sol\";\nimport \"../../interfaces/IWETH.sol\";\nimport \"../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../../core/fund-deployer/FundDeployer.sol\";\nimport \"../../extensions/policy-manager/PolicyManager.sol\";\nimport \"./bases/GasRelayPaymasterLibBase1.sol\";\nimport \"./IGasRelayPaymaster.sol\";\nimport \"./IGasRelayPaymasterDepositor.sol\";\n\n/// @title GasRelayPaymasterLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The core logic library for the \"paymaster\" contract which refunds GSN relayers\ncontract GasRelayPaymasterLib is IGasRelayPaymaster, GasRelayPaymasterLibBase1 {\n    using SafeMath for uint256;\n\n    // Immutable and constants\n    // Sane defaults, subject to change after gas profiling\n    uint256 private constant CALLDATA_SIZE_LIMIT = 10500;\n    // Deposit in wei\n    uint256 private constant DEPOSIT = 0.2 ether;\n    // Sane defaults, subject to change after gas profiling\n    uint256 private constant PRE_RELAYED_CALL_GAS_LIMIT = 100000;\n    uint256 private constant POST_RELAYED_CALL_GAS_LIMIT = 110000;\n    // FORWARDER_HUB_OVERHEAD = 50000;\n    // PAYMASTER_ACCEPTANCE_BUDGET = FORWARDER_HUB_OVERHEAD + PRE_RELAYED_CALL_GAS_LIMIT\n    uint256 private constant PAYMASTER_ACCEPTANCE_BUDGET = 150000;\n\n    address private immutable RELAY_HUB;\n    address private immutable TRUSTED_FORWARDER;\n    address private immutable WETH_TOKEN;\n\n    modifier onlyComptroller() {\n        require(\n            msg.sender == getParentComptroller(),\n            \"Can only be called by the parent comptroller\"\n        );\n        _;\n    }\n\n    modifier relayHubOnly() {\n        require(msg.sender == getHubAddr(), \"Can only be called by RelayHub\");\n        _;\n    }\n\n    constructor(\n        address _wethToken,\n        address _relayHub,\n        address _trustedForwarder\n    ) public {\n        RELAY_HUB = _relayHub;\n        TRUSTED_FORWARDER = _trustedForwarder;\n        WETH_TOKEN = _wethToken;\n    }\n\n    // INIT\n\n    /// @notice Initializes a paymaster proxy\n    /// @param _vault The VaultProxy associated with the paymaster proxy\n    /// @dev Used to set the owning vault\n    function init(address _vault) external {\n        require(getParentVault() == address(0), \"init: Paymaster already initialized\");\n\n        parentVault = _vault;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Pull deposit from the vault and reactivate relaying\n    function deposit() external override onlyComptroller {\n        __depositMax();\n    }\n\n    /// @notice Checks whether the paymaster will pay for a given relayed tx\n    /// @param _relayRequest The full relay request structure\n    /// @return context_ The tx signer and the fn sig, encoded so that it can be passed to `postRelayCall`\n    /// @return rejectOnRecipientRevert_ Always false\n    function preRelayedCall(\n        IGsnTypes.RelayRequest calldata _relayRequest,\n        bytes calldata,\n        bytes calldata,\n        uint256\n    )\n        external\n        override\n        relayHubOnly\n        returns (bytes memory context_, bool rejectOnRecipientRevert_)\n    {\n        address vaultProxy = getParentVault();\n        require(\n            IVault(vaultProxy).canRelayCalls(_relayRequest.request.from),\n            \"preRelayedCall: Unauthorized caller\"\n        );\n\n        bytes4 selector = __parseTxDataFunctionSelector(_relayRequest.request.data);\n        require(\n            __isAllowedCall(\n                vaultProxy,\n                _relayRequest.request.to,\n                selector,\n                _relayRequest.request.data\n            ),\n            \"preRelayedCall: Function call not permitted\"\n        );\n\n        return (abi.encode(_relayRequest.request.from, selector), false);\n    }\n\n    /// @notice Called by the relay hub after the relayed tx is executed, tops up deposit if flag passed through paymasterdata is true\n    /// @param _context The context constructed by preRelayedCall (used to pass data from pre to post relayed call)\n    /// @param _success Whether or not the relayed tx succeed\n    /// @param _relayData The relay params of the request. can be used by relayHub.calculateCharge()\n    function postRelayedCall(\n        bytes calldata _context,\n        bool _success,\n        uint256,\n        IGsnTypes.RelayData calldata _relayData\n    ) external override relayHubOnly {\n        bool shouldTopUpDeposit = abi.decode(_relayData.paymasterData, (bool));\n        if (shouldTopUpDeposit) {\n            __depositMax();\n        }\n\n        (address spender, bytes4 selector) = abi.decode(_context, (address, bytes4));\n        emit TransactionRelayed(spender, selector, _success);\n    }\n\n    /// @notice Send any deposited ETH back to the vault\n    function withdrawBalance() external override {\n        address vaultProxy = getParentVault();\n        require(\n            msg.sender == IVault(vaultProxy).getOwner() ||\n                msg.sender == __getComptrollerForVault(vaultProxy),\n            \"withdrawBalance: Only owner or comptroller is authorized\"\n        );\n\n        IGsnRelayHub(getHubAddr()).withdraw(getRelayHubDeposit(), payable(address(this)));\n\n        uint256 amount = address(this).balance;\n\n        Address.sendValue(payable(vaultProxy), amount);\n\n        emit Withdrawn(amount);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the current ComptrollerProxy of the VaultProxy associated with this contract\n    /// @return parentComptroller_ The ComptrollerProxy\n    function getParentComptroller() public view returns (address parentComptroller_) {\n        return __getComptrollerForVault(parentVault);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to pull WETH from the associated vault to top up to the max ETH deposit in the relay hub\n    function __depositMax() private {\n        uint256 prevDeposit = getRelayHubDeposit();\n\n        if (prevDeposit < DEPOSIT) {\n            uint256 amount = DEPOSIT.sub(prevDeposit);\n\n            IGasRelayPaymasterDepositor(getParentComptroller()).pullWethForGasRelayer(amount);\n\n            IWETH(getWethToken()).withdraw(amount);\n\n            IGsnRelayHub(getHubAddr()).depositFor{value: amount}(address(this));\n\n            emit Deposited(amount);\n        }\n    }\n\n    /// @dev Helper to get the ComptrollerProxy for a given VaultProxy\n    function __getComptrollerForVault(address _vaultProxy)\n        private\n        view\n        returns (address comptrollerProxy_)\n    {\n        return IVault(_vaultProxy).getAccessor();\n    }\n\n    /// @dev Helper to check if a contract call is allowed to be relayed using this paymaster\n    /// Allowed contracts are:\n    /// - VaultProxy\n    /// - ComptrollerProxy\n    /// - PolicyManager\n    /// - FundDeployer\n    function __isAllowedCall(\n        address _vaultProxy,\n        address _contract,\n        bytes4 _selector,\n        bytes calldata _txData\n    ) private view returns (bool allowed_) {\n        if (_contract == _vaultProxy) {\n            // All calls to the VaultProxy are allowed\n            return true;\n        }\n\n        address parentComptroller = __getComptrollerForVault(_vaultProxy);\n        if (_contract == parentComptroller) {\n            if (\n                _selector == ComptrollerLib.callOnExtension.selector ||\n                _selector == ComptrollerLib.vaultCallOnContract.selector ||\n                _selector == ComptrollerLib.buyBackProtocolFeeShares.selector ||\n                _selector == ComptrollerLib.depositToGasRelayPaymaster.selector ||\n                _selector == ComptrollerLib.setAutoProtocolFeeSharesBuyback.selector\n            ) {\n                return true;\n            }\n        } else if (_contract == ComptrollerLib(parentComptroller).getPolicyManager()) {\n            if (\n                _selector == PolicyManager.updatePolicySettingsForFund.selector ||\n                _selector == PolicyManager.enablePolicyForFund.selector ||\n                _selector == PolicyManager.disablePolicyForFund.selector\n            ) {\n                return __parseTxDataFirstParameterAsAddress(_txData) == getParentComptroller();\n            }\n        } else if (_contract == ComptrollerLib(parentComptroller).getFundDeployer()) {\n            if (\n                _selector == FundDeployer.createReconfigurationRequest.selector ||\n                _selector == FundDeployer.executeReconfiguration.selector ||\n                _selector == FundDeployer.cancelReconfiguration.selector\n            ) {\n                return __parseTxDataFirstParameterAsAddress(_txData) == getParentVault();\n            }\n        }\n\n        return false;\n    }\n\n    /// @notice Parses the first parameter of tx data as an address\n    /// @param _txData The tx data to retrieve the address from\n    /// @return retrievedAddress_ The extracted address\n    function __parseTxDataFirstParameterAsAddress(bytes calldata _txData)\n        private\n        pure\n        returns (address retrievedAddress_)\n    {\n        require(\n            _txData.length >= 36,\n            \"__parseTxDataFirstParameterAsAddress: _txData is not a valid length\"\n        );\n\n        return abi.decode(_txData[4:36], (address));\n    }\n\n    /// @notice Parses the function selector from tx data\n    /// @param _txData The tx data\n    /// @return functionSelector_ The extracted function selector\n    function __parseTxDataFunctionSelector(bytes calldata _txData)\n        private\n        pure\n        returns (bytes4 functionSelector_)\n    {\n        /// convert bytes[:4] to bytes4\n        require(\n            _txData.length >= 4,\n            \"__parseTxDataFunctionSelector: _txData is not a valid length\"\n        );\n\n        functionSelector_ =\n            _txData[0] |\n            (bytes4(_txData[1]) >> 8) |\n            (bytes4(_txData[2]) >> 16) |\n            (bytes4(_txData[3]) >> 24);\n\n        return functionSelector_;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets gas limits used by the relay hub for the pre and post relay calls\n    /// @return limits_ `GasAndDataLimits(PAYMASTER_ACCEPTANCE_BUDGET, PRE_RELAYED_CALL_GAS_LIMIT, POST_RELAYED_CALL_GAS_LIMIT, CALLDATA_SIZE_LIMIT)`\n    function getGasAndDataLimits()\n        external\n        view\n        override\n        returns (IGsnPaymaster.GasAndDataLimits memory limits_)\n    {\n        return\n            IGsnPaymaster.GasAndDataLimits(\n                PAYMASTER_ACCEPTANCE_BUDGET,\n                PRE_RELAYED_CALL_GAS_LIMIT,\n                POST_RELAYED_CALL_GAS_LIMIT,\n                CALLDATA_SIZE_LIMIT\n            );\n    }\n\n    /// @notice Gets the `RELAY_HUB` variable value\n    /// @return relayHub_ The `RELAY_HUB` value\n    function getHubAddr() public view override returns (address relayHub_) {\n        return RELAY_HUB;\n    }\n\n    /// @notice Gets the `parentVault` variable value\n    /// @return parentVault_ The `parentVault` value\n    function getParentVault() public view returns (address parentVault_) {\n        return parentVault;\n    }\n\n    /// @notice Look up amount of ETH deposited on the relay hub\n    /// @return depositBalance_ amount of ETH deposited on the relay hub\n    function getRelayHubDeposit() public view override returns (uint256 depositBalance_) {\n        return IGsnRelayHub(getHubAddr()).balanceOf(address(this));\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable value\n    /// @return wethToken_ The `WETH_TOKEN` value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n\n    /// @notice Gets the `TRUSTED_FORWARDER` variable value\n    /// @return trustedForwarder_ The forwarder contract which is trusted to validated the relayed tx signature\n    function trustedForwarder() external view override returns (address trustedForwarder_) {\n        return TRUSTED_FORWARDER;\n    }\n\n    /// @notice Gets the string representation of the contract version (fulfills interface)\n    /// @return versionString_ The version string\n    function versionPaymaster() external view override returns (string memory versionString_) {\n        return \"2.2.3+opengsn.enzymefund.ipaymaster\";\n    }\n}\n"
    },
    "contracts/release/interfaces/IGsnRelayHub.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"./IGsnTypes.sol\";\n\n/// @title IGsnRelayHub Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IGsnRelayHub {\n    function balanceOf(address target) external view returns (uint256);\n\n    function calculateCharge(uint256 gasUsed, IGsnTypes.RelayData calldata relayData)\n        external\n        view\n        returns (uint256);\n\n    function depositFor(address target) external payable;\n\n    function relayCall(\n        uint256 maxAcceptanceBudget,\n        IGsnTypes.RelayRequest calldata relayRequest,\n        bytes calldata signature,\n        bytes calldata approvalData,\n        uint256 externalGasLimit\n    ) external returns (bool paymasterAccepted, bytes memory returnValue);\n\n    function withdraw(uint256 amount, address payable dest) external;\n}\n"
    },
    "contracts/release/core/fund-deployer/FundDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../../persistent/dispatcher/IMigrationHookHandler.sol\";\nimport \"../../extensions/IExtension.sol\";\nimport \"../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\";\nimport \"../../infrastructure/protocol-fees/IProtocolFeeTracker.sol\";\nimport \"../fund/comptroller/ComptrollerProxy.sol\";\nimport \"../fund/comptroller/IComptroller.sol\";\nimport \"../fund/vault/IVault.sol\";\nimport \"./IFundDeployer.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title FundDeployer Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The top-level contract of the release.\n/// It primarily coordinates fund deployment and fund migration, but\n/// it is also deferred to for contract access control and for allowed calls\n/// that can be made with a fund's VaultProxy as the msg.sender.\ncontract FundDeployer is IFundDeployer, IMigrationHookHandler, GasRelayRecipientMixin {\n    event BuySharesOnBehalfCallerDeregistered(address caller);\n\n    event BuySharesOnBehalfCallerRegistered(address caller);\n\n    event ComptrollerLibSet(address comptrollerLib);\n\n    event ComptrollerProxyDeployed(\n        address indexed creator,\n        address comptrollerProxy,\n        address indexed denominationAsset,\n        uint256 sharesActionTimelock\n    );\n\n    event GasLimitsForDestructCallSet(\n        uint256 nextDeactivateFeeManagerGasLimit,\n        uint256 nextPayProtocolFeeGasLimit\n    );\n\n    event MigrationRequestCreated(\n        address indexed creator,\n        address indexed vaultProxy,\n        address comptrollerProxy\n    );\n\n    event NewFundCreated(address indexed creator, address vaultProxy, address comptrollerProxy);\n\n    event ProtocolFeeTrackerSet(address protocolFeeTracker);\n\n    event ReconfigurationRequestCancelled(\n        address indexed vaultProxy,\n        address indexed nextComptrollerProxy\n    );\n\n    event ReconfigurationRequestCreated(\n        address indexed creator,\n        address indexed vaultProxy,\n        address comptrollerProxy,\n        uint256 executableTimestamp\n    );\n\n    event ReconfigurationRequestExecuted(\n        address indexed vaultProxy,\n        address indexed prevComptrollerProxy,\n        address indexed nextComptrollerProxy\n    );\n\n    event ReconfigurationTimelockSet(uint256 nextTimelock);\n\n    event ReleaseIsLive();\n\n    event VaultCallDeregistered(\n        address indexed contractAddress,\n        bytes4 selector,\n        bytes32 dataHash\n    );\n\n    event VaultCallRegistered(address indexed contractAddress, bytes4 selector, bytes32 dataHash);\n\n    event VaultLibSet(address vaultLib);\n\n    struct ReconfigurationRequest {\n        address nextComptrollerProxy;\n        uint256 executableTimestamp;\n    }\n\n    // Constants\n    // keccak256(abi.encodePacked(\"mln.vaultCall.any\")\n    bytes32\n        private constant ANY_VAULT_CALL = 0x5bf1898dd28c4d29f33c4c1bb9b8a7e2f6322847d70be63e8f89de024d08a669;\n\n    address private immutable CREATOR;\n    address private immutable DISPATCHER;\n\n    // Pseudo-constants (can only be set once)\n    address private comptrollerLib;\n    address private protocolFeeTracker;\n    address private vaultLib;\n\n    // Storage\n    uint32 private gasLimitForDestructCallToDeactivateFeeManager; // Can reduce to uint16\n    uint32 private gasLimitForDestructCallToPayProtocolFee; // Can reduce to uint16\n    bool private isLive;\n    uint256 private reconfigurationTimelock;\n\n    mapping(address => bool) private acctToIsAllowedBuySharesOnBehalfCaller;\n    mapping(bytes32 => mapping(bytes32 => bool)) private vaultCallToPayloadToIsAllowed;\n    mapping(address => ReconfigurationRequest) private vaultProxyToReconfigurationRequest;\n\n    modifier onlyDispatcher() {\n        require(msg.sender == DISPATCHER, \"Only Dispatcher can call this function\");\n        _;\n    }\n\n    modifier onlyLiveRelease() {\n        require(releaseIsLive(), \"Release is not yet live\");\n        _;\n    }\n\n    modifier onlyMigrator(address _vaultProxy) {\n        __assertIsMigrator(_vaultProxy, __msgSender());\n        _;\n    }\n\n    modifier onlyMigratorNotRelayable(address _vaultProxy) {\n        __assertIsMigrator(_vaultProxy, msg.sender);\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == getOwner(), \"Only the contract owner can call this function\");\n        _;\n    }\n\n    modifier pseudoConstant(address _storageValue) {\n        require(_storageValue == address(0), \"This value can only be set once\");\n        _;\n    }\n\n    function __assertIsMigrator(address _vaultProxy, address _who) private view {\n        require(\n            IVault(_vaultProxy).canMigrate(_who),\n            \"Only a permissioned migrator can call this function\"\n        );\n    }\n\n    constructor(address _dispatcher, address _gasRelayPaymasterFactory)\n        public\n        GasRelayRecipientMixin(_gasRelayPaymasterFactory)\n    {\n        // Validate constants\n        require(\n            ANY_VAULT_CALL == keccak256(abi.encodePacked(\"mln.vaultCall.any\")),\n            \"constructor: Incorrect ANY_VAULT_CALL\"\n        );\n\n        CREATOR = msg.sender;\n        DISPATCHER = _dispatcher;\n\n        // Estimated base call cost: 17k\n        // Per fee that uses shares outstanding (default recipient): 33k\n        // 300k accommodates up to 8 such fees\n        gasLimitForDestructCallToDeactivateFeeManager = 300000;\n        // Estimated cost: 50k\n        gasLimitForDestructCallToPayProtocolFee = 200000;\n\n        reconfigurationTimelock = 2 days;\n    }\n\n    //////////////////////////////////////\n    // PSEUDO-CONSTANTS (only set once) //\n    //////////////////////////////////////\n\n    /// @notice Sets the ComptrollerLib\n    /// @param _comptrollerLib The ComptrollerLib contract address\n    function setComptrollerLib(address _comptrollerLib)\n        external\n        onlyOwner\n        pseudoConstant(getComptrollerLib())\n    {\n        comptrollerLib = _comptrollerLib;\n\n        emit ComptrollerLibSet(_comptrollerLib);\n    }\n\n    /// @notice Sets the ProtocolFeeTracker\n    /// @param _protocolFeeTracker The ProtocolFeeTracker contract address\n    function setProtocolFeeTracker(address _protocolFeeTracker)\n        external\n        onlyOwner\n        pseudoConstant(getProtocolFeeTracker())\n    {\n        protocolFeeTracker = _protocolFeeTracker;\n\n        emit ProtocolFeeTrackerSet(_protocolFeeTracker);\n    }\n\n    /// @notice Sets the VaultLib\n    /// @param _vaultLib The VaultLib contract address\n    function setVaultLib(address _vaultLib) external onlyOwner pseudoConstant(getVaultLib()) {\n        vaultLib = _vaultLib;\n\n        emit VaultLibSet(_vaultLib);\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Gets the current owner of the contract\n    /// @return owner_ The contract owner address\n    /// @dev The owner is initially the contract's creator, for convenience in setting up configuration.\n    /// Ownership is handed-off when the creator calls setReleaseLive().\n    function getOwner() public view override returns (address owner_) {\n        if (!releaseIsLive()) {\n            return getCreator();\n        }\n\n        return IDispatcher(getDispatcher()).getOwner();\n    }\n\n    /// @notice Sets the amounts of gas to forward to each of the ComptrollerLib.destructActivated() external calls\n    /// @param _nextDeactivateFeeManagerGasLimit The amount of gas to forward to deactivate the FeeManager\n    /// @param _nextPayProtocolFeeGasLimit The amount of gas to forward to pay the protocol fee\n    function setGasLimitsForDestructCall(\n        uint32 _nextDeactivateFeeManagerGasLimit,\n        uint32 _nextPayProtocolFeeGasLimit\n    ) external onlyOwner {\n        require(\n            _nextDeactivateFeeManagerGasLimit > 0 && _nextPayProtocolFeeGasLimit > 0,\n            \"setGasLimitsForDestructCall: Zero value not allowed\"\n        );\n\n        gasLimitForDestructCallToDeactivateFeeManager = _nextDeactivateFeeManagerGasLimit;\n        gasLimitForDestructCallToPayProtocolFee = _nextPayProtocolFeeGasLimit;\n\n        emit GasLimitsForDestructCallSet(\n            _nextDeactivateFeeManagerGasLimit,\n            _nextPayProtocolFeeGasLimit\n        );\n    }\n\n    /// @notice Sets the release as live\n    /// @dev A live release allows funds to be created and migrated once this contract\n    /// is set as the Dispatcher.currentFundDeployer\n    function setReleaseLive() external {\n        require(\n            msg.sender == getCreator(),\n            \"setReleaseLive: Only the creator can call this function\"\n        );\n        require(!releaseIsLive(), \"setReleaseLive: Already live\");\n\n        // All pseudo-constants should be set\n        require(getComptrollerLib() != address(0), \"setReleaseLive: comptrollerLib is not set\");\n        require(\n            getProtocolFeeTracker() != address(0),\n            \"setReleaseLive: protocolFeeTracker is not set\"\n        );\n        require(getVaultLib() != address(0), \"setReleaseLive: vaultLib is not set\");\n\n        isLive = true;\n\n        emit ReleaseIsLive();\n    }\n\n    /// @dev Helper to call ComptrollerProxy.destructActivated() with the correct params\n    function __destructActivatedComptrollerProxy(address _comptrollerProxy) private {\n        (\n            uint256 deactivateFeeManagerGasLimit,\n            uint256 payProtocolFeeGasLimit\n        ) = getGasLimitsForDestructCall();\n        IComptroller(_comptrollerProxy).destructActivated(\n            deactivateFeeManagerGasLimit,\n            payProtocolFeeGasLimit\n        );\n    }\n\n    ///////////////////\n    // FUND CREATION //\n    ///////////////////\n\n    /// @notice Creates a fully-configured ComptrollerProxy instance for a VaultProxy and signals the migration process\n    /// @param _vaultProxy The VaultProxy to migrate\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while signaling migration\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\n    function createMigrationRequest(\n        address _vaultProxy,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData,\n        bool _bypassPrevReleaseFailure\n    )\n        external\n        onlyLiveRelease\n        onlyMigratorNotRelayable(_vaultProxy)\n        returns (address comptrollerProxy_)\n    {\n        // Bad _vaultProxy value is validated by Dispatcher.signalMigration()\n\n        require(\n            !IDispatcher(getDispatcher()).hasMigrationRequest(_vaultProxy),\n            \"createMigrationRequest: A MigrationRequest already exists\"\n        );\n\n        comptrollerProxy_ = __deployComptrollerProxy(\n            msg.sender,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n\n        IComptroller(comptrollerProxy_).setVaultProxy(_vaultProxy);\n\n        __configureExtensions(\n            comptrollerProxy_,\n            _vaultProxy,\n            _feeManagerConfigData,\n            _policyManagerConfigData\n        );\n\n        IDispatcher(getDispatcher()).signalMigration(\n            _vaultProxy,\n            comptrollerProxy_,\n            getVaultLib(),\n            _bypassPrevReleaseFailure\n        );\n\n        emit MigrationRequestCreated(msg.sender, _vaultProxy, comptrollerProxy_);\n\n        return comptrollerProxy_;\n    }\n\n    /// @notice Creates a new fund\n    /// @param _fundOwner The address of the owner for the fund\n    /// @param _fundName The name of the fund\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\n    function createNewFund(\n        address _fundOwner,\n        string calldata _fundName,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external override onlyLiveRelease returns (address comptrollerProxy_, address vaultProxy_) {\n        console.log(\"fund Owner:%s\", _fundOwner);\n        console.log(\"fund name:%s\", _fundName);\n        console.log(\"asset:%s\", _denominationAsset);\n\n        // _fundOwner is validated by VaultLib.__setOwner()\n        address canonicalSender = __msgSender();\n\n        comptrollerProxy_ = __deployComptrollerProxy(\n            canonicalSender,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n\n        console.log(\"createNewFund:comptrollerProxy_:%s\", comptrollerProxy_);\n        vaultProxy_ = IDispatcher(getDispatcher()).deployVaultProxy(\n            getVaultLib(),\n            _fundOwner,\n            comptrollerProxy_,\n            _fundName\n        );\n        console.log(\"createNewFund:vaultProxy_:%s\", vaultProxy_);\n\n        IComptroller comptrollerContract = IComptroller(comptrollerProxy_);\n        console.log(\"createNewFund:comptrollerContract:%s\", address(comptrollerContract));\n        comptrollerContract.setVaultProxy(vaultProxy_);\n        console.log(\"createNewFund:setVaultProxy\");\n\n        __configureExtensions(\n            comptrollerProxy_,\n            vaultProxy_,\n            _feeManagerConfigData,\n            _policyManagerConfigData\n        );\n        console.log(\"createNewFund:__configureExtensions\");\n\n        comptrollerContract.activate(false);\n        console.log(\"createNewFund:comptrollerContract.activate\");\n\n        IProtocolFeeTracker(getProtocolFeeTracker()).initializeForVault(vaultProxy_);\n\n        console.log(\"createNewFund:IProtocolFeeTracker\");\n        emit NewFundCreated(canonicalSender, vaultProxy_, comptrollerProxy_);\n        console.log(\"createNewFund:NewFundCreated:comptrollerProxy_:%s\", comptrollerProxy_);\n        console.log(\"createNewFund:NewFundCreated:vaultProxy_:%s\", vaultProxy_);\n        return (comptrollerProxy_, vaultProxy_);\n    }\n\n    /// @notice Creates a fully-configured ComptrollerProxy instance for a VaultProxy and signals the reconfiguration process\n    /// @param _vaultProxy The VaultProxy to reconfigure\n    /// @param _denominationAsset The contract address of the denomination asset for the fund\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \"shares actions\"\n    /// (buying or selling shares) by the same user\n    /// @param _feeManagerConfigData Bytes data for the fees to be enabled for the fund\n    /// @param _policyManagerConfigData Bytes data for the policies to be enabled for the fund\n    /// @return comptrollerProxy_ The address of the ComptrollerProxy deployed during this action\n    function createReconfigurationRequest(\n        address _vaultProxy,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock,\n        bytes calldata _feeManagerConfigData,\n        bytes calldata _policyManagerConfigData\n    ) external returns (address comptrollerProxy_) {\n        address canonicalSender = __msgSender();\n        __assertIsMigrator(_vaultProxy, canonicalSender);\n        require(\n            IDispatcher(getDispatcher()).getFundDeployerForVaultProxy(_vaultProxy) ==\n                address(this),\n            \"createReconfigurationRequest: VaultProxy not on this release\"\n        );\n        require(\n            !hasReconfigurationRequest(_vaultProxy),\n            \"createReconfigurationRequest: VaultProxy has a pending reconfiguration request\"\n        );\n\n        comptrollerProxy_ = __deployComptrollerProxy(\n            canonicalSender,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n\n        IComptroller(comptrollerProxy_).setVaultProxy(_vaultProxy);\n\n        __configureExtensions(\n            comptrollerProxy_,\n            _vaultProxy,\n            _feeManagerConfigData,\n            _policyManagerConfigData\n        );\n\n        uint256 executableTimestamp = block.timestamp + getReconfigurationTimelock();\n        vaultProxyToReconfigurationRequest[_vaultProxy] = ReconfigurationRequest({\n            nextComptrollerProxy: comptrollerProxy_,\n            executableTimestamp: executableTimestamp\n        });\n\n        emit ReconfigurationRequestCreated(\n            canonicalSender,\n            _vaultProxy,\n            comptrollerProxy_,\n            executableTimestamp\n        );\n\n        return comptrollerProxy_;\n    }\n\n    /// @dev Helper function to configure the Extensions for a given ComptrollerProxy\n    function __configureExtensions(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes memory _feeManagerConfigData,\n        bytes memory _policyManagerConfigData\n    ) private {\n        console.log(\n            \"__configureExtensions _feeManagerConfigData.length:%s\",\n            _feeManagerConfigData.length > 0\n        );\n        console.log(\" __configureExtensions: _comptrollerProxy %s\", _comptrollerProxy);\n        console.log(\" __configureExtensions: _vaultProxy %s\", _vaultProxy);\n        // Since fees can only be set in this step, if there are no fees, there is no need to set the validated VaultProxy\n        if (_feeManagerConfigData.length > 0) {\n            address feeManager = IComptroller(_comptrollerProxy).getFeeManager();\n            console.log(\" __configureExtensions: feeManager %s\", feeManager);\n            console.log(\" __configureExtensions: sender %s\", msg.sender);\n            IExtension(feeManager).setConfigForFund(\n                _comptrollerProxy,\n                _vaultProxy,\n                _feeManagerConfigData\n            );\n        }\n        console.log(\"__configureExtensions first step\");\n\n        // For all other extensions, we call to cache the validated VaultProxy, for simplicity.\n        // In the future, we can consider caching conditionally.\n        IExtension(IComptroller(_comptrollerProxy).getExternalPositionManager()).setConfigForFund(\n            _comptrollerProxy,\n            _vaultProxy,\n            \"\"\n        );\n        console.log(\"__configureExtensions getExternalPositionManager\");\n        IExtension(IComptroller(_comptrollerProxy).getIntegrationManager()).setConfigForFund(\n            _comptrollerProxy,\n            _vaultProxy,\n            \"\"\n        );\n        console.log(\"__configureExtensions getIntegrationManager\");\n        IExtension(IComptroller(_comptrollerProxy).getPolicyManager()).setConfigForFund(\n            _comptrollerProxy,\n            _vaultProxy,\n            _policyManagerConfigData\n        );\n        console.log(\"__configureExtensions getPolicyManager\");\n    }\n\n    /// @dev Helper function to deploy a configured ComptrollerProxy\n    function __deployComptrollerProxy(\n        address _canonicalSender,\n        address _denominationAsset,\n        uint256 _sharesActionTimelock\n    ) private returns (address comptrollerProxy_) {\n        // _denominationAsset is validated by ComptrollerLib.init()\n\n        bytes memory constructData = abi.encodeWithSelector(\n            IComptroller.init.selector,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n        comptrollerProxy_ = address(new ComptrollerProxy(constructData, getComptrollerLib()));\n\n        emit ComptrollerProxyDeployed(\n            _canonicalSender,\n            comptrollerProxy_,\n            _denominationAsset,\n            _sharesActionTimelock\n        );\n\n        return comptrollerProxy_;\n    }\n\n    ///////////////////////////////////////////////\n    // RECONFIGURATION (INTRA-RELEASE MIGRATION) //\n    ///////////////////////////////////////////////\n\n    /// @notice Cancels a pending reconfiguration request\n    /// @param _vaultProxy The VaultProxy contract for which to cancel the reconfiguration request\n    function cancelReconfiguration(address _vaultProxy) external onlyMigrator(_vaultProxy) {\n        address nextComptrollerProxy = vaultProxyToReconfigurationRequest[_vaultProxy]\n            .nextComptrollerProxy;\n        require(\n            nextComptrollerProxy != address(0),\n            \"cancelReconfiguration: No reconfiguration request exists for _vaultProxy\"\n        );\n\n        // Destroy the nextComptrollerProxy\n        IComptroller(nextComptrollerProxy).destructUnactivated();\n\n        // Remove the reconfiguration request\n        delete vaultProxyToReconfigurationRequest[_vaultProxy];\n\n        emit ReconfigurationRequestCancelled(_vaultProxy, nextComptrollerProxy);\n    }\n\n    /// @notice Executes a pending reconfiguration request\n    /// @param _vaultProxy The VaultProxy contract for which to execute the reconfiguration request\n    /// @dev ProtocolFeeTracker.initializeForVault() does not need to be included in a reconfiguration,\n    /// as it refers to the vault and not the new ComptrollerProxy\n    function executeReconfiguration(address _vaultProxy) external onlyMigrator(_vaultProxy) {\n        ReconfigurationRequest memory request = getReconfigurationRequestForVaultProxy(\n            _vaultProxy\n        );\n        require(\n            request.nextComptrollerProxy != address(0),\n            \"executeReconfiguration: No reconfiguration request exists for _vaultProxy\"\n        );\n        require(\n            block.timestamp >= request.executableTimestamp,\n            \"executeReconfiguration: The reconfiguration timelock has not elapsed\"\n        );\n        // Not technically necessary, but a nice assurance\n        require(\n            IDispatcher(getDispatcher()).getFundDeployerForVaultProxy(_vaultProxy) ==\n                address(this),\n            \"executeReconfiguration: _vaultProxy is no longer on this release\"\n        );\n\n        // Unwind and destroy the prevComptrollerProxy before setting the nextComptrollerProxy as the VaultProxy.accessor\n        address prevComptrollerProxy = IVault(_vaultProxy).getAccessor();\n        address paymaster = IComptroller(prevComptrollerProxy).getGasRelayPaymaster();\n        __destructActivatedComptrollerProxy(prevComptrollerProxy);\n\n        // Execute the reconfiguration\n        IVault(_vaultProxy).setAccessorForFundReconfiguration(request.nextComptrollerProxy);\n\n        // Activate the new ComptrollerProxy\n        IComptroller(request.nextComptrollerProxy).activate(true);\n        if (paymaster != address(0)) {\n            IComptroller(request.nextComptrollerProxy).setGasRelayPaymaster(paymaster);\n        }\n\n        // Remove the reconfiguration request\n        delete vaultProxyToReconfigurationRequest[_vaultProxy];\n\n        emit ReconfigurationRequestExecuted(\n            _vaultProxy,\n            prevComptrollerProxy,\n            request.nextComptrollerProxy\n        );\n    }\n\n    /// @notice Sets a new reconfiguration timelock\n    /// @param _nextTimelock The number of seconds for the new timelock\n    function setReconfigurationTimelock(uint256 _nextTimelock) external onlyOwner {\n        reconfigurationTimelock = _nextTimelock;\n\n        emit ReconfigurationTimelockSet(_nextTimelock);\n    }\n\n    //////////////////\n    // MIGRATION IN //\n    //////////////////\n\n    /// @notice Cancels fund migration\n    /// @param _vaultProxy The VaultProxy for which to cancel migration\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while canceling migration\n    function cancelMigration(address _vaultProxy, bool _bypassPrevReleaseFailure)\n        external\n        onlyMigratorNotRelayable(_vaultProxy)\n    {\n        IDispatcher(getDispatcher()).cancelMigration(_vaultProxy, _bypassPrevReleaseFailure);\n    }\n\n    /// @notice Executes fund migration\n    /// @param _vaultProxy The VaultProxy for which to execute the migration\n    /// @param _bypassPrevReleaseFailure True if should override a failure in the previous release while executing migration\n    function executeMigration(address _vaultProxy, bool _bypassPrevReleaseFailure)\n        external\n        onlyMigratorNotRelayable(_vaultProxy)\n    {\n        IDispatcher dispatcherContract = IDispatcher(getDispatcher());\n\n        (, address comptrollerProxy, , ) = dispatcherContract\n            .getMigrationRequestDetailsForVaultProxy(_vaultProxy);\n\n        dispatcherContract.executeMigration(_vaultProxy, _bypassPrevReleaseFailure);\n\n        IComptroller(comptrollerProxy).activate(true);\n\n        IProtocolFeeTracker(getProtocolFeeTracker()).initializeForVault(_vaultProxy);\n    }\n\n    /// @notice Executes logic when a migration is canceled on the Dispatcher\n    /// @param _nextComptrollerProxy The ComptrollerProxy created on this release\n    function invokeMigrationInCancelHook(\n        address,\n        address,\n        address _nextComptrollerProxy,\n        address\n    ) external override onlyDispatcher {\n        IComptroller(_nextComptrollerProxy).destructUnactivated();\n    }\n\n    ///////////////////\n    // MIGRATION OUT //\n    ///////////////////\n\n    /// @notice Allows \"hooking into\" specific moments in the migration pipeline\n    /// to execute arbitrary logic during a migration out of this release\n    /// @param _vaultProxy The VaultProxy being migrated\n    function invokeMigrationOutHook(\n        MigrationOutHook _hook,\n        address _vaultProxy,\n        address,\n        address,\n        address\n    ) external override onlyDispatcher {\n        if (_hook != MigrationOutHook.PreMigrate) {\n            return;\n        }\n\n        // Must use PreMigrate hook to get the ComptrollerProxy from the VaultProxy\n        address comptrollerProxy = IVault(_vaultProxy).getAccessor();\n\n        // Wind down fund and destroy its config\n        __destructActivatedComptrollerProxy(comptrollerProxy);\n    }\n\n    //////////////\n    // REGISTRY //\n    //////////////\n\n    // BUY SHARES CALLERS\n\n    /// @notice Deregisters allowed callers of ComptrollerProxy.buySharesOnBehalf()\n    /// @param _callers The callers to deregister\n    function deregisterBuySharesOnBehalfCallers(address[] calldata _callers) external onlyOwner {\n        for (uint256 i; i < _callers.length; i++) {\n            require(\n                isAllowedBuySharesOnBehalfCaller(_callers[i]),\n                \"deregisterBuySharesOnBehalfCallers: Caller not registered\"\n            );\n\n            acctToIsAllowedBuySharesOnBehalfCaller[_callers[i]] = false;\n\n            emit BuySharesOnBehalfCallerDeregistered(_callers[i]);\n        }\n    }\n\n    /// @notice Registers allowed callers of ComptrollerProxy.buySharesOnBehalf()\n    /// @param _callers The allowed callers\n    /// @dev Validate that each registered caller only forwards requests to buy shares that\n    /// originate from the same _buyer passed into buySharesOnBehalf(). This is critical\n    /// to the integrity of VaultProxy.freelyTransferableShares.\n    function registerBuySharesOnBehalfCallers(address[] calldata _callers) external onlyOwner {\n        for (uint256 i; i < _callers.length; i++) {\n            require(\n                !isAllowedBuySharesOnBehalfCaller(_callers[i]),\n                \"registerBuySharesOnBehalfCallers: Caller already registered\"\n            );\n\n            acctToIsAllowedBuySharesOnBehalfCaller[_callers[i]] = true;\n\n            emit BuySharesOnBehalfCallerRegistered(_callers[i]);\n        }\n    }\n\n    // VAULT CALLS\n\n    /// @notice De-registers allowed arbitrary contract calls that can be sent from the VaultProxy\n    /// @param _contracts The contracts of the calls to de-register\n    /// @param _selectors The selectors of the calls to de-register\n    /// @param _dataHashes The keccak call data hashes of the calls to de-register\n    /// @dev ANY_VAULT_CALL is a wildcard that allows any payload\n    function deregisterVaultCalls(\n        address[] calldata _contracts,\n        bytes4[] calldata _selectors,\n        bytes32[] memory _dataHashes\n    ) external onlyOwner {\n        require(_contracts.length > 0, \"deregisterVaultCalls: Empty _contracts\");\n        require(\n            _contracts.length == _selectors.length && _contracts.length == _dataHashes.length,\n            \"deregisterVaultCalls: Uneven input arrays\"\n        );\n\n        for (uint256 i; i < _contracts.length; i++) {\n            require(\n                isRegisteredVaultCall(_contracts[i], _selectors[i], _dataHashes[i]),\n                \"deregisterVaultCalls: Call not registered\"\n            );\n\n            vaultCallToPayloadToIsAllowed[keccak256(\n                abi.encodePacked(_contracts[i], _selectors[i])\n            )][_dataHashes[i]] = false;\n\n            emit VaultCallDeregistered(_contracts[i], _selectors[i], _dataHashes[i]);\n        }\n    }\n\n    /// @notice Registers allowed arbitrary contract calls that can be sent from the VaultProxy\n    /// @param _contracts The contracts of the calls to register\n    /// @param _selectors The selectors of the calls to register\n    /// @param _dataHashes The keccak call data hashes of the calls to register\n    /// @dev ANY_VAULT_CALL is a wildcard that allows any payload\n    function registerVaultCalls(\n        address[] calldata _contracts,\n        bytes4[] calldata _selectors,\n        bytes32[] memory _dataHashes\n    ) external onlyOwner {\n        require(_contracts.length > 0, \"registerVaultCalls: Empty _contracts\");\n        require(\n            _contracts.length == _selectors.length && _contracts.length == _dataHashes.length,\n            \"registerVaultCalls: Uneven input arrays\"\n        );\n\n        for (uint256 i; i < _contracts.length; i++) {\n            require(\n                !isRegisteredVaultCall(_contracts[i], _selectors[i], _dataHashes[i]),\n                \"registerVaultCalls: Call already registered\"\n            );\n\n            vaultCallToPayloadToIsAllowed[keccak256(\n                abi.encodePacked(_contracts[i], _selectors[i])\n            )][_dataHashes[i]] = true;\n\n            emit VaultCallRegistered(_contracts[i], _selectors[i], _dataHashes[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Checks if a contract call is allowed\n    /// @param _contract The contract of the call to check\n    /// @param _selector The selector of the call to check\n    /// @param _dataHash The keccak call data hash of the call to check\n    /// @return isAllowed_ True if the call is allowed\n    /// @dev A vault call is allowed if the _dataHash is specifically allowed,\n    /// or if any _dataHash is allowed\n    function isAllowedVaultCall(\n        address _contract,\n        bytes4 _selector,\n        bytes32 _dataHash\n    ) external view override returns (bool isAllowed_) {\n        bytes32 contractFunctionHash = keccak256(abi.encodePacked(_contract, _selector));\n\n        return\n            vaultCallToPayloadToIsAllowed[contractFunctionHash][_dataHash] ||\n            vaultCallToPayloadToIsAllowed[contractFunctionHash][ANY_VAULT_CALL];\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the `comptrollerLib` variable value\n    /// @return comptrollerLib_ The `comptrollerLib` variable value\n    function getComptrollerLib() public view override returns (address comptrollerLib_) {\n        return comptrollerLib;\n    }\n\n    /// @notice Gets the `CREATOR` variable value\n    /// @return creator_ The `CREATOR` variable value\n    function getCreator() public view returns (address creator_) {\n        return CREATOR;\n    }\n\n    /// @notice Gets the `DISPATCHER` variable value\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the amounts of gas to forward to each of the ComptrollerLib.destructActivated() external calls\n    /// @return deactivateFeeManagerGasLimit_ The amount of gas to forward to deactivate the FeeManager\n    /// @return payProtocolFeeGasLimit_ The amount of gas to forward to pay the protocol fee\n    function getGasLimitsForDestructCall()\n        public\n        view\n        returns (uint256 deactivateFeeManagerGasLimit_, uint256 payProtocolFeeGasLimit_)\n    {\n        return (\n            gasLimitForDestructCallToDeactivateFeeManager,\n            gasLimitForDestructCallToPayProtocolFee\n        );\n    }\n\n    /// @notice Gets the `protocolFeeTracker` variable value\n    /// @return protocolFeeTracker_ The `protocolFeeTracker` variable value\n    function getProtocolFeeTracker() public view returns (address protocolFeeTracker_) {\n        return protocolFeeTracker;\n    }\n\n    /// @notice Gets the pending ReconfigurationRequest for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return reconfigurationRequest_ The pending ReconfigurationRequest\n    function getReconfigurationRequestForVaultProxy(address _vaultProxy)\n        public\n        view\n        returns (ReconfigurationRequest memory reconfigurationRequest_)\n    {\n        return vaultProxyToReconfigurationRequest[_vaultProxy];\n    }\n\n    /// @notice Gets the amount of time that must pass before executing a ReconfigurationRequest\n    /// @return reconfigurationTimelock_ The timelock value (in seconds)\n    function getReconfigurationTimelock() public view returns (uint256 reconfigurationTimelock_) {\n        return reconfigurationTimelock;\n    }\n\n    /// @notice Gets the `vaultLib` variable value\n    /// @return vaultLib_ The `vaultLib` variable value\n    function getVaultLib() public view override returns (address vaultLib_) {\n        return vaultLib;\n    }\n\n    /// @notice Checks whether a ReconfigurationRequest exists for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return hasReconfigurationRequest_ True if a ReconfigurationRequest exists\n    function hasReconfigurationRequest(address _vaultProxy)\n        public\n        view\n        override\n        returns (bool hasReconfigurationRequest_)\n    {\n        return vaultProxyToReconfigurationRequest[_vaultProxy].nextComptrollerProxy != address(0);\n    }\n\n    /// @notice Checks if an account is an allowed caller of ComptrollerProxy.buySharesOnBehalf()\n    /// @param _who The account to check\n    /// @return isAllowed_ True if the account is an allowed caller\n    function isAllowedBuySharesOnBehalfCaller(address _who)\n        public\n        view\n        override\n        returns (bool isAllowed_)\n    {\n        return acctToIsAllowedBuySharesOnBehalfCaller[_who];\n    }\n\n    /// @notice Checks if a contract call is registered\n    /// @param _contract The contract of the call to check\n    /// @param _selector The selector of the call to check\n    /// @param _dataHash The keccak call data hash of the call to check\n    /// @return isRegistered_ True if the call is registered\n    function isRegisteredVaultCall(\n        address _contract,\n        bytes4 _selector,\n        bytes32 _dataHash\n    ) public view returns (bool isRegistered_) {\n        return\n            vaultCallToPayloadToIsAllowed[keccak256(\n                abi.encodePacked(_contract, _selector)\n            )][_dataHash];\n    }\n\n    /// @notice Gets the `isLive` variable value\n    /// @return isLive_ The `isLive` variable value\n    function releaseIsLive() public view returns (bool isLive_) {\n        return isLive;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/PolicyManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../core/fund/comptroller/IComptroller.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\";\nimport \"../../utils/AddressArrayLib.sol\";\nimport \"../utils/ExtensionBase.sol\";\nimport \"./IPolicy.sol\";\nimport \"./IPolicyManager.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title PolicyManager Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Manages policies for funds\n/// @dev Any arbitrary fee is allowed by default, so all participants must be aware of\n/// their fund's configuration, especially whether they use official policies only.\n/// Policies that restrict current investors can only be added upon fund setup, migration, or reconfiguration.\n/// Policies that restrict new investors or asset management actions can be added at any time.\n/// Policies themselves specify whether or not they are allowed to be updated or removed.\ncontract PolicyManager is IPolicyManager, ExtensionBase, GasRelayRecipientMixin {\n    using AddressArrayLib for address[];\n\n    event PolicyDisabledOnHookForFund(\n        address indexed comptrollerProxy,\n        address indexed policy,\n        PolicyHook indexed hook\n    );\n\n    event PolicyEnabledForFund(\n        address indexed comptrollerProxy,\n        address indexed policy,\n        bytes settingsData\n    );\n\n    uint256 private constant POLICY_HOOK_COUNT = 10;\n\n    mapping(address => mapping(PolicyHook => address[])) private comptrollerProxyToHookToPolicies;\n\n    modifier onlyFundOwner(address _comptrollerProxy) {\n        require(\n            __msgSender() == IVault(getVaultProxyForFund(_comptrollerProxy)).getOwner(),\n            \"Only the fund owner can call this function\"\n        );\n        _;\n    }\n\n    constructor(address _fundDeployer, address _gasRelayPaymasterFactory)\n        public\n        ExtensionBase(_fundDeployer)\n        GasRelayRecipientMixin(_gasRelayPaymasterFactory)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Validates and initializes policies as necessary prior to fund activation\n    /// @param _isMigratedFund True if the fund is migrating to this release\n    /// @dev There will be no enabledPolicies if the caller is not a valid ComptrollerProxy\n    function activateForFund(bool _isMigratedFund) external override {\n        address comptrollerProxy = msg.sender;\n\n        // Policies must assert that they are congruent with migrated vault state\n        if (_isMigratedFund) {\n            address[] memory enabledPolicies = getEnabledPoliciesForFund(comptrollerProxy);\n            for (uint256 i; i < enabledPolicies.length; i++) {\n                __activatePolicyForFund(comptrollerProxy, enabledPolicies[i]);\n            }\n        }\n    }\n\n    /// @notice Disables a policy for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _policy The policy address to disable\n    /// @dev If an arbitrary policy changes its `implementedHooks()` return values after it is\n    /// already enabled on a fund, then this will not correctly disable the policy from any\n    /// removed hook values.\n    function disablePolicyForFund(address _comptrollerProxy, address _policy)\n        external\n        onlyFundOwner(_comptrollerProxy)\n    {\n        require(IPolicy(_policy).canDisable(), \"disablePolicyForFund: _policy cannot be disabled\");\n\n        PolicyHook[] memory implementedHooks = IPolicy(_policy).implementedHooks();\n        for (uint256 i; i < implementedHooks.length; i++) {\n\n                bool disabled\n             = comptrollerProxyToHookToPolicies[_comptrollerProxy][implementedHooks[i]]\n                .removeStorageItem(_policy);\n            if (disabled) {\n                emit PolicyDisabledOnHookForFund(_comptrollerProxy, _policy, implementedHooks[i]);\n            }\n        }\n    }\n\n    /// @notice Enables a policy for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _policy The policy address to enable\n    /// @param _settingsData The encoded settings data with which to configure the policy\n    /// @dev Disabling a policy does not delete fund config on the policy, so if a policy is\n    /// disabled and then enabled again, its initial state will be the previous config. It is the\n    /// policy's job to determine how to merge that config with the _settingsData param in this function.\n    function enablePolicyForFund(\n        address _comptrollerProxy,\n        address _policy,\n        bytes calldata _settingsData\n    ) external onlyFundOwner(_comptrollerProxy) {\n        PolicyHook[] memory implementedHooks = IPolicy(_policy).implementedHooks();\n        for (uint256 i; i < implementedHooks.length; i++) {\n            require(\n                !__policyHookRestrictsCurrentInvestorActions(implementedHooks[i]),\n                \"enablePolicyForFund: _policy restricts actions of current investors\"\n            );\n        }\n\n        __enablePolicyForFund(_comptrollerProxy, _policy, _settingsData, implementedHooks);\n\n        __activatePolicyForFund(_comptrollerProxy, _policy);\n    }\n\n    /// @notice Enable policies for use in a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _configData Encoded config data\n    function setConfigForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes calldata _configData\n    ) external override onlyFundDeployer {\n        console.log(\"policyManager setConfigForFund\");\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\n        console.log(\"policyManager setConfigForFund __setValidatedVaultProxy\");\n        console.logBytes(_configData);\n        // In case the  re are no policies yet\n        if (_configData.length == 0 || _configData.length == 1) {\n            return;\n        }\n        console.log(\"policyManager setConfigForFund <> 0\");\n\n        (address[] memory policies, bytes[] memory settingsData) = abi.decode(\n            _configData,\n            (address[], bytes[])\n        );\n        console.log(\"policyManager setConfigForFund abi decode\");\n\n        // Sanity check\n        require(\n            policies.length == settingsData.length,\n            \"setConfigForFund: policies and settingsData array lengths unequal\"\n        );\n\n        // Enable each policy with settings\n        for (uint256 i; i < policies.length; i++) {\n            __enablePolicyForFund(\n                _comptrollerProxy,\n                policies[i],\n                settingsData[i],\n                IPolicy(policies[i]).implementedHooks()\n            );\n        }\n    }\n\n    /// @notice Updates policy settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _policy The Policy contract to update\n    /// @param _settingsData The encoded settings data with which to update the policy config\n    function updatePolicySettingsForFund(\n        address _comptrollerProxy,\n        address _policy,\n        bytes calldata _settingsData\n    ) external onlyFundOwner(_comptrollerProxy) {\n        IPolicy(_policy).updateFundSettings(_comptrollerProxy, _settingsData);\n    }\n\n    /// @notice Validates all policies that apply to a given hook for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _hook The PolicyHook for which to validate policies\n    /// @param _validationData The encoded data with which to validate the filtered policies\n    function validatePolicies(\n        address _comptrollerProxy,\n        PolicyHook _hook,\n        bytes calldata _validationData\n    ) external override {\n        // Return as quickly as possible if no policies to run\n        address[] memory policies = getEnabledPoliciesOnHookForFund(_comptrollerProxy, _hook);\n        if (policies.length == 0) {\n            return;\n        }\n\n        // Limit calls to trusted components, in case policies update local storage upon runs\n        require(\n            msg.sender == _comptrollerProxy ||\n                msg.sender == IComptroller(_comptrollerProxy).getIntegrationManager() ||\n                msg.sender == IComptroller(_comptrollerProxy).getExternalPositionManager(),\n            \"validatePolicies: Caller not allowed\"\n        );\n\n        for (uint256 i; i < policies.length; i++) {\n            require(\n                IPolicy(policies[i]).validateRule(_comptrollerProxy, _hook, _validationData),\n                string(\n                    abi.encodePacked(\n                        \"Rule evaluated to false: \",\n                        IPolicy(policies[i]).identifier()\n                    )\n                )\n            );\n        }\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to activate a policy for a fund\n    function __activatePolicyForFund(address _comptrollerProxy, address _policy) private {\n        IPolicy(_policy).activateForFund(_comptrollerProxy);\n    }\n\n    /// @dev Helper to set config and enable policies for a fund\n    function __enablePolicyForFund(\n        address _comptrollerProxy,\n        address _policy,\n        bytes memory _settingsData,\n        PolicyHook[] memory _hooks\n    ) private {\n        // Set fund config on policy\n        if (_settingsData.length > 0) {\n            IPolicy(_policy).addFundSettings(_comptrollerProxy, _settingsData);\n        }\n\n        // Add policy\n        for (uint256 i; i < _hooks.length; i++) {\n            require(\n                !policyIsEnabledOnHookForFund(_comptrollerProxy, _hooks[i], _policy),\n                \"__enablePolicyForFund: Policy is already enabled\"\n            );\n            comptrollerProxyToHookToPolicies[_comptrollerProxy][_hooks[i]].push(_policy);\n        }\n\n        emit PolicyEnabledForFund(_comptrollerProxy, _policy, _settingsData);\n    }\n\n    /// @dev Helper to get all the hooks available to policies\n    function __getAllPolicyHooks()\n        private\n        pure\n        returns (PolicyHook[POLICY_HOOK_COUNT] memory hooks_)\n    {\n        return [\n            PolicyHook.PostBuyShares,\n            PolicyHook.PostCallOnIntegration,\n            PolicyHook.PreTransferShares,\n            PolicyHook.RedeemSharesForSpecificAssets,\n            PolicyHook.AddTrackedAssets,\n            PolicyHook.RemoveTrackedAssets,\n            PolicyHook.CreateExternalPosition,\n            PolicyHook.PostCallOnExternalPosition,\n            PolicyHook.RemoveExternalPosition,\n            PolicyHook.ReactivateExternalPosition\n        ];\n    }\n\n    /// @dev Helper to check if a policy hook restricts the actions of current investors.\n    /// These hooks should not allow policy additions post-deployment or post-migration.\n    function __policyHookRestrictsCurrentInvestorActions(PolicyHook _hook)\n        private\n        pure\n        returns (bool restrictsActions_)\n    {\n        return\n            _hook == PolicyHook.PreTransferShares ||\n            _hook == PolicyHook.RedeemSharesForSpecificAssets;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Get a list of enabled policies for the given fund\n    /// @param _comptrollerProxy The ComptrollerProxy\n    /// @return enabledPolicies_ The array of enabled policy addresses\n    function getEnabledPoliciesForFund(address _comptrollerProxy)\n        public\n        view\n        returns (address[] memory enabledPolicies_)\n    {\n        PolicyHook[POLICY_HOOK_COUNT] memory hooks = __getAllPolicyHooks();\n\n        for (uint256 i; i < hooks.length; i++) {\n            enabledPolicies_ = enabledPolicies_.mergeArray(\n                getEnabledPoliciesOnHookForFund(_comptrollerProxy, hooks[i])\n            );\n        }\n\n        return enabledPolicies_;\n    }\n\n    /// @notice Get a list of enabled policies that run on a given hook for the given fund\n    /// @param _comptrollerProxy The ComptrollerProxy\n    /// @param _hook The PolicyHook\n    /// @return enabledPolicies_ The array of enabled policy addresses\n    function getEnabledPoliciesOnHookForFund(address _comptrollerProxy, PolicyHook _hook)\n        public\n        view\n        returns (address[] memory enabledPolicies_)\n    {\n        return comptrollerProxyToHookToPolicies[_comptrollerProxy][_hook];\n    }\n\n    /// @notice Check whether a given policy runs on a given hook for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy\n    /// @param _hook The PolicyHook\n    /// @param _policy The policy\n    /// @return isEnabled_ True if the policy is enabled\n    function policyIsEnabledOnHookForFund(\n        address _comptrollerProxy,\n        PolicyHook _hook,\n        address _policy\n    ) public view returns (bool isEnabled_) {\n        return getEnabledPoliciesOnHookForFund(_comptrollerProxy, _hook).contains(_policy);\n    }\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/bases/GasRelayPaymasterLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title GasRelayPaymasterLibBase1 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A persistent contract containing all required storage variables and events\n/// for a GasRelayPaymasterLib\n/// @dev DO NOT EDIT CONTRACT ONCE DEPLOYED. If new events or storage are necessary,\n/// they should be added to a numbered GasRelayPaymasterLibBaseXXX that inherits the previous base.\n/// e.g., `GasRelayPaymasterLibBase2 is GasRelayPaymasterLibBase1`\nabstract contract GasRelayPaymasterLibBase1 {\n    event Deposited(uint256 amount);\n\n    event TransactionRelayed(address indexed authorizer, bytes4 invokedSelector, bool successful);\n\n    event Withdrawn(uint256 amount);\n\n    // Pseudo-constants\n    address internal parentVault;\n}\n"
    },
    "contracts/persistent/dispatcher/IMigrationHookHandler.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IMigrationHookHandler Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IMigrationHookHandler {\n    enum MigrationOutHook {PreSignal, PostSignal, PreMigrate, PostMigrate, PostCancel}\n\n    function invokeMigrationInCancelHook(\n        address _vaultProxy,\n        address _prevFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib\n    ) external;\n\n    function invokeMigrationOutHook(\n        MigrationOutHook _hook,\n        address _vaultProxy,\n        address _nextFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib\n    ) external;\n}\n"
    },
    "contracts/release/core/fund/comptroller/ComptrollerProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../utils/NonUpgradableProxy.sol\";\n\n/// @title ComptrollerProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for all ComptrollerProxy instances\ncontract ComptrollerProxy is NonUpgradableProxy {\n    constructor(bytes memory _constructData, address _comptrollerLib)\n        public\n        NonUpgradableProxy(_constructData, _comptrollerLib)\n    {}\n}\n"
    },
    "contracts/release/utils/NonUpgradableProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title NonUpgradableProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for use with non-upgradable libs\n/// @dev The recommended constructor-fallback pattern of a proxy in EIP-1822, updated for solc 0.6.12,\n/// and using an immutable lib value to save on gas (since not upgradable).\n/// The EIP-1967 storage slot for the lib is still assigned,\n/// for ease of referring to UIs that understand the pattern, i.e., Etherscan.\nabstract contract NonUpgradableProxy {\n    address private immutable CONTRACT_LOGIC;\n\n    constructor(bytes memory _constructData, address _contractLogic) public {\n        CONTRACT_LOGIC = _contractLogic;\n\n        assembly {\n            // EIP-1967 slot: `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\n            sstore(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\n                _contractLogic\n            )\n        }\n        (bool success, bytes memory returnData) = _contractLogic.delegatecall(_constructData);\n        require(success, string(returnData));\n    }\n\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        address contractLogic = CONTRACT_LOGIC;\n\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/IntegrationManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../core/fund/vault/IVault.sol\";\nimport \"../../infrastructure/value-interpreter/IValueInterpreter.sol\";\nimport \"../../utils/AddressArrayLib.sol\";\nimport \"../../utils/AssetHelpers.sol\";\nimport \"../policy-manager/IPolicyManager.sol\";\nimport \"../utils/ExtensionBase.sol\";\nimport \"../utils/PermissionedVaultActionMixin.sol\";\nimport \"./integrations/IIntegrationAdapter.sol\";\nimport \"./IIntegrationManager.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title IntegrationManager\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Extension to handle DeFi integration actions for funds\n/// @dev Any arbitrary adapter is allowed by default, so all participants must be aware of\n/// their fund's configuration, especially whether they use a policy that only allows\n/// official adapters. Owners and asset managers must also establish trust for any\n/// arbitrary adapters that they interact with.\ncontract IntegrationManager is\n    IIntegrationManager,\n    ExtensionBase,\n    PermissionedVaultActionMixin,\n    AssetHelpers\n{\n    using AddressArrayLib for address[];\n    using SafeMath for uint256;\n\n    event CallOnIntegrationExecutedForFund(\n        address indexed comptrollerProxy,\n        address caller,\n        address indexed adapter,\n        bytes4 indexed selector,\n        bytes integrationData,\n        address[] incomingAssets,\n        uint256[] incomingAssetAmounts,\n        address[] spendAssets,\n        uint256[] spendAssetAmounts\n    );\n\n    address private immutable POLICY_MANAGER;\n    address private immutable VALUE_INTERPRETER;\n\n    constructor(\n        address _fundDeployer,\n        address _policyManager,\n        address _valueInterpreter\n    ) public ExtensionBase(_fundDeployer) {\n        POLICY_MANAGER = _policyManager;\n        VALUE_INTERPRETER = _valueInterpreter;\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Enables the IntegrationManager to be used by a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    function setConfigForFund(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes calldata\n    ) external override onlyFundDeployer {\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\n    }\n\n    ///////////////////////////////\n    // CALL-ON-EXTENSION ACTIONS //\n    ///////////////////////////////\n\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\n    /// @param _caller The user who called for this action\n    /// @param _actionId An ID representing the desired action\n    /// @param _callArgs The encoded args for the action\n    function receiveCallFromComptroller(\n        address _caller,\n        uint256 _actionId,\n        bytes calldata _callArgs\n    ) external override {\n        address comptrollerProxy = msg.sender;\n\n        // This validation comes at negligible cost but is not strictly necessary,\n        // as all actions below call permissioned actions on the VaultProxy,\n        // which will fail for an invalid ComptrollerProxy\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\n        require(vaultProxy != address(0), \"receiveCallFromComptroller: Fund is not valid\");\n\n        require(\n            IVault(vaultProxy).canManageAssets(_caller),\n            \"receiveCallFromComptroller: Unauthorized\"\n        );\n\n        // Dispatch the action\n        if (_actionId == 0) {\n            __callOnIntegration(_caller, comptrollerProxy, vaultProxy, _callArgs);\n        } else if (_actionId == 1) {\n            __addTrackedAssetsToVault(_caller, comptrollerProxy, _callArgs);\n        } else if (_actionId == 2) {\n            __removeTrackedAssetsFromVault(_caller, comptrollerProxy, _callArgs);\n        } else {\n            revert(\"receiveCallFromComptroller: Invalid _actionId\");\n        }\n    }\n\n    /// @dev Adds assets as tracked assets of the vault.\n    /// Does not validate that assets are not already tracked.\n    function __addTrackedAssetsToVault(\n        address _caller,\n        address _comptrollerProxy,\n        bytes memory _callArgs\n    ) private {\n        address[] memory assets = abi.decode(_callArgs, (address[]));\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.AddTrackedAssets,\n            abi.encode(_caller, assets)\n        );\n\n        for (uint256 i; i < assets.length; i++) {\n            require(\n                IValueInterpreter(getValueInterpreter()).isSupportedAsset(assets[i]),\n                \"__addTrackedAssetsToVault: Unsupported asset\"\n            );\n\n            __addTrackedAsset(_comptrollerProxy, assets[i]);\n        }\n    }\n\n    /// @dev Removes assets from the tracked assets of the vault.\n    /// Does not validate that assets are not already tracked.\n    function __removeTrackedAssetsFromVault(\n        address _caller,\n        address _comptrollerProxy,\n        bytes memory _callArgs\n    ) private {\n        address[] memory assets = abi.decode(_callArgs, (address[]));\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.RemoveTrackedAssets,\n            abi.encode(_caller, assets)\n        );\n\n        for (uint256 i; i < assets.length; i++) {\n            __removeTrackedAsset(_comptrollerProxy, assets[i]);\n        }\n    }\n\n    /////////////////////////\n    // CALL ON INTEGRATION //\n    /////////////////////////\n\n    /// @notice Universal method for calling third party contract functions through adapters\n    /// @param _caller The caller of this function via the ComptrollerProxy\n    /// @param _comptrollerProxy The ComptrollerProxy\n    /// @param _vaultProxy The VaultProxy\n    /// @param _callArgs The encoded args for this function\n    /// - _adapter Adapter of the integration on which to execute a call\n    /// - _selector Method selector of the adapter method to execute\n    /// - _integrationData Encoded arguments specific to the adapter\n    /// @dev Refer to specific adapter to see how to encode its arguments.\n    function __callOnIntegration(\n        address _caller,\n        address _comptrollerProxy,\n        address _vaultProxy,\n        bytes memory _callArgs\n    ) private {\n        // Validating the ComptrollerProxy is the active VaultProxy.accessor()\n        // protects against corner cases of lingering permissions on adapters issued\n        // via VaultLib.callOnContract() that could otherwise be called from an\n        // undestructed ComptrollerProxy\n        require(\n            _comptrollerProxy == IVault(_vaultProxy).getAccessor(),\n            \"receiveCallFromComptroller: Fund is not active\"\n        );\n\n        (\n            address adapter,\n            bytes4 selector,\n            bytes memory integrationData\n        ) = __decodeCallOnIntegrationArgs(_callArgs);\n\n        (\n            address[] memory incomingAssets,\n            uint256[] memory incomingAssetAmounts,\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts\n        ) = __callOnIntegrationInner(\n            _comptrollerProxy,\n            _vaultProxy,\n            adapter,\n            selector,\n            integrationData\n        );\n\n        IPolicyManager(getPolicyManager()).validatePolicies(\n            _comptrollerProxy,\n            IPolicyManager.PolicyHook.PostCallOnIntegration,\n            abi.encode(\n                _caller,\n                adapter,\n                selector,\n                incomingAssets,\n                incomingAssetAmounts,\n                spendAssets,\n                spendAssetAmounts\n            )\n        );\n\n        emit CallOnIntegrationExecutedForFund(\n            _comptrollerProxy,\n            _caller,\n            adapter,\n            selector,\n            integrationData,\n            incomingAssets,\n            incomingAssetAmounts,\n            spendAssets,\n            spendAssetAmounts\n        );\n    }\n\n    /// @dev Helper to execute the bulk of logic of callOnIntegration.\n    /// Avoids the stack-too-deep-error.\n    function __callOnIntegrationInner(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _adapter,\n        bytes4 _selector,\n        bytes memory _integrationData\n    )\n        private\n        returns (\n            address[] memory incomingAssets_,\n            uint256[] memory incomingAssetAmounts_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_\n        )\n    {\n        uint256[] memory preCallIncomingAssetBalances;\n        uint256[] memory minIncomingAssetAmounts;\n        SpendAssetsHandleType spendAssetsHandleType;\n        uint256[] memory maxSpendAssetAmounts;\n        uint256[] memory preCallSpendAssetBalances;\n\n        (\n            incomingAssets_,\n            preCallIncomingAssetBalances,\n            minIncomingAssetAmounts,\n            spendAssetsHandleType,\n            spendAssets_,\n            maxSpendAssetAmounts,\n            preCallSpendAssetBalances\n        ) = __preProcessCoI(_comptrollerProxy, _vaultProxy, _adapter, _selector, _integrationData);\n        console.log(\"after __preProcessCoI call\");\n\n        __executeCoI(\n            _vaultProxy,\n            _adapter,\n            _selector,\n            _integrationData,\n            abi.encode(spendAssets_, maxSpendAssetAmounts, incomingAssets_)\n        );\n        console.log(\"after __executeCoI call\");\n\n        (incomingAssetAmounts_, spendAssetAmounts_) = __postProcessCoI(\n            _comptrollerProxy,\n            _vaultProxy,\n            _adapter,\n            incomingAssets_,\n            preCallIncomingAssetBalances,\n            minIncomingAssetAmounts,\n            spendAssetsHandleType,\n            spendAssets_,\n            maxSpendAssetAmounts,\n            preCallSpendAssetBalances\n        );\n        console.log(\"after __postProcessCoI call\");\n\n        return (incomingAssets_, incomingAssetAmounts_, spendAssets_, spendAssetAmounts_);\n    }\n\n    /// @dev Helper to decode CoI args\n    function __decodeCallOnIntegrationArgs(bytes memory _callArgs)\n        private\n        pure\n        returns (\n            address adapter_,\n            bytes4 selector_,\n            bytes memory integrationData_\n        )\n    {\n        return abi.decode(_callArgs, (address, bytes4, bytes));\n    }\n\n    /// @dev Helper to execute a call to an integration\n    /// @dev Avoids stack-too-deep error\n    function __executeCoI(\n        address _vaultProxy,\n        address _adapter,\n        bytes4 _selector,\n        bytes memory _integrationData,\n        bytes memory _assetData\n    ) private {\n        console.log(\"__executeCoI:_adapter:%s\", _adapter);\n\n        (bool success, bytes memory returnData) = _adapter.call(\n            abi.encodeWithSelector(_selector, _vaultProxy, _integrationData, _assetData)\n        );\n        require(success, string(returnData));\n    }\n\n    /// @dev Helper to get the vault's balance of a particular asset\n    function __getVaultAssetBalance(address _vaultProxy, address _asset)\n        private\n        view\n        returns (uint256)\n    {\n        return ERC20(_asset).balanceOf(_vaultProxy);\n    }\n\n    /// @dev Helper for the internal actions to take prior to executing CoI\n    function __preProcessCoI(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _adapter,\n        bytes4 _selector,\n        bytes memory _integrationData\n    )\n        private\n        returns (\n            address[] memory incomingAssets_,\n            uint256[] memory preCallIncomingAssetBalances_,\n            uint256[] memory minIncomingAssetAmounts_,\n            SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory maxSpendAssetAmounts_,\n            uint256[] memory preCallSpendAssetBalances_\n        )\n    {\n        // Note that incoming and spend assets are allowed to overlap\n        // (e.g., a fee for the incomingAsset charged in a spend asset)\n        (\n            spendAssetsHandleType_,\n            spendAssets_,\n            maxSpendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        ) = IIntegrationAdapter(_adapter).parseAssetsForAction(\n            _vaultProxy,\n            _selector,\n            _integrationData\n        );\n        require(\n            spendAssets_.length == maxSpendAssetAmounts_.length,\n            \"__preProcessCoI: Spend assets arrays unequal\"\n        );\n        require(\n            incomingAssets_.length == minIncomingAssetAmounts_.length,\n            \"__preProcessCoI: Incoming assets arrays unequal\"\n        );\n        require(spendAssets_.isUniqueSet(), \"__preProcessCoI: Duplicate spend asset\");\n        require(incomingAssets_.isUniqueSet(), \"__preProcessCoI: Duplicate incoming asset\");\n\n        // INCOMING ASSETS\n\n        // Incoming asset balances must be recorded prior to spend asset balances in case there\n        // is an overlap (an asset that is both a spend asset and an incoming asset),\n        // as a spend asset can be immediately transferred after recording its balance\n        preCallIncomingAssetBalances_ = new uint256[](incomingAssets_.length);\n        for (uint256 i; i < incomingAssets_.length; i++) {\n            require(\n                IValueInterpreter(getValueInterpreter()).isSupportedAsset(incomingAssets_[i]),\n                \"__preProcessCoI: Non-receivable incoming asset\"\n            );\n            console.log(\"__preProcessCoI:balance of %s\", incomingAssets_[i]);\n            console.log(\"__preProcessCoI:balance to _vaultProxy %s\", _vaultProxy);\n            preCallIncomingAssetBalances_[i] = ERC20(incomingAssets_[i]).balanceOf(_vaultProxy);\n            console.log(\n                \"__preProcessCoI:balance preCallIncomingAssetBalances_[i]  %d\",\n                preCallIncomingAssetBalances_[i]\n            );\n        }\n\n        // SPEND ASSETS\n\n        preCallSpendAssetBalances_ = new uint256[](spendAssets_.length);\n        for (uint256 i; i < spendAssets_.length; i++) {\n            preCallSpendAssetBalances_[i] = ERC20(spendAssets_[i]).balanceOf(_vaultProxy);\n            console.log(\"__preProcessCoI:spendAssets_[i]:%s\", spendAssets_[i]);\n            console.log(\"__preProcessCoI:_vaultProxy[i]:%s\", _vaultProxy);\n            console.log(\n                \"__preProcessCoI:preCallSpendAssetBalances_[i] %d\",\n                preCallSpendAssetBalances_[i]\n            );\n            // Grant adapter access to the spend assets.\n            // spendAssets_ is already asserted to be a unique set.\n            if (spendAssetsHandleType_ == SpendAssetsHandleType.Approve) {\n                // Use exact approve amount, and reset afterwards\n                __approveAssetSpender(\n                    _comptrollerProxy,\n                    spendAssets_[i],\n                    _adapter,\n                    maxSpendAssetAmounts_[i]\n                );\n            } else if (spendAssetsHandleType_ == SpendAssetsHandleType.Transfer) {\n                console.log(\n                    \"__preProcessCoI:__withdrawAssetTo from _comptrollerProxy %s\",\n                    _comptrollerProxy\n                );\n                __withdrawAssetTo(\n                    _comptrollerProxy,\n                    spendAssets_[i],\n                    _adapter,\n                    maxSpendAssetAmounts_[i]\n                );\n                console.log(\"__preProcessCoI: after __withdrawAssetTo\");\n            }\n        }\n    }\n\n    /// @dev Helper to reconcile incoming and spend assets after executing CoI\n    function __postProcessCoI(\n        address _comptrollerProxy,\n        address _vaultProxy,\n        address _adapter,\n        address[] memory _incomingAssets,\n        uint256[] memory _preCallIncomingAssetBalances,\n        uint256[] memory _minIncomingAssetAmounts,\n        SpendAssetsHandleType _spendAssetsHandleType,\n        address[] memory _spendAssets,\n        uint256[] memory _maxSpendAssetAmounts,\n        uint256[] memory _preCallSpendAssetBalances\n    )\n        private\n        returns (uint256[] memory incomingAssetAmounts_, uint256[] memory spendAssetAmounts_)\n    {\n        // INCOMING ASSETS\n\n        incomingAssetAmounts_ = new uint256[](_incomingAssets.length);\n        for (uint256 i; i < _incomingAssets.length; i++) {\n            incomingAssetAmounts_[i] = __getVaultAssetBalance(_vaultProxy, _incomingAssets[i]).sub(\n                _preCallIncomingAssetBalances[i]\n            );\n            require(\n                incomingAssetAmounts_[i] >= _minIncomingAssetAmounts[i],\n                \"__postProcessCoI: Received incoming asset less than expected\"\n            );\n\n            // Even if the asset's previous balance was >0, it might not have been tracked\n            __addTrackedAsset(_comptrollerProxy, _incomingAssets[i]);\n        }\n\n        // SPEND ASSETS\n\n        spendAssetAmounts_ = new uint256[](_spendAssets.length);\n        for (uint256 i; i < _spendAssets.length; i++) {\n            // Calculate the balance change of spend assets. Ignore if balance increased.\n            uint256 postCallSpendAssetBalance = __getVaultAssetBalance(\n                _vaultProxy,\n                _spendAssets[i]\n            );\n            if (postCallSpendAssetBalance < _preCallSpendAssetBalances[i]) {\n                spendAssetAmounts_[i] = _preCallSpendAssetBalances[i].sub(\n                    postCallSpendAssetBalance\n                );\n            }\n\n            // Reset any unused approvals\n            if (\n                _spendAssetsHandleType == SpendAssetsHandleType.Approve &&\n                ERC20(_spendAssets[i]).allowance(_vaultProxy, _adapter) > 0\n            ) {\n                __approveAssetSpender(_comptrollerProxy, _spendAssets[i], _adapter, 0);\n            } else if (_spendAssetsHandleType == SpendAssetsHandleType.None) {\n                // Only need to validate _maxSpendAssetAmounts if not SpendAssetsHandleType.Approve\n                // or SpendAssetsHandleType.Transfer, as each of those implicitly validate the max\n                require(\n                    spendAssetAmounts_[i] <= _maxSpendAssetAmounts[i],\n                    \"__postProcessCoI: Spent amount greater than expected\"\n                );\n            }\n        }\n\n        return (incomingAssetAmounts_, spendAssetAmounts_);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `POLICY_MANAGER` variable\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\n    function getPolicyManager() public view returns (address policyManager_) {\n        return POLICY_MANAGER;\n    }\n\n    /// @notice Gets the `VALUE_INTERPRETER` variable\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\n        return VALUE_INTERPRETER;\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/CurvePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../../interfaces/ICurveAddressProvider.sol\";\nimport \"../../../../interfaces/ICurveLiquidityGaugeToken.sol\";\nimport \"../../../../interfaces/ICurveLiquidityPool.sol\";\nimport \"../../../../interfaces/ICurveRegistry.sol\";\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../IDerivativePriceFeed.sol\";\n\n/// @title CurvePriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price feed for Curve pool tokens\ncontract CurvePriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event DerivativeAdded(\n        address indexed derivative,\n        address indexed pool,\n        address indexed invariantProxyAsset,\n        uint256 invariantProxyAssetDecimals\n    );\n\n    event DerivativeRemoved(address indexed derivative);\n\n    // Both pool tokens and liquidity gauge tokens are treated the same for pricing purposes.\n    // We take one asset as representative of the pool's invariant, e.g., WETH for ETH-based pools.\n    struct DerivativeInfo {\n        address pool;\n        address invariantProxyAsset;\n        uint256 invariantProxyAssetDecimals;\n    }\n\n    uint256 private constant VIRTUAL_PRICE_UNIT = 10**18;\n\n    address private immutable ADDRESS_PROVIDER;\n\n    mapping(address => DerivativeInfo) private derivativeToInfo;\n\n    constructor(address _fundDeployer, address _addressProvider)\n        public\n        FundDeployerOwnerMixin(_fundDeployer)\n    {\n        ADDRESS_PROVIDER = _addressProvider;\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        public\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        DerivativeInfo memory derivativeInfo = derivativeToInfo[_derivative];\n        require(\n            derivativeInfo.pool != address(0),\n            \"calcUnderlyingValues: _derivative is not supported\"\n        );\n\n        underlyings_ = new address[](1);\n        underlyings_[0] = derivativeInfo.invariantProxyAsset;\n\n        underlyingAmounts_ = new uint256[](1);\n        if (derivativeInfo.invariantProxyAssetDecimals == 18) {\n            underlyingAmounts_[0] = _derivativeAmount\n                .mul(ICurveLiquidityPool(derivativeInfo.pool).get_virtual_price())\n                .div(VIRTUAL_PRICE_UNIT);\n        } else {\n            underlyingAmounts_[0] = _derivativeAmount\n                .mul(ICurveLiquidityPool(derivativeInfo.pool).get_virtual_price())\n                .mul(10**derivativeInfo.invariantProxyAssetDecimals)\n                .div(VIRTUAL_PRICE_UNIT)\n                .div(VIRTUAL_PRICE_UNIT);\n        }\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return derivativeToInfo[_asset].pool != address(0);\n    }\n\n    //////////////////////////\n    // DERIVATIVES REGISTRY //\n    //////////////////////////\n\n    /// @notice Adds Curve LP and/or liquidity gauge tokens to the price feed\n    /// @param _derivatives Curve LP and/or liquidity gauge tokens to add\n    /// @param _invariantProxyAssets The ordered assets that act as proxies to the pool invariants,\n    /// corresponding to each item in _derivatives, e.g., WETH for ETH-based pools\n    function addDerivatives(\n        address[] calldata _derivatives,\n        address[] calldata _invariantProxyAssets\n    ) external onlyFundDeployerOwner {\n        require(_derivatives.length > 0, \"addDerivatives: Empty _derivatives\");\n        require(\n            _derivatives.length == _invariantProxyAssets.length,\n            \"addDerivatives: Unequal arrays\"\n        );\n\n        ICurveRegistry curveRegistryContract = ICurveRegistry(\n            ICurveAddressProvider(ADDRESS_PROVIDER).get_registry()\n        );\n\n        for (uint256 i; i < _derivatives.length; i++) {\n            require(_derivatives[i] != address(0), \"addDerivatives: Empty derivative\");\n            require(\n                _invariantProxyAssets[i] != address(0),\n                \"addDerivatives: Empty invariantProxyAsset\"\n            );\n            require(!isSupportedAsset(_derivatives[i]), \"addDerivatives: Value already set\");\n\n            // First, try assuming that the derivative is an LP token\n            address pool = curveRegistryContract.get_pool_from_lp_token(_derivatives[i]);\n\n            // If the derivative is not a valid LP token, try to treat it as a liquidity gauge token\n            if (pool == address(0)) {\n                // We cannot confirm whether a liquidity gauge token is a valid token\n                // for a particular liquidity gauge, due to some pools using\n                // old liquidity gauge contracts that did not incorporate a token\n                pool = curveRegistryContract.get_pool_from_lp_token(\n                    ICurveLiquidityGaugeToken(_derivatives[i]).lp_token()\n                );\n\n                // Likely unreachable as above calls will revert on Curve, but doesn't hurt\n                require(\n                    pool != address(0),\n                    \"addDerivatives: Not a valid LP token or liquidity gauge token\"\n                );\n            }\n\n            uint256 invariantProxyAssetDecimals = ERC20(_invariantProxyAssets[i]).decimals();\n            derivativeToInfo[_derivatives[i]] = DerivativeInfo({\n                pool: pool,\n                invariantProxyAsset: _invariantProxyAssets[i],\n                invariantProxyAssetDecimals: invariantProxyAssetDecimals\n            });\n\n            // Confirm that a non-zero price can be returned for the registered derivative\n            (, uint256[] memory underlyingAmounts) = calcUnderlyingValues(\n                _derivatives[i],\n                1 ether\n            );\n            require(underlyingAmounts[0] > 0, \"addDerivatives: could not calculate valid price\");\n\n            emit DerivativeAdded(\n                _derivatives[i],\n                pool,\n                _invariantProxyAssets[i],\n                invariantProxyAssetDecimals\n            );\n        }\n    }\n\n    /// @notice Removes Curve LP and/or liquidity gauge tokens from the price feed\n    /// @param _derivatives Curve LP and/or liquidity gauge tokens to add\n    function removeDerivatives(address[] calldata _derivatives) external onlyFundDeployerOwner {\n        require(_derivatives.length > 0, \"removeDerivatives: Empty _derivatives\");\n        for (uint256 i; i < _derivatives.length; i++) {\n            require(_derivatives[i] != address(0), \"removeDerivatives: Empty derivative\");\n            require(isSupportedAsset(_derivatives[i]), \"removeDerivatives: Value is not set\");\n\n            delete derivativeToInfo[_derivatives[i]];\n\n            emit DerivativeRemoved(_derivatives[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ADDRESS_PROVIDER` variable\n    /// @return addressProvider_ The `ADDRESS_PROVIDER` variable value\n    function getAddressProvider() external view returns (address addressProvider_) {\n        return ADDRESS_PROVIDER;\n    }\n\n    /// @notice Gets the `DerivativeInfo` for a given derivative\n    /// @param _derivative The derivative for which to get the `DerivativeInfo`\n    /// @return derivativeInfo_ The `DerivativeInfo` value\n    function getDerivativeInfo(address _derivative)\n        external\n        view\n        returns (DerivativeInfo memory derivativeInfo_)\n    {\n        return derivativeToInfo[_derivative];\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveAddressProvider interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveAddressProvider {\n    function get_address(uint256) external view returns (address);\n\n    function get_registry() external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ICurveLiquidityGaugeToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveLiquidityGaugeToken interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Common interface functions for all Curve liquidity gauge token contracts\ninterface ICurveLiquidityGaugeToken {\n    function lp_token() external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ICurveLiquidityPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveLiquidityPool interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveLiquidityPool {\n    function coins(uint256) external view returns (address);\n\n    function get_virtual_price() external view returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/ICurveRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveRegistry interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveRegistry {\n    function get_gauges(address) external view returns (address[10] memory, int128[10] memory);\n\n    function get_lp_token(address) external view returns (address);\n\n    function get_pool_from_lp_token(address) external view returns (address);\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/RevertingPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../IDerivativePriceFeed.sol\";\n\n/// @title RevertingPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price feed that always reverts on value conversion\n/// @dev Used purely for extraordinary circumstances where we want to prevent value calculations,\n/// while allowing an asset to continue to be in the asset universe\ncontract RevertingPriceFeed is IDerivativePriceFeed {\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    function calcUnderlyingValues(address, uint256)\n        external\n        override\n        returns (address[] memory, uint256[] memory)\n    {\n        revert(\"calcUnderlyingValues: RevertingPriceFeed\");\n    }\n\n    /// @notice Checks whether an asset is a supported primitive of the price feed\n    /// @return isSupported_ True if the asset is a supported primitive\n    function isSupportedAsset(address) public view override returns (bool isSupported_) {\n        return true;\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/SinglePeggedDerivativePriceFeedBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../IDerivativePriceFeed.sol\";\n\n/// @title SinglePeggedDerivativePriceFeedBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price feed base for any single derivative that is pegged 1:1 to its underlying\nabstract contract SinglePeggedDerivativePriceFeedBase is IDerivativePriceFeed {\n    address private immutable DERIVATIVE;\n    address private immutable UNDERLYING;\n\n    constructor(address _derivative, address _underlying) public {\n        require(\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\n            \"constructor: Unequal decimals\"\n        );\n\n        DERIVATIVE = _derivative;\n        UNDERLYING = _underlying;\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        require(isSupportedAsset(_derivative), \"calcUnderlyingValues: Not a supported derivative\");\n\n        underlyings_ = new address[](1);\n        underlyings_[0] = UNDERLYING;\n        underlyingAmounts_ = new uint256[](1);\n        underlyingAmounts_[0] = _derivativeAmount;\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return _asset == DERIVATIVE;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `DERIVATIVE` variable value\n    /// @return derivative_ The `DERIVATIVE` variable value\n    function getDerivative() external view returns (address derivative_) {\n        return DERIVATIVE;\n    }\n\n    /// @notice Gets the `UNDERLYING` variable value\n    /// @return underlying_ The `UNDERLYING` variable value\n    function getUnderlying() external view returns (address underlying_) {\n        return UNDERLYING;\n    }\n}\n"
    },
    "contracts/test/TestSinglePeggedDerivativePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/SinglePeggedDerivativePriceFeedBase.sol\";\n\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of SinglePeggedDerivativePriceFeedBase\ncontract TestSinglePeggedDerivativePriceFeed is SinglePeggedDerivativePriceFeedBase {\n    constructor(address _derivative, address _underlying)\n        public\n        SinglePeggedDerivativePriceFeedBase(_derivative, _underlying)\n    {}\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/StakehoundEthPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/SinglePeggedDerivativePriceFeedBase.sol\";\n\n/// @title StakehoundEthPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for Stakehound stETH, which maps 1:1 with ETH\ncontract StakehoundEthPriceFeed is SinglePeggedDerivativePriceFeedBase {\n    constructor(address _steth, address _weth)\n        public\n        SinglePeggedDerivativePriceFeedBase(_steth, _weth)\n    {}\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/YearnVaultV2PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../../../interfaces/IYearnVaultV2.sol\";\nimport \"../../../../interfaces/IYearnVaultV2Registry.sol\";\nimport \"../IDerivativePriceFeed.sol\";\nimport \"./utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\n\n/// @title YearnVaultV2PriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for Yearn Vault V2 shares\ncontract YearnVaultV2PriceFeed is IDerivativePriceFeed, SingleUnderlyingDerivativeRegistryMixin {\n    using SafeMath for uint256;\n\n    address private immutable YEARN_VAULT_V2_REGISTRY;\n\n    constructor(address _fundDeployer, address _yearnVaultV2Registry)\n        public\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\n    {\n        YEARN_VAULT_V2_REGISTRY = _yearnVaultV2Registry;\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        underlyings_ = new address[](1);\n        underlyings_[0] = getUnderlyingForDerivative(_derivative);\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\n\n        underlyingAmounts_ = new uint256[](1);\n        underlyingAmounts_[0] = _derivativeAmount\n            .mul(IYearnVaultV2(_derivative).pricePerShare())\n            .div(10**uint256(ERC20(_derivative).decimals()));\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\n        return getUnderlyingForDerivative(_asset) != address(0);\n    }\n\n    /// @dev Helper to validate the derivative-underlying pair.\n    /// Inherited from SingleUnderlyingDerivativeRegistryMixin.\n    function __validateDerivative(address _derivative, address _underlying) internal override {\n        // Only validate that the _derivative is a valid yVault using the V2 contract,\n        // not that it is the latest vault for a particular _underlying\n        bool isValidYearnVaultV2;\n        IYearnVaultV2Registry yearnRegistryContract = IYearnVaultV2Registry(\n            getYearnVaultV2Registry()\n        );\n        for (uint256 i; i < yearnRegistryContract.numVaults(_underlying); i++) {\n            if (yearnRegistryContract.vaults(_underlying, i) == _derivative) {\n                isValidYearnVaultV2 = true;\n                break;\n            }\n        }\n        require(isValidYearnVaultV2, \"__validateDerivative: Invalid yVault for underlying\");\n\n        // Validates our assumption that yVaults and underlyings will have the same decimals\n        require(\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\n            \"__validateDerivative: Incongruent decimals\"\n        );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `YEARN_VAULT_V2_REGISTRY` variable\n    /// @return yearnVaultV2Registry_ The `YEARN_VAULT_V2_REGISTRY` variable value\n    function getYearnVaultV2Registry() public view returns (address yearnVaultV2Registry_) {\n        return YEARN_VAULT_V2_REGISTRY;\n    }\n}\n"
    },
    "contracts/release/interfaces/IYearnVaultV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IYearnVaultV2 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for our interactions with Yearn Vault V2 contracts\ninterface IYearnVaultV2 {\n    function deposit(uint256, address) external returns (uint256);\n\n    function pricePerShare() external view returns (uint256);\n\n    function token() external view returns (address);\n\n    function withdraw(\n        uint256,\n        address,\n        uint256\n    ) external returns (uint256);\n\n    function setEmergencyShutdown(bool) external;\n\n    function availableDepositLimit() external view returns (uint256);\n\n    function emergencyShutdown() external view returns (bool);\n\n    function setDepositLimit(uint256) external;\n\n    function totalAssets() external view returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/IYearnVaultV2Registry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IYearnVaultV2Registry Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for our interactions with the Yearn Vault V2 registry\ninterface IYearnVaultV2Registry {\n    function numVaults(address) external view returns (uint256);\n\n    function vaults(address, uint256) external view returns (address);\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/SingleUnderlyingDerivativeRegistryMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title SingleUnderlyingDerivativeRegistryMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin for derivative price feeds that handle multiple derivatives\n/// that each have a single underlying asset\nabstract contract SingleUnderlyingDerivativeRegistryMixin is FundDeployerOwnerMixin {\n    event DerivativeAdded(address indexed derivative, address indexed underlying);\n\n    event DerivativeRemoved(address indexed derivative);\n\n    mapping(address => address) private derivativeToUnderlying;\n\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\n\n    /// @notice Adds derivatives with corresponding underlyings to the price feed\n    /// @param _derivatives The derivatives to add\n    /// @param _underlyings The corresponding underlyings to add\n    function addDerivatives(address[] memory _derivatives, address[] memory _underlyings)\n        external\n        virtual\n        onlyFundDeployerOwner\n    {\n        require(_derivatives.length > 0, \"addDerivatives: Empty _derivatives\");\n        require(_derivatives.length == _underlyings.length, \"addDerivatives: Unequal arrays\");\n\n        for (uint256 i; i < _derivatives.length; i++) {\n            require(_derivatives[i] != address(0), \"addDerivatives: Empty derivative\");\n            require(_underlyings[i] != address(0), \"addDerivatives: Empty underlying\");\n            require(\n                getUnderlyingForDerivative(_derivatives[i]) == address(0),\n                \"addDerivatives: Value already set\"\n            );\n\n            console.log(\n                \"SingleUnderlyingDerivativeRegistryMixin _derivatives:%s\",\n                _derivatives[i]\n            );\n            console.log(\n                \"SingleUnderlyingDerivativeRegistryMixin _underlyings:%s\",\n                _underlyings[i]\n            );\n\n            //__validateDerivative(_derivatives[i], _underlyings[i]);\n            console.log(\"SingleUnderlyingDerivativeRegistryMixin passed validation\");\n            derivativeToUnderlying[_derivatives[i]] = _underlyings[i];\n            console.log(\"SingleUnderlyingDerivativeRegistryMixin aaded\");\n\n            emit DerivativeAdded(_derivatives[i], _underlyings[i]);\n        }\n    }\n\n    /// @notice Removes derivatives from the price feed\n    /// @param _derivatives The derivatives to remove\n    function removeDerivatives(address[] memory _derivatives) external onlyFundDeployerOwner {\n        require(_derivatives.length > 0, \"removeDerivatives: Empty _derivatives\");\n\n        for (uint256 i; i < _derivatives.length; i++) {\n            require(\n                getUnderlyingForDerivative(_derivatives[i]) != address(0),\n                \"removeDerivatives: Value not set\"\n            );\n\n            delete derivativeToUnderlying[_derivatives[i]];\n\n            emit DerivativeRemoved(_derivatives[i]);\n        }\n    }\n\n    /// @dev Optionally allow the inheriting price feed to validate the derivative-underlying pair\n    function __validateDerivative(address, address) internal virtual {\n        // UNIMPLEMENTED\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the underlying asset for a given derivative\n    /// @param _derivative The derivative for which to get the underlying asset\n    /// @return underlying_ The underlying asset\n    function getUnderlyingForDerivative(address _derivative)\n        public\n        view\n        returns (address underlying_)\n    {\n        return derivativeToUnderlying[_derivative];\n    }\n}\n"
    },
    "contracts/test/TestSingleUnderlyingDerivativeRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\n\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of SingleUnderlyingDerivativeRegistryMixin\ncontract TestSingleUnderlyingDerivativeRegistry is SingleUnderlyingDerivativeRegistryMixin {\n    constructor(address _dispatcher) public SingleUnderlyingDerivativeRegistryMixin(_dispatcher) {}\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/IdlePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../interfaces/IIdleTokenV4.sol\";\nimport \"../IDerivativePriceFeed.sol\";\nimport \"./utils/SingleUnderlyingDerivativeRegistryMixin.sol\";\n\n/// @title IdlePriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for IdleTokens\ncontract IdlePriceFeed is IDerivativePriceFeed, SingleUnderlyingDerivativeRegistryMixin {\n    using SafeMath for uint256;\n\n    uint256 private constant IDLE_TOKEN_UNIT = 10**18;\n\n    constructor(address _fundDeployer)\n        public\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\n    {}\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        underlyings_ = new address[](1);\n        underlyings_[0] = getUnderlyingForDerivative(_derivative);\n        require(underlyings_[0] != address(0), \"calcUnderlyingValues: Unsupported derivative\");\n\n        underlyingAmounts_ = new uint256[](1);\n        underlyingAmounts_[0] = _derivativeAmount.mul(IIdleTokenV4(_derivative).tokenPrice()).div(\n            IDLE_TOKEN_UNIT\n        );\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\n        return getUnderlyingForDerivative(_asset) != address(0);\n    }\n\n    /// @dev Helper to validate the derivative-underlying pair.\n    /// Inherited from SingleUnderlyingDerivativeRegistryMixin.\n    function __validateDerivative(address _derivative, address _underlying) internal override {\n        require(\n            IIdleTokenV4(_derivative).token() == _underlying,\n            \"__validateDerivative: Invalid underlying for IdleToken\"\n        );\n    }\n}\n"
    },
    "contracts/release/interfaces/IIdleTokenV4.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IIdleTokenV4 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for our interactions with IdleToken (V4) contracts\ninterface IIdleTokenV4 {\n    function getGovTokensAmounts(address) external view returns (uint256[] calldata);\n\n    function govTokens(uint256) external view returns (address);\n\n    function mintIdleToken(\n        uint256,\n        bool,\n        address\n    ) external returns (uint256);\n\n    function redeemIdleToken(uint256) external returns (uint256);\n\n    function token() external view returns (address);\n\n    function tokenPrice() external view returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/IdleV4ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IIdleTokenV4.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title IdleV4ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with Idle tokens (V4)\nabstract contract IdleV4ActionsMixin is AssetHelpers {\n    address private constant IDLE_V4_REFERRAL_ACCOUNT = 0x1ad1fc9964c551f456238Dd88D6a38344B5319D7;\n\n    /// @dev Helper to claim gov token rewards for an IdleToken balance.\n    /// Requires that the current contract has already been transferred the idleToken balance.\n    function __idleV4ClaimRewards(address _idleToken) internal {\n        IIdleTokenV4(_idleToken).redeemIdleToken(0);\n    }\n\n    /// @dev Helper to get all rewards tokens for a specified idleToken\n    function __idleV4GetRewardsTokens(address _idleToken)\n        internal\n        view\n        returns (address[] memory rewardsTokens_)\n    {\n        IIdleTokenV4 idleTokenContract = IIdleTokenV4(_idleToken);\n\n        rewardsTokens_ = new address[](idleTokenContract.getGovTokensAmounts(address(0)).length);\n        for (uint256 i; i < rewardsTokens_.length; i++) {\n            rewardsTokens_[i] = IIdleTokenV4(idleTokenContract).govTokens(i);\n        }\n\n        return rewardsTokens_;\n    }\n\n    /// @dev Helper to lend underlying for IdleToken\n    function __idleV4Lend(\n        address _idleToken,\n        address _underlying,\n        uint256 _underlyingAmount\n    ) internal {\n        __approveAssetMaxAsNeeded(_underlying, _idleToken, _underlyingAmount);\n        IIdleTokenV4(_idleToken).mintIdleToken(_underlyingAmount, true, IDLE_V4_REFERRAL_ACCOUNT);\n    }\n\n    /// @dev Helper to redeem IdleToken for underlying\n    function __idleV4Redeem(address _idleToken, uint256 _idleTokenAmount) internal {\n        IIdleTokenV4(_idleToken).redeemIdleToken(_idleTokenAmount);\n    }\n}\n"
    },
    "contracts/release/peripheral/DepositWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../interfaces/IWETH.sol\";\nimport \"../utils/AssetHelpers.sol\";\n\n/// @title DepositWrapper Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Logic related to wrapping deposit actions\ncontract DepositWrapper is AssetHelpers {\n    address private immutable WETH_TOKEN;\n\n    constructor(address _weth) public {\n        WETH_TOKEN = _weth;\n    }\n\n    /// @dev Needed in case WETH not fully used during exchangeAndBuyShares,\n    /// to unwrap into ETH and refund\n    receive() external payable {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Exchanges ETH into a fund's denomination asset and then buys shares\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _minSharesQuantity The minimum quantity of shares to buy with the sent ETH\n    /// @param _exchange The exchange on which to execute the swap to the denomination asset\n    /// @param _exchangeApproveTarget The address that should be given an allowance of WETH\n    /// for the given _exchange\n    /// @param _exchangeData The data with which to call the exchange to execute the swap\n    /// to the denomination asset\n    /// @param _minInvestmentAmount The minimum amount of the denomination asset\n    /// to receive in the trade for investment (not necessary for WETH)\n    /// @return sharesReceived_ The actual amount of shares received\n    /// @dev Use a reasonable _minInvestmentAmount always, in case the exchange\n    /// does not perform as expected (low incoming asset amount, blend of assets, etc).\n    /// If the fund's denomination asset is WETH, _exchange, _exchangeApproveTarget, _exchangeData,\n    /// and _minInvestmentAmount will be ignored.\n    function exchangeEthAndBuyShares(\n        address _comptrollerProxy,\n        address _denominationAsset,\n        uint256 _minSharesQuantity,\n        address _exchange,\n        address _exchangeApproveTarget,\n        bytes calldata _exchangeData,\n        uint256 _minInvestmentAmount\n    ) external payable returns (uint256 sharesReceived_) {\n        // Wrap ETH into WETH\n        IWETH(payable(getWethToken())).deposit{value: msg.value}();\n\n        // If denominationAsset is WETH, can just buy shares directly\n        if (_denominationAsset == getWethToken()) {\n            __approveAssetMaxAsNeeded(getWethToken(), _comptrollerProxy, msg.value);\n\n            return __buyShares(_comptrollerProxy, msg.sender, msg.value, _minSharesQuantity);\n        }\n\n        // Exchange ETH to the fund's denomination asset\n        __approveAssetMaxAsNeeded(getWethToken(), _exchangeApproveTarget, msg.value);\n        (bool success, bytes memory returnData) = _exchange.call(_exchangeData);\n        require(success, string(returnData));\n\n        // Confirm the amount received in the exchange is above the min acceptable amount\n        uint256 investmentAmount = ERC20(_denominationAsset).balanceOf(address(this));\n        require(\n            investmentAmount >= _minInvestmentAmount,\n            \"exchangeAndBuyShares: _minInvestmentAmount not met\"\n        );\n\n        // Give the ComptrollerProxy max allowance for its denomination asset as necessary\n        __approveAssetMaxAsNeeded(_denominationAsset, _comptrollerProxy, investmentAmount);\n\n        // Buy fund shares\n        sharesReceived_ = __buyShares(\n            _comptrollerProxy,\n            msg.sender,\n            investmentAmount,\n            _minSharesQuantity\n        );\n\n        // Unwrap and refund any remaining WETH not used in the exchange\n        uint256 remainingWeth = ERC20(getWethToken()).balanceOf(address(this));\n        if (remainingWeth > 0) {\n            IWETH(payable(getWethToken())).withdraw(remainingWeth);\n            (success, returnData) = msg.sender.call{value: remainingWeth}(\"\");\n            require(success, string(returnData));\n        }\n\n        return sharesReceived_;\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper for buying shares\n    function __buyShares(\n        address _comptrollerProxy,\n        address _buyer,\n        uint256 _investmentAmount,\n        uint256 _minSharesQuantity\n    ) private returns (uint256 sharesReceived_) {\n        ComptrollerLib comptrollerProxyContract = ComptrollerLib(_comptrollerProxy);\n        sharesReceived_ = comptrollerProxyContract.buySharesOnBehalf(\n            _buyer,\n            _investmentAmount,\n            _minSharesQuantity\n        );\n\n        return sharesReceived_;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `WETH_TOKEN` variable\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveStethLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../../interfaces/ICurveStableSwapSteth.sol\";\nimport \"../../../../../interfaces/IWETH.sol\";\n\n/// @title CurveStethLiquidityActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Curve steth pool's liquidity functions\n/// @dev Inheriting contract must have a receive() function\nabstract contract CurveStethLiquidityActionsMixin {\n    using SafeERC20 for ERC20;\n\n    int128 private constant CURVE_STETH_POOL_INDEX_ETH = 0;\n    int128 private constant CURVE_STETH_POOL_INDEX_STETH = 1;\n\n    address private immutable CURVE_STETH_LIQUIDITY_POOL;\n    address private immutable CURVE_STETH_LIQUIDITY_WETH_TOKEN;\n\n    constructor(\n        address _pool,\n        address _stethToken,\n        address _wethToken\n    ) public {\n        CURVE_STETH_LIQUIDITY_POOL = _pool;\n        CURVE_STETH_LIQUIDITY_WETH_TOKEN = _wethToken;\n\n        // Pre-approve pool to use max of steth token\n        ERC20(_stethToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    /// @dev Helper to add liquidity to the pool\n    function __curveStethLend(\n        uint256 _outgoingWethAmount,\n        uint256 _outgoingStethAmount,\n        uint256 _minIncomingLPTokenAmount\n    ) internal {\n        if (_outgoingWethAmount > 0) {\n            IWETH((CURVE_STETH_LIQUIDITY_WETH_TOKEN)).withdraw(_outgoingWethAmount);\n        }\n\n        ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).add_liquidity{\n            value: _outgoingWethAmount\n        }([_outgoingWethAmount, _outgoingStethAmount], _minIncomingLPTokenAmount);\n    }\n\n    /// @dev Helper to remove liquidity from the pool.\n    // Assumes that if _redeemSingleAsset is true, then\n    // \"_minIncomingWethAmount > 0 XOR _minIncomingStethAmount > 0\" has already been validated.\n    function __curveStethRedeem(\n        uint256 _outgoingLPTokenAmount,\n        uint256 _minIncomingWethAmount,\n        uint256 _minIncomingStethAmount,\n        bool _redeemSingleAsset\n    ) internal {\n        if (_redeemSingleAsset) {\n            if (_minIncomingWethAmount > 0) {\n                ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_STETH_POOL_INDEX_ETH,\n                    _minIncomingWethAmount\n                );\n\n                IWETH(payable(CURVE_STETH_LIQUIDITY_WETH_TOKEN)).deposit{\n                    value: payable(address(this)).balance\n                }();\n            } else {\n                ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_STETH_POOL_INDEX_STETH,\n                    _minIncomingStethAmount\n                );\n            }\n        } else {\n            ICurveStableSwapSteth(CURVE_STETH_LIQUIDITY_POOL).remove_liquidity(\n                _outgoingLPTokenAmount,\n                [_minIncomingWethAmount, _minIncomingStethAmount]\n            );\n\n            IWETH(payable(CURVE_STETH_LIQUIDITY_WETH_TOKEN)).deposit{\n                value: payable(address(this)).balance\n            }();\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_STETH_LIQUIDITY_POOL` variable\n    /// @return pool_ The `CURVE_STETH_LIQUIDITY_POOL` variable value\n    function getCurveStethLiquidityPool() public view returns (address pool_) {\n        return CURVE_STETH_LIQUIDITY_POOL;\n    }\n\n    /// @notice Gets the `CURVE_STETH_LIQUIDITY_WETH_TOKEN` variable\n    /// @return wethToken_ The `CURVE_STETH_LIQUIDITY_WETH_TOKEN` variable value\n    function getCurveStethLiquidityWethToken() public view returns (address wethToken_) {\n        return CURVE_STETH_LIQUIDITY_WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveStableSwapSteth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveStableSwapSteth interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveStableSwapSteth {\n    function add_liquidity(uint256[2] calldata, uint256) external payable returns (uint256);\n\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveSethLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../../interfaces/ICurveStableSwapSeth.sol\";\nimport \"../../../../../interfaces/IWETH.sol\";\n\n/// @title CurveSethLiquidityActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Curve seth pool's liquidity functions\n/// @dev Inheriting contract must have a receive() function\nabstract contract CurveSethLiquidityActionsMixin {\n    using SafeERC20 for ERC20;\n\n    int128 private constant CURVE_SETH_POOL_INDEX_ETH = 0;\n    int128 private constant CURVE_SETH_POOL_INDEX_SETH = 1;\n\n    address private immutable CURVE_SETH_LIQUIDITY_POOL;\n    address private immutable CURVE_SETH_LIQUIDITY_WETH_TOKEN;\n\n    constructor(\n        address _pool,\n        address _sethToken,\n        address _wethToken\n    ) public {\n        CURVE_SETH_LIQUIDITY_POOL = _pool;\n        CURVE_SETH_LIQUIDITY_WETH_TOKEN = _wethToken;\n\n        // Pre-approve pool to use max of seth token\n        ERC20(_sethToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    /// @dev Helper to add liquidity to the pool\n    function __curveSethLend(\n        uint256 _outgoingWethAmount,\n        uint256 _outgoingSethAmount,\n        uint256 _minIncomingLPTokenAmount\n    ) internal {\n        if (_outgoingWethAmount > 0) {\n            IWETH((CURVE_SETH_LIQUIDITY_WETH_TOKEN)).withdraw(_outgoingWethAmount);\n        }\n\n        ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).add_liquidity{value: _outgoingWethAmount}(\n            [_outgoingWethAmount, _outgoingSethAmount],\n            _minIncomingLPTokenAmount\n        );\n    }\n\n    /// @dev Helper to remove liquidity from the pool.\n    // Assumes that if _redeemSingleAsset is true, then\n    // \"_minIncomingWethAmount > 0 XOR _minIncomingSethAmount > 0\" has already been validated.\n    function __curveSethRedeem(\n        uint256 _outgoingLPTokenAmount,\n        uint256 _minIncomingWethAmount,\n        uint256 _minIncomingSethAmount,\n        bool _redeemSingleAsset\n    ) internal {\n        if (_redeemSingleAsset) {\n            if (_minIncomingWethAmount > 0) {\n                ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_SETH_POOL_INDEX_ETH,\n                    _minIncomingWethAmount\n                );\n\n                IWETH(payable(CURVE_SETH_LIQUIDITY_WETH_TOKEN)).deposit{\n                    value: payable(address(this)).balance\n                }();\n            } else {\n                ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_SETH_POOL_INDEX_SETH,\n                    _minIncomingSethAmount\n                );\n            }\n        } else {\n            ICurveStableSwapSeth(CURVE_SETH_LIQUIDITY_POOL).remove_liquidity(\n                _outgoingLPTokenAmount,\n                [_minIncomingWethAmount, _minIncomingSethAmount]\n            );\n\n            IWETH(payable(CURVE_SETH_LIQUIDITY_WETH_TOKEN)).deposit{\n                value: payable(address(this)).balance\n            }();\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_SETH_LIQUIDITY_POOL` variable\n    /// @return pool_ The `CURVE_SETH_LIQUIDITY_POOL` variable value\n    function getCurveSethLiquidityPool() public view returns (address pool_) {\n        return CURVE_SETH_LIQUIDITY_POOL;\n    }\n\n    /// @notice Gets the `CURVE_SETH_LIQUIDITY_WETH_TOKEN` variable\n    /// @return wethToken_ The `CURVE_SETH_LIQUIDITY_WETH_TOKEN` variable value\n    function getCurveSethLiquidityWethToken() public view returns (address wethToken_) {\n        return CURVE_SETH_LIQUIDITY_WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveStableSwapSeth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveStableSwapSeth interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveStableSwapSeth {\n    function add_liquidity(uint256[2] calldata, uint256) external payable returns (uint256);\n\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquiditySethAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\nimport \"../utils/actions/CurveSethLiquidityActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CurveLiquiditySethAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for liquidity provision in Curve's seth pool (https://www.curve.fi/seth)\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\n/// or claimRewardsAndReinvest(). Rationale:\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\n/// to enforce policy management or emit an event\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\ncontract CurveLiquiditySethAdapter is\n    AdapterBase,\n    CurveGaugeV2RewardsHandlerBase,\n    CurveSethLiquidityActionsMixin\n{\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\n    address private immutable LP_TOKEN;\n    address private immutable SETH_TOKEN;\n\n    constructor(\n        address _integrationManager,\n        address _liquidityGaugeToken,\n        address _lpToken,\n        address _minter,\n        address _pool,\n        address _crvToken,\n        address _sethToken,\n        address _wethToken\n    )\n        public\n        AdapterBase(_integrationManager)\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\n        CurveSethLiquidityActionsMixin(_pool, _sethToken, _wethToken)\n    {\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\n        LP_TOKEN = _lpToken;\n        SETH_TOKEN = _sethToken;\n\n        // Max approve contracts to spend relevant tokens\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\n    }\n\n    /// @dev Needed to receive ETH from redemption and to unwrap WETH\n    receive() external payable {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\n    }\n\n    /// @notice Lends assets for seth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingSethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveSethLend(\n            outgoingWethAmount,\n            outgoingSethAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n    }\n\n    /// @notice Lends assets for seth LP tokens, then stakes the received LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lendAndStake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingSethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveSethLend(\n            outgoingWethAmount,\n            outgoingSethAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n        __curveGaugeV2Stake(\n            LIQUIDITY_GAUGE_TOKEN,\n            LP_TOKEN,\n            ERC20(LP_TOKEN).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Redeems seth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingSethAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveSethRedeem(\n            outgoingLpTokenAmount,\n            minIncomingWethAmount,\n            minIncomingSethAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /// @notice Stakes seth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function stake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Stake(LIQUIDITY_GAUGE_TOKEN, LP_TOKEN, __decodeStakeCallArgs(_actionData));\n    }\n\n    /// @notice Unstakes seth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, __decodeUnstakeCallArgs(_actionData));\n    }\n\n    /// @notice Unstakes seth LP tokens, then redeems them\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstakeAndRedeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingSethAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\n        __curveSethRedeem(\n            outgoingLiquidityGaugeTokenAmount,\n            minIncomingWethAmount,\n            minIncomingSethAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards();\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\n            return __parseAssetsForLendAndStake(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        } else if (_selector == STAKE_SELECTOR) {\n            return __parseAssetsForStake(_actionData);\n        } else if (_selector == UNSTAKE_SELECTOR) {\n            return __parseAssetsForUnstake(_actionData);\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\n            return __parseAssetsForUnstakeAndRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls.\n    /// No action required, all values empty.\n    function __parseAssetsForClaimRewards()\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            new address[](0),\n            new uint256[](0),\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingSethAmount,\n            uint256 minIncomingLpTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingWethAmount,\n            outgoingSethAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lendAndStake() calls\n    function __parseAssetsForLendAndStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingSethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingWethAmount,\n            outgoingSethAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingSethAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingWethAmount,\n            minIncomingSethAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during stake() calls\n    function __parseAssetsForStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstake() calls\n    function __parseAssetsForUnstake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstakeAndRedeem() calls\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingSethAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingWethAmount,\n            minIncomingSethAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\n    function __parseIncomingAssetsForRedemptionCalls(\n        uint256 _minIncomingWethAmount,\n        uint256 _minIncomingSethAmount,\n        bool _receiveSingleAsset\n    )\n        private\n        view\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\n    {\n        if (_receiveSingleAsset) {\n            incomingAssets_ = new address[](1);\n            minIncomingAssetAmounts_ = new uint256[](1);\n\n            if (_minIncomingWethAmount == 0) {\n                require(\n                    _minIncomingSethAmount > 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\n                );\n                incomingAssets_[0] = SETH_TOKEN;\n                minIncomingAssetAmounts_[0] = _minIncomingSethAmount;\n            } else {\n                require(\n                    _minIncomingSethAmount == 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\n                );\n                incomingAssets_[0] = getCurveSethLiquidityWethToken();\n                minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\n            }\n        } else {\n            incomingAssets_ = new address[](2);\n            incomingAssets_[0] = getCurveSethLiquidityWethToken();\n            incomingAssets_[1] = SETH_TOKEN;\n\n            minIncomingAssetAmounts_ = new uint256[](2);\n            minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\n            minIncomingAssetAmounts_[1] = _minIncomingSethAmount;\n        }\n\n        return (incomingAssets_, minIncomingAssetAmounts_);\n    }\n\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\n    function __parseSpendAssetsForLendingCalls(\n        uint256 _outgoingWethAmount,\n        uint256 _outgoingSethAmount\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\n        if (_outgoingWethAmount > 0 && _outgoingSethAmount > 0) {\n            spendAssets_ = new address[](2);\n            spendAssets_[0] = getCurveSethLiquidityWethToken();\n            spendAssets_[1] = SETH_TOKEN;\n\n            spendAssetAmounts_ = new uint256[](2);\n            spendAssetAmounts_[0] = _outgoingWethAmount;\n            spendAssetAmounts_[1] = _outgoingSethAmount;\n        } else if (_outgoingWethAmount > 0) {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = getCurveSethLiquidityWethToken();\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingWethAmount;\n        } else {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = SETH_TOKEN;\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingSethAmount;\n        }\n\n        return (spendAssets_, spendAssetAmounts_);\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode the encoded call arguments for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingWethAmount_,\n            uint256 outgoingSethAmount_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for redeeming.\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\n    /// `minIncomingWethAmount_` and `minIncomingSethAmount_` must be >0\n    /// to indicate which asset is to be received.\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingAssetAmount_,\n            uint256 minIncomingWethAmount_,\n            uint256 minIncomingSethAmount_,\n            bool receiveSingleAsset_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256, bool));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for staking\n    function __decodeStakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLpTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for unstaking\n    function __decodeUnstakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\n        return LIQUIDITY_GAUGE_TOKEN;\n    }\n\n    /// @notice Gets the `LP_TOKEN` variable\n    /// @return lpToken_ The `LP_TOKEN` variable value\n    function getLpToken() external view returns (address lpToken_) {\n        return LP_TOKEN;\n    }\n\n    /// @notice Gets the `SETH_TOKEN` variable\n    /// @return sethToken_ The `SETH_TOKEN` variable value\n    function getSethToken() external view returns (address sethToken_) {\n        return SETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveGaugeV2RewardsHandlerBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/ICurveMinter.sol\";\nimport \"../../../../../utils/AddressArrayLib.sol\";\nimport \"./CurveGaugeV2ActionsMixin.sol\";\n\n/// @title CurveGaugeV2RewardsHandlerBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Base contract for handling claiming and reinvesting rewards for a Curve pool\n/// that uses the LiquidityGaugeV2 contract\nabstract contract CurveGaugeV2RewardsHandlerBase is CurveGaugeV2ActionsMixin {\n    using AddressArrayLib for address[];\n\n    address private immutable CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN;\n    address private immutable CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER;\n\n    constructor(address _minter, address _crvToken) public {\n        CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN = _crvToken;\n        CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER = _minter;\n    }\n\n    /// @dev Helper to claim all rewards (CRV and pool-specific).\n    /// Requires contract to be approved to use mint_for().\n    function __curveGaugeV2ClaimAllRewards(address _gauge, address _target) internal {\n        // Claim owed $CRV\n        ICurveMinter(CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER).mint_for(_gauge, _target);\n\n        // Claim owed pool-specific rewards\n        __curveGaugeV2ClaimRewards(_gauge, _target);\n    }\n\n    /// @dev Helper to get all rewards tokens for staking LP tokens\n    function __curveGaugeV2GetRewardsTokensWithCrv(address _gauge)\n        internal\n        view\n        returns (address[] memory rewardsTokens_)\n    {\n        return\n            __curveGaugeV2GetRewardsTokens(_gauge).addUniqueItem(\n                CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN\n            );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN` variable\n    /// @return crvToken_ The `CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN` variable value\n    function getCurveGaugeV2RewardsHandlerCrvToken() public view returns (address crvToken_) {\n        return CURVE_GAUGE_V2_REWARDS_HANDLER_CRV_TOKEN;\n    }\n\n    /// @notice Gets the `CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER` variable\n    /// @return minter_ The `CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER` variable value\n    function getCurveGaugeV2RewardsHandlerMinter() public view returns (address minter_) {\n        return CURVE_GAUGE_V2_REWARDS_HANDLER_MINTER;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveMinter interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveMinter {\n    function mint_for(address, address) external;\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveGaugeV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/ICurveLiquidityGaugeV2.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title CurveGaugeV2ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with any Curve LiquidityGaugeV2 contract\nabstract contract CurveGaugeV2ActionsMixin is AssetHelpers {\n    uint256 private constant CURVE_GAUGE_V2_MAX_REWARDS = 8;\n\n    /// @dev Helper to claim pool-specific rewards\n    function __curveGaugeV2ClaimRewards(address _gauge, address _target) internal {\n        ICurveLiquidityGaugeV2(_gauge).claim_rewards(_target);\n    }\n\n    /// @dev Helper to get list of pool-specific rewards tokens\n    function __curveGaugeV2GetRewardsTokens(address _gauge)\n        internal\n        view\n        returns (address[] memory rewardsTokens_)\n    {\n        address[] memory lpRewardsTokensWithEmpties = new address[](CURVE_GAUGE_V2_MAX_REWARDS);\n        uint256 rewardsTokensCount;\n        for (uint256 i; i < CURVE_GAUGE_V2_MAX_REWARDS; i++) {\n            address rewardToken = ICurveLiquidityGaugeV2(_gauge).reward_tokens(i);\n            if (rewardToken != address(0)) {\n                lpRewardsTokensWithEmpties[i] = rewardToken;\n                rewardsTokensCount++;\n            } else {\n                break;\n            }\n        }\n\n        rewardsTokens_ = new address[](rewardsTokensCount);\n        for (uint256 i; i < rewardsTokensCount; i++) {\n            rewardsTokens_[i] = lpRewardsTokensWithEmpties[i];\n        }\n\n        return rewardsTokens_;\n    }\n\n    /// @dev Helper to stake LP tokens\n    function __curveGaugeV2Stake(\n        address _gauge,\n        address _lpToken,\n        uint256 _amount\n    ) internal {\n        __approveAssetMaxAsNeeded(_lpToken, _gauge, _amount);\n        ICurveLiquidityGaugeV2(_gauge).deposit(_amount, address(this));\n    }\n\n    /// @dev Helper to unstake LP tokens\n    function __curveGaugeV2Unstake(address _gauge, uint256 _amount) internal {\n        ICurveLiquidityGaugeV2(_gauge).withdraw(_amount);\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveLiquidityGaugeV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveLiquidityGaugeV2 interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveLiquidityGaugeV2 {\n    function claim_rewards(address) external;\n\n    function deposit(uint256, address) external;\n\n    function reward_tokens(uint256) external view returns (address);\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityStethAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\nimport \"../utils/actions/CurveStethLiquidityActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CurveLiquidityStethAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for liquidity provision in Curve's steth pool (https://www.curve.fi/steth)\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\n/// or claimRewardsAndReinvest(). Rationale:\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\n/// to enforce policy management or emit an event\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\ncontract CurveLiquidityStethAdapter is\n    AdapterBase,\n    CurveGaugeV2RewardsHandlerBase,\n    CurveStethLiquidityActionsMixin\n{\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\n    address private immutable LP_TOKEN;\n    address private immutable STETH_TOKEN;\n\n    constructor(\n        address _integrationManager,\n        address _liquidityGaugeToken,\n        address _lpToken,\n        address _minter,\n        address _pool,\n        address _crvToken,\n        address _stethToken,\n        address _wethToken\n    )\n        public\n        AdapterBase(_integrationManager)\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\n        CurveStethLiquidityActionsMixin(_pool, _stethToken, _wethToken)\n    {\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\n        LP_TOKEN = _lpToken;\n        STETH_TOKEN = _stethToken;\n\n        // Max approve contracts to spend relevant tokens\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\n    }\n\n    /// @dev Needed to receive ETH from redemption and to unwrap WETH\n    receive() external payable {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\n    }\n\n    /// @notice Lends assets for steth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingStethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveStethLend(\n            outgoingWethAmount,\n            outgoingStethAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n    }\n\n    /// @notice Lends assets for steth LP tokens, then stakes the received LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lendAndStake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingStethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveStethLend(\n            outgoingWethAmount,\n            outgoingStethAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n        __curveGaugeV2Stake(\n            LIQUIDITY_GAUGE_TOKEN,\n            LP_TOKEN,\n            ERC20(LP_TOKEN).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Redeems steth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingStethAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveStethRedeem(\n            outgoingLpTokenAmount,\n            minIncomingWethAmount,\n            minIncomingStethAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /// @notice Stakes steth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function stake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Stake(LIQUIDITY_GAUGE_TOKEN, LP_TOKEN, __decodeStakeCallArgs(_actionData));\n    }\n\n    /// @notice Unstakes steth LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, __decodeUnstakeCallArgs(_actionData));\n    }\n\n    /// @notice Unstakes steth LP tokens, then redeems them\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstakeAndRedeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingStethAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\n        __curveStethRedeem(\n            outgoingLiquidityGaugeTokenAmount,\n            minIncomingWethAmount,\n            minIncomingStethAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards();\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\n            return __parseAssetsForLendAndStake(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        } else if (_selector == STAKE_SELECTOR) {\n            return __parseAssetsForStake(_actionData);\n        } else if (_selector == UNSTAKE_SELECTOR) {\n            return __parseAssetsForUnstake(_actionData);\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\n            return __parseAssetsForUnstakeAndRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls.\n    /// No action required, all values empty.\n    function __parseAssetsForClaimRewards()\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            new address[](0),\n            new uint256[](0),\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingStethAmount,\n            uint256 minIncomingLpTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingWethAmount,\n            outgoingStethAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lendAndStake() calls\n    function __parseAssetsForLendAndStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingWethAmount,\n            uint256 outgoingStethAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingWethAmount,\n            outgoingStethAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingStethAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingWethAmount,\n            minIncomingStethAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during stake() calls\n    function __parseAssetsForStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstake() calls\n    function __parseAssetsForUnstake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstakeAndRedeem() calls\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingWethAmount,\n            uint256 minIncomingStethAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingWethAmount,\n            minIncomingStethAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\n    function __parseIncomingAssetsForRedemptionCalls(\n        uint256 _minIncomingWethAmount,\n        uint256 _minIncomingStethAmount,\n        bool _receiveSingleAsset\n    )\n        private\n        view\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\n    {\n        if (_receiveSingleAsset) {\n            incomingAssets_ = new address[](1);\n            minIncomingAssetAmounts_ = new uint256[](1);\n\n            if (_minIncomingWethAmount == 0) {\n                require(\n                    _minIncomingStethAmount > 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\n                );\n                incomingAssets_[0] = STETH_TOKEN;\n                minIncomingAssetAmounts_[0] = _minIncomingStethAmount;\n            } else {\n                require(\n                    _minIncomingStethAmount == 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\n                );\n                incomingAssets_[0] = getCurveStethLiquidityWethToken();\n                minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\n            }\n        } else {\n            incomingAssets_ = new address[](2);\n            incomingAssets_[0] = getCurveStethLiquidityWethToken();\n            incomingAssets_[1] = STETH_TOKEN;\n\n            minIncomingAssetAmounts_ = new uint256[](2);\n            minIncomingAssetAmounts_[0] = _minIncomingWethAmount;\n            minIncomingAssetAmounts_[1] = _minIncomingStethAmount;\n        }\n\n        return (incomingAssets_, minIncomingAssetAmounts_);\n    }\n\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\n    function __parseSpendAssetsForLendingCalls(\n        uint256 _outgoingWethAmount,\n        uint256 _outgoingStethAmount\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\n        if (_outgoingWethAmount > 0 && _outgoingStethAmount > 0) {\n            spendAssets_ = new address[](2);\n            spendAssets_[0] = getCurveStethLiquidityWethToken();\n            spendAssets_[1] = STETH_TOKEN;\n\n            spendAssetAmounts_ = new uint256[](2);\n            spendAssetAmounts_[0] = _outgoingWethAmount;\n            spendAssetAmounts_[1] = _outgoingStethAmount;\n        } else if (_outgoingWethAmount > 0) {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = getCurveStethLiquidityWethToken();\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingWethAmount;\n        } else {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = STETH_TOKEN;\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingStethAmount;\n        }\n\n        return (spendAssets_, spendAssetAmounts_);\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode the encoded call arguments for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingWethAmount_,\n            uint256 outgoingStethAmount_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for redeeming.\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\n    /// `minIncomingWethAmount_` and `minIncomingStethAmount_` must be >0\n    /// to indicate which asset is to be received.\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingAssetAmount_,\n            uint256 minIncomingWethAmount_,\n            uint256 minIncomingStethAmount_,\n            bool receiveSingleAsset_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256, bool));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for staking\n    function __decodeStakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLpTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for unstaking\n    function __decodeUnstakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\n        return LIQUIDITY_GAUGE_TOKEN;\n    }\n\n    /// @notice Gets the `LP_TOKEN` variable\n    /// @return lpToken_ The `LP_TOKEN` variable value\n    function getLpToken() external view returns (address lpToken_) {\n        return LP_TOKEN;\n    }\n\n    /// @notice Gets the `STETH_TOKEN` variable\n    /// @return stethToken_ The `STETH_TOKEN` variable value\n    function getStethToken() external view returns (address stethToken_) {\n        return STETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityEursAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\nimport \"../utils/actions/CurveEursLiquidityActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CurveLiquidityEursAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for liquidity provision in Curve's eurs pool (https://www.curve.fi/eurs)\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\n/// Rationale:\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\n/// to enforce policy management or emit an event\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\ncontract CurveLiquidityEursAdapter is\n    AdapterBase,\n    CurveGaugeV2RewardsHandlerBase,\n    CurveEursLiquidityActionsMixin\n{\n    address private immutable EURS_TOKEN;\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\n    address private immutable LP_TOKEN;\n    address private immutable SEUR_TOKEN;\n\n    constructor(\n        address _integrationManager,\n        address _liquidityGaugeToken,\n        address _lpToken,\n        address _minter,\n        address _pool,\n        address _crvToken,\n        address _eursToken,\n        address _seurToken\n    )\n        public\n        AdapterBase(_integrationManager)\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\n        CurveEursLiquidityActionsMixin(_pool, _eursToken, _seurToken)\n    {\n        EURS_TOKEN = _eursToken;\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\n        LP_TOKEN = _lpToken;\n        SEUR_TOKEN = _seurToken;\n\n        // Max approve contracts to spend relevant tokens\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Claims rewards from the Curve Minter as well as pool-specific rewards\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        __curveGaugeV2ClaimAllRewards(getLiquidityGaugeToken(), _vaultProxy);\n    }\n\n    /// @notice Lends assets for eurs LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingEursAmount,\n            uint256 outgoingSeurAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveEursLend(\n            outgoingEursAmount,\n            outgoingSeurAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n    }\n\n    /// @notice Lends assets for eurs LP tokens, then stakes the received LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lendAndStake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingEursAmount,\n            uint256 outgoingSeurAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveEursLend(\n            outgoingEursAmount,\n            outgoingSeurAmount,\n            minIncomingLiquidityGaugeTokenAmount\n        );\n        __curveGaugeV2Stake(\n            getLiquidityGaugeToken(),\n            getLpToken(),\n            ERC20(getLpToken()).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Redeems eurs LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingEursAmount,\n            uint256 minIncomingSeurAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveEursRedeem(\n            outgoingLpTokenAmount,\n            minIncomingEursAmount,\n            minIncomingSeurAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /// @notice Stakes eurs LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function stake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Stake(\n            getLiquidityGaugeToken(),\n            getLpToken(),\n            __decodeStakeCallArgs(_actionData)\n        );\n    }\n\n    /// @notice Unstakes eurs LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        __curveGaugeV2Unstake(getLiquidityGaugeToken(), __decodeUnstakeCallArgs(_actionData));\n    }\n\n    /// @notice Unstakes eurs LP tokens, then redeems them\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstakeAndRedeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingEursAmount,\n            uint256 minIncomingSeurAmount,\n            bool redeemSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveGaugeV2Unstake(getLiquidityGaugeToken(), outgoingLiquidityGaugeTokenAmount);\n        __curveEursRedeem(\n            outgoingLiquidityGaugeTokenAmount,\n            minIncomingEursAmount,\n            minIncomingSeurAmount,\n            redeemSingleAsset\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards();\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\n            return __parseAssetsForLendAndStake(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        } else if (_selector == STAKE_SELECTOR) {\n            return __parseAssetsForStake(_actionData);\n        } else if (_selector == UNSTAKE_SELECTOR) {\n            return __parseAssetsForUnstake(_actionData);\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\n            return __parseAssetsForUnstakeAndRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls.\n    /// No action required, all values empty.\n    function __parseAssetsForClaimRewards()\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            new address[](0),\n            new uint256[](0),\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingEursAmount,\n            uint256 outgoingSeurAmount,\n            uint256 minIncomingLpTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingEursAmount,\n            outgoingSeurAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = getLpToken();\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lendAndStake() calls\n    function __parseAssetsForLendAndStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingEursAmount,\n            uint256 outgoingSeurAmount,\n            uint256 minIncomingLiquidityGaugeTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            outgoingEursAmount,\n            outgoingSeurAmount\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = getLiquidityGaugeToken();\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256 minIncomingEursAmount,\n            uint256 minIncomingSeurAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = getLpToken();\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingEursAmount,\n            minIncomingSeurAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during stake() calls\n    function __parseAssetsForStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = getLpToken();\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = getLiquidityGaugeToken();\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstake() calls\n    function __parseAssetsForUnstake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = getLiquidityGaugeToken();\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = getLpToken();\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstakeAndRedeem() calls\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256 minIncomingEursAmount,\n            uint256 minIncomingSeurAmount,\n            bool receiveSingleAsset\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = getLiquidityGaugeToken();\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            minIncomingEursAmount,\n            minIncomingSeurAmount,\n            receiveSingleAsset\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\n    function __parseIncomingAssetsForRedemptionCalls(\n        uint256 _minIncomingEursAmount,\n        uint256 _minIncomingSeurAmount,\n        bool _receiveSingleAsset\n    )\n        private\n        view\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\n    {\n        if (_receiveSingleAsset) {\n            incomingAssets_ = new address[](1);\n            minIncomingAssetAmounts_ = new uint256[](1);\n\n            if (_minIncomingEursAmount == 0) {\n                require(\n                    _minIncomingSeurAmount > 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: No min asset amount specified\"\n                );\n                incomingAssets_[0] = getSeurToken();\n                minIncomingAssetAmounts_[0] = _minIncomingSeurAmount;\n            } else {\n                require(\n                    _minIncomingSeurAmount == 0,\n                    \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\n                );\n                incomingAssets_[0] = getEursToken();\n                minIncomingAssetAmounts_[0] = _minIncomingEursAmount;\n            }\n        } else {\n            incomingAssets_ = new address[](2);\n            incomingAssets_[0] = getEursToken();\n            incomingAssets_[1] = getSeurToken();\n\n            minIncomingAssetAmounts_ = new uint256[](2);\n            minIncomingAssetAmounts_[0] = _minIncomingEursAmount;\n            minIncomingAssetAmounts_[1] = _minIncomingSeurAmount;\n        }\n\n        return (incomingAssets_, minIncomingAssetAmounts_);\n    }\n\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\n    function __parseSpendAssetsForLendingCalls(\n        uint256 _outgoingEursAmount,\n        uint256 _outgoingSeurAmount\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\n        if (_outgoingEursAmount > 0 && _outgoingSeurAmount > 0) {\n            spendAssets_ = new address[](2);\n            spendAssets_[0] = getEursToken();\n            spendAssets_[1] = getSeurToken();\n\n            spendAssetAmounts_ = new uint256[](2);\n            spendAssetAmounts_[0] = _outgoingEursAmount;\n            spendAssetAmounts_[1] = _outgoingSeurAmount;\n        } else if (_outgoingEursAmount > 0) {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = getEursToken();\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingEursAmount;\n        } else {\n            spendAssets_ = new address[](1);\n            spendAssets_[0] = getSeurToken();\n\n            spendAssetAmounts_ = new uint256[](1);\n            spendAssetAmounts_[0] = _outgoingSeurAmount;\n        }\n\n        return (spendAssets_, spendAssetAmounts_);\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode the encoded call arguments for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingEursAmount_,\n            uint256 outgoingSeurAmount_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for redeeming.\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\n    /// `minIncomingEursAmount_` and `minIncomingSeurAmount_` must be >0\n    /// to indicate which asset is to be received.\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingAssetAmount_,\n            uint256 minIncomingEursAmount_,\n            uint256 minIncomingSeurAmount_,\n            bool receiveSingleAsset_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256, uint256, bool));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for staking\n    function __decodeStakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLpTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for unstaking\n    function __decodeUnstakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `EURS_TOKEN` variable\n    /// @return eursToken_ The `EURS_TOKEN` variable value\n    function getEursToken() public view returns (address eursToken_) {\n        return EURS_TOKEN;\n    }\n\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\n    function getLiquidityGaugeToken() public view returns (address liquidityGaugeToken_) {\n        return LIQUIDITY_GAUGE_TOKEN;\n    }\n\n    /// @notice Gets the `LP_TOKEN` variable\n    /// @return lpToken_ The `LP_TOKEN` variable value\n    function getLpToken() public view returns (address lpToken_) {\n        return LP_TOKEN;\n    }\n\n    /// @notice Gets the `SEUR_TOKEN` variable\n    /// @return seurToken_ The `SEUR_TOKEN` variable value\n    function getSeurToken() public view returns (address seurToken_) {\n        return SEUR_TOKEN;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveEursLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../../interfaces/ICurveStableSwapEurs.sol\";\n\n/// @title CurveEursLiquidityActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Curve eurs pool's liquidity functions\n/// @dev Inheriting contract must have a receive() function\nabstract contract CurveEursLiquidityActionsMixin {\n    using SafeERC20 for ERC20;\n\n    int128 private constant CURVE_EURS_POOL_INDEX_EURS = 0;\n    int128 private constant CURVE_EURS_POOL_INDEX_SEUR = 1;\n\n    address private immutable CURVE_EURS_LIQUIDITY_POOL;\n\n    constructor(\n        address _pool,\n        address _eursToken,\n        address _seurToken\n    ) public {\n        CURVE_EURS_LIQUIDITY_POOL = _pool;\n\n        // Pre-approve pool to use max of both tokens\n        ERC20(_eursToken).safeApprove(_pool, type(uint256).max);\n        ERC20(_seurToken).safeApprove(_pool, type(uint256).max);\n    }\n\n    /// @dev Helper to add liquidity to the pool\n    function __curveEursLend(\n        uint256 _outgoingEursAmount,\n        uint256 _outgoingSeurAmount,\n        uint256 _minIncomingLPTokenAmount\n    ) internal {\n        ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).add_liquidity(\n            [_outgoingEursAmount, _outgoingSeurAmount],\n            _minIncomingLPTokenAmount\n        );\n    }\n\n    /// @dev Helper to remove liquidity from the pool.\n    // Assumes that if _redeemSingleAsset is true, then\n    // \"_minIncomingEursAmount > 0 XOR _minIncomingSeurAmount > 0\" has already been validated.\n    function __curveEursRedeem(\n        uint256 _outgoingLPTokenAmount,\n        uint256 _minIncomingEursAmount,\n        uint256 _minIncomingSeurAmount,\n        bool _redeemSingleAsset\n    ) internal {\n        if (_redeemSingleAsset) {\n            if (_minIncomingEursAmount > 0) {\n                ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_EURS_POOL_INDEX_EURS,\n                    _minIncomingEursAmount\n                );\n            } else {\n                ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                    _outgoingLPTokenAmount,\n                    CURVE_EURS_POOL_INDEX_SEUR,\n                    _minIncomingSeurAmount\n                );\n            }\n        } else {\n            ICurveStableSwapEurs(CURVE_EURS_LIQUIDITY_POOL).remove_liquidity(\n                _outgoingLPTokenAmount,\n                [_minIncomingEursAmount, _minIncomingSeurAmount]\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_EURS_LIQUIDITY_POOL` variable\n    /// @return pool_ The `CURVE_EURS_LIQUIDITY_POOL` variable value\n    function getCurveEursLiquidityPool() public view returns (address pool_) {\n        return CURVE_EURS_LIQUIDITY_POOL;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveStableSwapEurs.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveStableSwapEurs interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveStableSwapEurs {\n    function add_liquidity(uint256[2] calldata, uint256) external returns (uint256);\n\n    function remove_liquidity(uint256, uint256[2] calldata) external returns (uint256[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256\n    ) external returns (uint256);\n}\n"
    },
    "contracts/test/TestAddressArrayLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/utils/AddressArrayLib.sol\";\n\n/// @title TestAddressArrayLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of AddressArrayLib\ncontract TestAddressArrayLib {\n    using AddressArrayLib for address[];\n\n    function mergeArray(address[] memory _array, address[] memory _arrayToMerge)\n        external\n        pure\n        returns (address[] memory nextArray_)\n    {\n        return _array.mergeArray(_arrayToMerge);\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/IdleAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/IdlePriceFeed.sol\";\nimport \"../../../../interfaces/IIdleTokenV4.sol\";\nimport \"../../../../utils/AddressArrayLib.sol\";\nimport \"../utils/actions/IdleV4ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title IdleAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for Idle Lending <https://idle.finance/>\n/// @dev There are some idiosyncrasies of reward accrual and claiming in IdleTokens that\n/// are handled by this adapter:\n/// - Rewards accrue to the IdleToken holder, but the accrued\n/// amount is passed to the recipient of a transfer.\n/// - Claiming rewards cannot be done on behalf of a holder, but must be done directly.\n/// - Claiming rewards occurs automatically upon redeeming, but there are situations when\n/// it is difficult to know whether to expect incoming rewards (e.g., after a user mints\n/// idleTokens and then redeems before any other user has interacted with the protocol,\n/// then getGovTokensAmounts() will return 0 balances). Because of this difficulty -\n/// and in keeping with how other adapters treat claimed rewards -\n/// this adapter does not report claimed rewards as incomingAssets.\ncontract IdleAdapter is AdapterBase, IdleV4ActionsMixin {\n    using AddressArrayLib for address[];\n\n    address private immutable IDLE_PRICE_FEED;\n\n    constructor(address _integrationManager, address _idlePriceFeed)\n        public\n        AdapterBase(_integrationManager)\n    {\n        IDLE_PRICE_FEED = _idlePriceFeed;\n    }\n\n    /// @notice Claims rewards for a given IdleToken\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionSpendAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        address idleToken = __decodeClaimRewardsCallArgs(_actionData);\n\n        __idleV4ClaimRewards(idleToken);\n\n        __pushFullAssetBalances(_vaultProxy, __idleV4GetRewardsTokens(idleToken));\n    }\n\n    /// @notice Lends an amount of a token for idleToken\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        // More efficient to parse all from _assetData\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n\n        __idleV4Lend(incomingAssets[0], spendAssets[0], spendAssetAmounts[0]);\n    }\n\n    /// @notice Redeems an amount of idleToken for its underlying asset\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    /// @dev This will also pay out any due gov token rewards.\n    /// We use the full IdleToken balance of the current contract rather than the user input\n    /// for the corner case of a prior balance existing in the current contract, which would\n    /// throw off the per-user avg price of the IdleToken used by Idle, and would leave the\n    /// initial token balance in the current contract post-tx.\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (address idleToken, , ) = __decodeRedeemCallArgs(_actionData);\n\n        __idleV4Redeem(idleToken, ERC20(idleToken).balanceOf(address(this)));\n\n        __pushFullAssetBalances(_vaultProxy, __idleV4GetRewardsTokens(idleToken));\n    }\n\n    /// @dev Helper to get the underlying for a given IdleToken\n    function __getUnderlyingForIdleToken(address _idleToken)\n        private\n        view\n        returns (address underlying_)\n    {\n        return IdlePriceFeed(IDLE_PRICE_FEED).getUnderlyingForDerivative(_idleToken);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address _vaultProxy,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards(_vaultProxy, _actionData);\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls\n    function __parseAssetsForClaimRewards(address _vaultProxy, bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        address idleToken = __decodeClaimRewardsCallArgs(_actionData);\n\n        require(\n            __getUnderlyingForIdleToken(idleToken) != address(0),\n            \"__parseAssetsForClaimRewards: Unsupported idleToken\"\n        );\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = idleToken;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = ERC20(idleToken).balanceOf(_vaultProxy);\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address idleToken,\n            uint256 outgoingUnderlyingAmount,\n            uint256 minIncomingIdleTokenAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        address underlying = __getUnderlyingForIdleToken(idleToken);\n        require(underlying != address(0), \"__parseAssetsForLend: Unsupported idleToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = underlying;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingUnderlyingAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = idleToken;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingIdleTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address idleToken,\n            uint256 outgoingIdleTokenAmount,\n            uint256 minIncomingUnderlyingAmount\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        address underlying = __getUnderlyingForIdleToken(idleToken);\n        require(underlying != address(0), \"__parseAssetsForRedeem: Unsupported idleToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = idleToken;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingIdleTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = underlying;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingUnderlyingAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode callArgs for claiming rewards tokens\n    function __decodeClaimRewardsCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (address idleToken_)\n    {\n        return abi.decode(_actionData, (address));\n    }\n\n    /// @dev Helper to decode callArgs for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address idleToken_,\n            uint256 outgoingUnderlyingAmount_,\n            uint256 minIncomingIdleTokenAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, uint256));\n    }\n\n    /// @dev Helper to decode callArgs for redeeming\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address idleToken_,\n            uint256 outgoingIdleTokenAmount_,\n            uint256 minIncomingUnderlyingAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `IDLE_PRICE_FEED` variable\n    /// @return idlePriceFeed_ The `IDLE_PRICE_FEED` variable value\n    function getIdlePriceFeed() external view returns (address idlePriceFeed_) {\n        return IDLE_PRICE_FEED;\n    }\n}\n"
    },
    "contracts/release/extensions/external-position-manager/external-positions/compound-debt/CompoundDebtPositionLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../../persistent/external-positions/compound-debt/CompoundDebtPositionLibBase1.sol\";\nimport \"../../../../interfaces/ICERC20.sol\";\nimport \"../../../../interfaces/ICEther.sol\";\nimport \"../../../../interfaces/ICompoundComptroller.sol\";\nimport \"../../../../interfaces/IWETH.sol\";\nimport \"../../../../utils/AddressArrayLib.sol\";\nimport \"./ICompoundDebtPosition.sol\";\n\n/// @title CompoundDebtPositionLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An External Position library contract for Compound debt positions\ncontract CompoundDebtPositionLib is CompoundDebtPositionLibBase1, ICompoundDebtPosition {\n    using AddressArrayLib for address[];\n    using SafeERC20 for ERC20;\n    using SafeMath for uint256;\n\n    address private immutable COMP_TOKEN;\n    address private immutable COMPOUND_COMPTROLLER;\n    address private immutable WETH_TOKEN;\n\n    constructor(\n        address _compoundComptroller,\n        address _compToken,\n        address _weth\n    ) public {\n        COMPOUND_COMPTROLLER = _compoundComptroller;\n        COMP_TOKEN = _compToken;\n        WETH_TOKEN = _weth;\n    }\n\n    /// @notice Initializes the external position\n    /// @dev Nothing to initialize for this contract\n    function init(bytes memory) external override {}\n\n    /// @notice Receives and executes a call from the Vault\n    /// @param _actionData Encoded data to execute the action\n    function receiveCallFromVault(bytes memory _actionData) external override {\n        (uint256 actionId, bytes memory actionArgs) = abi.decode(_actionData, (uint256, bytes));\n\n        (address[] memory assets, uint256[] memory amounts, bytes memory data) = abi.decode(\n            actionArgs,\n            (address[], uint256[], bytes)\n        );\n\n        if (actionId == uint256(ExternalPositionActions.AddCollateral)) {\n            __addCollateralAssets(assets, amounts);\n        } else if (actionId == uint256(ExternalPositionActions.RemoveCollateral)) {\n            __removeCollateralAssets(assets, amounts);\n        } else if (actionId == uint256(ExternalPositionActions.Borrow)) {\n            __borrowAssets(assets, amounts, data);\n        } else if (actionId == uint256(ExternalPositionActions.RepayBorrow)) {\n            __repayBorrowedAssets(assets, amounts, data);\n        } else if (actionId == uint256(ExternalPositionActions.ClaimComp)) {\n            __claimComp();\n        } else {\n            revert(\"receiveCallFromVault: Invalid actionId\");\n        }\n    }\n\n    /// @dev Adds assets as collateral\n    function __addCollateralAssets(address[] memory _assets, uint256[] memory _amounts) private {\n        uint256[] memory enterMarketErrorCodes = ICompoundComptroller(getCompoundComptroller())\n            .enterMarkets(_assets);\n\n        for (uint256 i; i < _assets.length; i++) {\n            require(\n                enterMarketErrorCodes[i] == 0,\n                \"__addCollateralAssets: Error while calling enterMarkets on Compound\"\n            );\n\n            if (!assetIsCollateral(_assets[i])) {\n                assetToIsCollateral[_assets[i]] = true;\n                collateralAssets.push(_assets[i]);\n            }\n\n            emit CollateralAssetAdded(_assets[i], _amounts[i]);\n        }\n    }\n\n    /// @dev Borrows assets using the available collateral\n    function __borrowAssets(\n        address[] memory _assets,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) private {\n        address[] memory cTokens = abi.decode(_data, (address[]));\n\n        for (uint256 i; i < _assets.length; i++) {\n            require(\n                ICERC20(cTokens[i]).borrow(_amounts[i]) == 0,\n                \"__borrowAssets: Problem while borrowing from Compound\"\n            );\n\n            // The cToken-token pair is already validated by the parser\n            if (getCTokenFromBorrowedAsset(_assets[i]) == address(0)) {\n                borrowedAssetToCToken[_assets[i]] = cTokens[i];\n                borrowedAssets.push(_assets[i]);\n            }\n\n            if (_assets[i] == getWethToken()) {\n                IWETH(payable(getWethToken())).deposit{value: _amounts[i]}();\n            }\n\n            ERC20(_assets[i]).safeTransfer(msg.sender, _amounts[i]);\n\n            emit AssetBorrowed(_assets[i], _amounts[i]);\n        }\n    }\n\n    /// @dev Claims the COMP_TOKEN accrued in all markets\n    function __claimComp() private {\n        ICompoundComptroller(getCompoundComptroller()).claimComp(address(this));\n\n        ERC20 compToken = ERC20(getCompToken());\n\n        compToken.safeTransfer(msg.sender, compToken.balanceOf(address(this)));\n    }\n\n    /// @dev Removes assets from collateral\n    function __removeCollateralAssets(address[] memory _assets, uint256[] memory _amounts)\n        private\n    {\n        for (uint256 i; i < _assets.length; i++) {\n            require(\n                assetIsCollateral(_assets[i]),\n                \"__removeCollateralAssets: Asset is not collateral\"\n            );\n\n            if (ERC20(_assets[i]).balanceOf(address(this)) == _amounts[i]) {\n                // If the full collateral of an asset is removed, it can be removed from collateral assets\n                assetToIsCollateral[_assets[i]] = false;\n\n                collateralAssets.removeStorageItem(_assets[i]);\n            }\n\n            ERC20(_assets[i]).safeTransfer(msg.sender, _amounts[i]);\n\n            emit CollateralAssetRemoved(_assets[i], _amounts[i]);\n        }\n    }\n\n    /// @notice Repays borrowed assets, reducing the borrow balance\n    function __repayBorrowedAssets(\n        address[] memory _assets,\n        uint256[] memory _amounts,\n        bytes memory _data\n    ) private {\n        address[] memory cTokens = abi.decode(_data, (address[]));\n\n        for (uint256 i; i < _assets.length; i++) {\n            require(\n                getCTokenFromBorrowedAsset(_assets[i]) != address(0),\n                \"__repayBorrowedAssets: Asset has not been borrowed\"\n            );\n\n            require(\n                ERC20(_assets[i]).balanceOf(address(this)) >= _amounts[i],\n                \"__repayBorrowedAssets: Insufficient balance\"\n            );\n\n            // Accrue interest to get the current borrow balance\n            // NOTE: Used instead of borrow-balance-current: https://compound.finance/docs/ctokens#borrow-balance\n            require(\n                ICERC20(cTokens[i]).accrueInterest() == 0,\n                \"__repayBorrowedAssets: Error while calling accrueInterest\"\n            );\n\n            uint256 borrowBalance = ICERC20(cTokens[i]).borrowBalanceStored(address(this));\n\n            if (_amounts[i] < borrowBalance) {\n                // Repaid amount doesn't cover the full balance\n                __repayBorrowedAsset(cTokens[i], _assets[i], _amounts[i]);\n            } else {\n                // Amount covers the full borrow balance, so it can be removed from borrowed balances\n                __repayBorrowedAsset(cTokens[i], _assets[i], borrowBalance);\n\n                // Reset borrowed asset cToken and remove it from the list of borrowed assets\n                delete borrowedAssetToCToken[_assets[i]];\n                borrowedAssets.removeStorageItem(_assets[i]);\n\n                // Send back the remaining token amount after paying the loan\n                if (_amounts[i] > borrowBalance) {\n                    ERC20(_assets[i]).safeTransfer(msg.sender, _amounts[i].sub(borrowBalance));\n                }\n            }\n\n            emit BorrowedAssetRepaid(_assets[i], _amounts[i]);\n        }\n    }\n\n    /// @dev Helper used to repay a borrowed asset to a Compound cToken\n    function __repayBorrowedAsset(\n        address _cToken,\n        address _token,\n        uint256 _amount\n    ) private {\n        if (_token == getWethToken()) {\n            IWETH(payable(getWethToken())).withdraw(_amount);\n            ICEther(_cToken).repayBorrow{value: _amount}();\n        } else {\n            ERC20(_token).safeApprove(_cToken, _amount);\n\n            require(\n                ICERC20(_cToken).repayBorrow(_amount) == 0,\n                \"__repayBorrowedAsset: Error while repaying borrow\"\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Retrieves the borrowed assets and balances of the current external position\n    /// @return assets_ Assets with an active loan\n    /// @return amounts_ Amount of assets in external\n    function getDebtAssets()\n        external\n        override\n        returns (address[] memory assets_, uint256[] memory amounts_)\n    {\n        assets_ = borrowedAssets;\n        amounts_ = new uint256[](assets_.length);\n\n        for (uint256 i; i < assets_.length; i++) {\n            address cToken = getCTokenFromBorrowedAsset(assets_[i]);\n            amounts_[i] = ICERC20(cToken).borrowBalanceStored(address(this));\n        }\n\n        return (assets_, amounts_);\n    }\n\n    /// @notice Retrieves the collateral assets and balances of the current external position\n    /// @return assets_ Assets with balance > 0 that are being used as collateral\n    /// @return amounts_ Amount of assets being used as collateral\n    function getManagedAssets()\n        external\n        override\n        returns (address[] memory assets_, uint256[] memory amounts_)\n    {\n        assets_ = collateralAssets;\n        amounts_ = new uint256[](collateralAssets.length);\n\n        for (uint256 i; i < assets_.length; i++) {\n            amounts_[i] = ERC20(assets_[i]).balanceOf(address(this));\n        }\n\n        return (assets_, amounts_);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether an asset is collateral\n    /// @return isCollateral True if the asset is part of the collateral assets of the external position\n    function assetIsCollateral(address _asset) public view returns (bool isCollateral) {\n        return assetToIsCollateral[_asset];\n    }\n\n    /// @notice Gets the `COMPOUND_COMPTROLLER` variable\n    /// @return compoundComptroller_ The `COMPOUND_COMPTROLLER` variable value\n    function getCompoundComptroller() public view returns (address compoundComptroller_) {\n        return COMPOUND_COMPTROLLER;\n    }\n\n    /// @notice Gets the `COMP_TOKEN` variable\n    /// @return compToken_ The `COMP_TOKEN` variable value\n    function getCompToken() public view returns (address compToken_) {\n        return COMP_TOKEN;\n    }\n\n    /// @notice Returns the cToken of a given borrowed asset\n    /// @param _borrowedAsset The token for which to get the cToken\n    /// @return cToken_ The cToken\n    function getCTokenFromBorrowedAsset(address _borrowedAsset)\n        public\n        view\n        returns (address cToken_)\n    {\n        return borrowedAssetToCToken[_borrowedAsset];\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/persistent/external-positions/compound-debt/CompoundDebtPositionLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title CompoundDebtPositionLibBase1 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A persistent contract containing all required storage variables and\n/// required functions for a CompoundDebtPositionLib implementation\n/// @dev DO NOT EDIT CONTRACT. If new events or storage are necessary, they should be added to\n/// a numbered CompoundDebtPositionLibBaseXXX that inherits the previous base.\n/// e.g., `CompoundDebtPositionLibBase2 is CompoundDebtPositionLibBase1`\n\ncontract CompoundDebtPositionLibBase1 {\n    event AssetBorrowed(address indexed asset, uint256 amount);\n\n    event BorrowedAssetRepaid(address indexed asset, uint256 amount);\n\n    event CollateralAssetAdded(address indexed asset, uint256 amount);\n\n    event CollateralAssetRemoved(address indexed asset, uint256 amount);\n\n    address[] internal borrowedAssets;\n    address[] internal collateralAssets;\n\n    mapping(address => bool) internal assetToIsCollateral;\n    mapping(address => address) internal borrowedAssetToCToken;\n}\n"
    },
    "contracts/release/interfaces/ICEther.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity ^0.6.12;\n\n/// @title ICEther Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for interactions with Compound Ether\ninterface ICEther {\n    function mint() external payable;\n\n    function repayBorrow() external payable;\n}\n"
    },
    "contracts/release/interfaces/ICompoundComptroller.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n    (c) Enzyme Council <council@enzyme.finance>\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity ^0.6.12;\n\n/// @title ICompoundComptroller Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for interactions with Compound Comptroller\ninterface ICompoundComptroller {\n    function claimComp(address) external;\n\n    function enterMarkets(address[] calldata) external returns (uint256[] memory);\n\n    function exitMarket(address) external returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CompoundActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/ICERC20.sol\";\nimport \"../../../../../interfaces/ICEther.sol\";\nimport \"../../../../../interfaces/IWETH.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title CompoundActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Compound lending functions\n/// @dev Inheriting contract must have a receive() function\nabstract contract CompoundActionsMixin is AssetHelpers {\n    address private immutable COMPOUND_WETH_TOKEN;\n\n    constructor(address _wethToken) public {\n        COMPOUND_WETH_TOKEN = _wethToken;\n    }\n\n    /// @dev Helper to execute lending\n    function __compoundLend(\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount,\n        address _incomingAsset\n    ) internal {\n        if (_outgoingAsset == COMPOUND_WETH_TOKEN) {\n            IWETH(COMPOUND_WETH_TOKEN).withdraw(_outgoingAssetAmount);\n            ICEther(_incomingAsset).mint{value: _outgoingAssetAmount}();\n        } else {\n            __approveAssetMaxAsNeeded(_outgoingAsset, _incomingAsset, _outgoingAssetAmount);\n            ICERC20(_incomingAsset).mint(_outgoingAssetAmount);\n        }\n    }\n\n    /// @dev Helper to execute redeeming\n    function __compoundRedeem(\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount,\n        address _incomingAsset\n    ) internal {\n        ICERC20(_outgoingAsset).redeem(_outgoingAssetAmount);\n\n        if (_incomingAsset == COMPOUND_WETH_TOKEN) {\n            IWETH(payable(COMPOUND_WETH_TOKEN)).deposit{value: payable(address(this)).balance}();\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `COMPOUND_WETH_TOKEN` variable\n    /// @return compoundWethToken_ The `COMPOUND_WETH_TOKEN` variable value\n    function getCompoundWethToken() public view returns (address compoundWethToken_) {\n        return COMPOUND_WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CompoundAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/CompoundPriceFeed.sol\";\nimport \"../utils/actions/CompoundActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CompoundAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for Compound <https://compound.finance/>\ncontract CompoundAdapter is AdapterBase, CompoundActionsMixin {\n    address private immutable COMPOUND_PRICE_FEED;\n\n    constructor(\n        address _integrationManager,\n        address _compoundPriceFeed,\n        address _wethToken\n    ) public AdapterBase(_integrationManager) CompoundActionsMixin(_wethToken) {\n        COMPOUND_PRICE_FEED = _compoundPriceFeed;\n    }\n\n    /// @dev Needed to receive ETH during cEther lend/redeem\n    receive() external payable {}\n\n    /// @notice Lends an amount of a token to Compound\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        // More efficient to parse all from _assetData\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n\n        __compoundLend(spendAssets[0], spendAssetAmounts[0], incomingAssets[0]);\n    }\n\n    /// @notice Redeems an amount of cTokens from Compound\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        // More efficient to parse all from _assetData\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n\n        __compoundRedeem(spendAssets[0], spendAssetAmounts[0], incomingAssets[0]);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address cToken, uint256 tokenAmount, uint256 minCTokenAmount) = __decodeCallArgs(\n            _actionData\n        );\n        address token = CompoundPriceFeed(COMPOUND_PRICE_FEED).getTokenFromCToken(cToken);\n        require(token != address(0), \"__parseAssetsForLend: Unsupported cToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = token;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = tokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = cToken;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minCTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address cToken, uint256 cTokenAmount, uint256 minTokenAmount) = __decodeCallArgs(\n            _actionData\n        );\n        address token = CompoundPriceFeed(COMPOUND_PRICE_FEED).getTokenFromCToken(cToken);\n        require(token != address(0), \"__parseAssetsForRedeem: Unsupported cToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = cToken;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = cTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = token;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode callArgs for lend and redeem\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address cToken_,\n            uint256 outgoingAssetAmount_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `COMPOUND_PRICE_FEED` variable\n    /// @return compoundPriceFeed_ The `COMPOUND_PRICE_FEED` variable value\n    function getCompoundPriceFeed() external view returns (address compoundPriceFeed_) {\n        return COMPOUND_PRICE_FEED;\n    }\n}\n"
    },
    "contracts/release/interfaces/IPoolTogetherV4Ticket.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity ^0.6.12;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title IPoolTogetherV4Ticket Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Minimal interface for interactions with PoolTogether tokens (ptTokens)\ninterface IPoolTogetherV4Ticket is IERC20 {\n    function controller() external view returns (address);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/PoolTogetherV4ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IPoolTogetherV4PrizeDistributor.sol\";\nimport \"../../../../../interfaces/IPoolTogetherV4PrizePool.sol\";\nimport \"../../../../../interfaces/IPoolTogetherV4Ticket.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title PoolTogetherV4ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the PoolTogether lending functions\nabstract contract PoolTogetherV4ActionsMixin is AssetHelpers {\n    /// @dev Helper to execute lending\n    function __poolTogetherV4Lend(\n        address _recipient,\n        address _token,\n        uint256 _amount,\n        address _ptToken\n    ) internal {\n        address prizePoolAddress = IPoolTogetherV4Ticket(_ptToken).controller();\n\n        __approveAssetMaxAsNeeded(_token, prizePoolAddress, _amount);\n\n        IPoolTogetherV4PrizePool(prizePoolAddress).depositToAndDelegate(\n            _recipient,\n            _amount,\n            _recipient\n        );\n    }\n\n    /// @dev Helper to execute redeeming\n    function __poolTogetherV4Redeem(\n        address _recipient,\n        address _ptToken,\n        uint256 _amount\n    ) internal {\n        address prizePoolAddress = IPoolTogetherV4Ticket(_ptToken).controller();\n\n        IPoolTogetherV4PrizePool(prizePoolAddress).withdrawFrom(_recipient, _amount);\n    }\n\n    /// @dev Helper to execute claiming\n    function __poolTogetherV4Claim(\n        address _recipient,\n        address _prizeDistributorAddress,\n        uint32[] memory _drawIds,\n        bytes memory _winningPicks\n    ) internal {\n        IPoolTogetherV4PrizeDistributor(_prizeDistributorAddress).claim(\n            _recipient,\n            _drawIds,\n            _winningPicks\n        );\n    }\n}\n"
    },
    "contracts/release/interfaces/IPoolTogetherV4PrizeDistributor.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IPoolTogetherV4PrizeDistributor interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IPoolTogetherV4PrizeDistributor {\n    function claim(\n        address,\n        uint32[] calldata,\n        bytes calldata\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/IPoolTogetherV4PrizePool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IPoolTogetherV4PrizePool interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IPoolTogetherV4PrizePool {\n    function getToken() external view returns (address);\n\n    function depositToAndDelegate(\n        address,\n        uint256,\n        address\n    ) external;\n\n    function withdrawFrom(address, uint256) external returns (uint256);\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/PoolTogetherV4PriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../interfaces/IPoolTogetherV4PrizePool.sol\";\nimport \"../../../../interfaces/IPoolTogetherV4Ticket.sol\";\nimport \"./utils/PeggedDerivativesPriceFeedBase.sol\";\n\n/// @title PoolTogetherV4PriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for PoolTogether (v4)\ncontract PoolTogetherV4PriceFeed is PeggedDerivativesPriceFeedBase {\n    constructor(address _fundDeployer) public PeggedDerivativesPriceFeedBase(_fundDeployer) {}\n\n    function __validateDerivative(address _derivative, address _underlying) internal override {\n        super.__validateDerivative(_derivative, _underlying);\n\n        address controller = IPoolTogetherV4Ticket(_derivative).controller();\n        address prizePoolAsset = IPoolTogetherV4PrizePool(controller).getToken();\n\n        require(\n            prizePoolAsset == _underlying,\n            \"__validateDerivative: Invalid ptToken or token provided\"\n        );\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/utils/PeggedDerivativesPriceFeedBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../../IDerivativePriceFeed.sol\";\nimport \"./SingleUnderlyingDerivativeRegistryMixin.sol\";\n\n/// @title PeggedDerivativesPriceFeedBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price feed base for multiple derivatives that are pegged 1:1 to their underlyings,\n/// and have the same decimals as their underlying\nabstract contract PeggedDerivativesPriceFeedBase is\n    IDerivativePriceFeed,\n    SingleUnderlyingDerivativeRegistryMixin\n{\n    constructor(address _fundDeployer)\n        public\n        SingleUnderlyingDerivativeRegistryMixin(_fundDeployer)\n    {}\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        address underlying = getUnderlyingForDerivative(_derivative);\n        require(underlying != address(0), \"calcUnderlyingValues: Not a supported derivative\");\n\n        underlyings_ = new address[](1);\n        underlyings_[0] = underlying;\n\n        underlyingAmounts_ = new uint256[](1);\n        underlyingAmounts_[0] = _derivativeAmount;\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks if an asset is supported by the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is supported\n    function isSupportedAsset(address _asset) external view override returns (bool isSupported_) {\n        return getUnderlyingForDerivative(_asset) != address(0);\n    }\n\n    /// @dev Provides validation that the derivative and underlying have the same decimals.\n    /// Can be overrode by the inheriting price feed using super() to implement further validation.\n    function __validateDerivative(address _derivative, address _underlying)\n        internal\n        virtual\n        override\n    {\n        require(\n            ERC20(_derivative).decimals() == ERC20(_underlying).decimals(),\n            \"__validateDerivative: Unequal decimals\"\n        );\n    }\n}\n"
    },
    "contracts/test/TestPeggedDerivativesPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/infrastructure/price-feeds/derivatives/feeds/utils/PeggedDerivativesPriceFeedBase.sol\";\n\n/// @title TestSingleUnderlyingDerivativeRegistry Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A test implementation of PeggedDerivativesPriceFeedBase\ncontract TestPeggedDerivativesPriceFeed is PeggedDerivativesPriceFeedBase {\n    constructor(address _dispatcher) public PeggedDerivativesPriceFeedBase(_dispatcher) {}\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/AavePriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../interfaces/IAaveProtocolDataProvider.sol\";\nimport \"./utils/PeggedDerivativesPriceFeedBase.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title AavePriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for Aave\ncontract AavePriceFeed is PeggedDerivativesPriceFeedBase {\n    address private immutable PROTOCOL_DATA_PROVIDER;\n\n    constructor(address _fundDeployer, address _protocolDataProvider)\n        public\n        PeggedDerivativesPriceFeedBase(_fundDeployer)\n    {\n        console.log(\"AavePriceFeed constructor _protocolDataProvider:%s\", _protocolDataProvider);\n        PROTOCOL_DATA_PROVIDER = _protocolDataProvider;\n    }\n\n    function __validateDerivative(address _derivative, address _underlying) internal override {\n        super.__validateDerivative(_derivative, _underlying);\n\n        (address aTokenAddress, , ) = IAaveProtocolDataProvider(PROTOCOL_DATA_PROVIDER)\n            .getReserveTokensAddresses(_underlying);\n\n        console.log(\"__validateDerivative:aTokenAddress:%s\", aTokenAddress);\n        console.log(\"__validateDerivative:_derivative:%s\", _derivative);\n        require(\n            aTokenAddress == _derivative,\n            \"__validateDerivative: Invalid aToken or token provided\"\n        );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `PROTOCOL_DATA_PROVIDER` variable value\n    /// @return protocolDataProvider_ The `PROTOCOL_DATA_PROVIDER` variable value\n    function getProtocolDataProvider() external view returns (address protocolDataProvider_) {\n        return PROTOCOL_DATA_PROVIDER;\n    }\n}\n"
    },
    "contracts/release/interfaces/IAaveProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IAaveProtocolDataProvider interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IAaveProtocolDataProvider {\n    function getReserveTokensAddresses(address)\n        external\n        view\n        returns (\n            address,\n            address,\n            address\n        );\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/AaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/AavePriceFeed.sol\";\nimport \"../utils/actions/AaveActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title AaveAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for Aave Lending <https://aave.com/>\n/// @dev When lending and redeeming, a small `ROUNDING_BUFFER` is subtracted from the min incoming asset amount.\n/// This is a workaround for problematic quirks in `aToken` balance rounding (due to RayMath and rebasing logic),\n/// which would otherwise lead to tx failures during IntegrationManager validation of incoming asset amounts.\n/// Due to this workaround, an `aToken` value less than `ROUNDING_BUFFER` is not usable in this adapter,\n/// which is fine because those values would not make sense (gas-wise) to lend or redeem.\ncontract AaveAdapter is AdapterBase, AaveActionsMixin {\n    using SafeMath for uint256;\n\n    uint256 private constant ROUNDING_BUFFER = 2;\n\n    address private immutable AAVE_PRICE_FEED;\n\n    constructor(\n        address _integrationManager,\n        address _lendingPoolAddressProvider,\n        address _aavePriceFeed\n    ) public AdapterBase(_integrationManager) AaveActionsMixin(_lendingPoolAddressProvider) {\n        AAVE_PRICE_FEED = _aavePriceFeed;\n    }\n\n    /// @notice Lends an amount of a token to AAVE\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    ) external onlyIntegrationManager {\n        (address[] memory spendAssets, uint256[] memory spendAssetAmounts, ) = __decodeAssetData(\n            _assetData\n        );\n\n        __aaveLend(_vaultProxy, spendAssets[0], spendAssetAmounts[0]);\n    }\n\n    /// @notice Redeems an amount of aTokens from AAVE\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    ) external onlyIntegrationManager {\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n\n        __aaveRedeem(_vaultProxy, spendAssets[0], spendAssetAmounts[0], incomingAssets[0]);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address aToken, uint256 amount) = __decodeCallArgs(_actionData);\n\n        // Prevent from invalid token/aToken combination\n        address token = AavePriceFeed(AAVE_PRICE_FEED).getUnderlyingForDerivative(aToken);\n        require(token != address(0), \"__parseAssetsForLend: Unsupported aToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = token;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = amount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = aToken;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = amount.sub(ROUNDING_BUFFER);\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address aToken, uint256 amount) = __decodeCallArgs(_actionData);\n\n        // Prevent from invalid token/aToken combination\n        address token = AavePriceFeed(AAVE_PRICE_FEED).getUnderlyingForDerivative(aToken);\n        require(token != address(0), \"__parseAssetsForRedeem: Unsupported aToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = aToken;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = amount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = token;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        // The `ROUNDING_BUFFER` is overly cautious in this case, but it comes at minimal expense\n        minIncomingAssetAmounts_[0] = amount.sub(ROUNDING_BUFFER);\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode callArgs for lend and redeem\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (address aToken, uint256 amount)\n    {\n        return abi.decode(_actionData, (address, uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `AAVE_PRICE_FEED` variable\n    /// @return aavePriceFeed_ The `AAVE_PRICE_FEED` variable value\n    function getAavePriceFeed() external view returns (address aavePriceFeed_) {\n        return AAVE_PRICE_FEED;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/AaveActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IAaveLendingPool.sol\";\nimport \"../../../../../interfaces/IAaveLendingPoolAddressProvider.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title AaveActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Aave lending functions\nabstract contract AaveActionsMixin is AssetHelpers {\n    uint16 private constant AAVE_REFERRAL_CODE = 158;\n\n    address private immutable AAVE_LENDING_POOL_ADDRESS_PROVIDER;\n\n    constructor(address _lendingPoolAddressProvider) public {\n        AAVE_LENDING_POOL_ADDRESS_PROVIDER = _lendingPoolAddressProvider;\n    }\n\n    /// @dev Helper to execute lending\n    function __aaveLend(\n        address _recipient,\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount\n    ) internal {\n        address lendingPoolAddress = IAaveLendingPoolAddressProvider(\n            AAVE_LENDING_POOL_ADDRESS_PROVIDER\n        )\n            .getLendingPool();\n\n        __approveAssetMaxAsNeeded(_outgoingAsset, lendingPoolAddress, _outgoingAssetAmount);\n\n        IAaveLendingPool(lendingPoolAddress).deposit(\n            _outgoingAsset,\n            _outgoingAssetAmount,\n            _recipient,\n            AAVE_REFERRAL_CODE\n        );\n    }\n\n    /// @dev Helper to execute redeeming\n    function __aaveRedeem(\n        address _recipient,\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount,\n        address _incomingAsset\n    ) internal {\n        address lendingPoolAddress = IAaveLendingPoolAddressProvider(\n            AAVE_LENDING_POOL_ADDRESS_PROVIDER\n        )\n            .getLendingPool();\n\n        __approveAssetMaxAsNeeded(_outgoingAsset, lendingPoolAddress, _outgoingAssetAmount);\n\n        IAaveLendingPool(lendingPoolAddress).withdraw(\n            _incomingAsset,\n            _outgoingAssetAmount,\n            _recipient\n        );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `AAVE_LENDING_POOL_ADDRESS_PROVIDER` variable\n    /// @return aaveLendingPoolAddressProvider_ The `AAVE_LENDING_POOL_ADDRESS_PROVIDER` variable value\n    function getAaveLendingPoolAddressProvider()\n        public\n        view\n        returns (address aaveLendingPoolAddressProvider_)\n    {\n        return AAVE_LENDING_POOL_ADDRESS_PROVIDER;\n    }\n\n    /// @notice Gets the `AAVE_REFERRAL_CODE` variable\n    /// @return aaveReferralCode_ The `AAVE_REFERRAL_CODE` variable value\n    function getAaveReferralCode() public pure returns (uint16 aaveReferralCode_) {\n        return AAVE_REFERRAL_CODE;\n    }\n}\n"
    },
    "contracts/release/interfaces/IAaveLendingPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IAaveLendingPool interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IAaveLendingPool {\n    function deposit(\n        address,\n        uint256,\n        address,\n        uint16\n    ) external;\n\n    function withdraw(\n        address,\n        uint256,\n        address\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/IAaveLendingPoolAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title IAaveLendingPoolAddressProvider interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IAaveLendingPoolAddressProvider {\n    function getLendingPool() external view returns (address);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/PoolTogetherV4Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/PoolTogetherV4PriceFeed.sol\";\nimport \"../utils/actions/PoolTogetherV4ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title PoolTogetherV4Adapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for PoolTogether (v4)\ncontract PoolTogetherV4Adapter is AdapterBase, PoolTogetherV4ActionsMixin {\n    address private immutable POOL_TOGETHER_V4_PRICE_FEED;\n\n    constructor(address _integrationManager, address _poolTogetherV4PriceFeed)\n        public\n        AdapterBase(_integrationManager)\n    {\n        POOL_TOGETHER_V4_PRICE_FEED = _poolTogetherV4PriceFeed;\n    }\n\n    /// @notice Claims rewards from the Prize Distributor\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address prizeDistributor,\n            uint32[] memory drawIds,\n            bytes memory winningPicks\n        ) = __decodeClaimRewardsCallArgs(_actionData);\n\n        __poolTogetherV4Claim(_vaultProxy, prizeDistributor, drawIds, winningPicks);\n    }\n\n    /// @notice Lends an amount of a token to PoolTogether\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\n    function lend(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _encodedAssetTransferArgs\n    ) external onlyIntegrationManager {\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_encodedAssetTransferArgs);\n\n        __poolTogetherV4Lend(_vaultProxy, spendAssets[0], spendAssetAmounts[0], incomingAssets[0]);\n    }\n\n    /// @notice Redeems an amount of ptTokens from PoolTogether\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _encodedAssetTransferArgs Encoded args for expected assets to spend and receive\n    function redeem(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _encodedAssetTransferArgs\n    ) external onlyIntegrationManager {\n        (address[] memory spendAssets, uint256[] memory spendAssetAmounts, ) = __decodeAssetData(\n            _encodedAssetTransferArgs\n        );\n\n        __poolTogetherV4Redeem(_vaultProxy, spendAssets[0], spendAssetAmounts[0]);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards();\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForMethod: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address ptToken, uint256 amount) = __decodeCallArgs(_actionData);\n\n        // Prevent from invalid token/ptToken combination\n        address token = PoolTogetherV4PriceFeed(POOL_TOGETHER_V4_PRICE_FEED)\n            .getUnderlyingForDerivative(ptToken);\n        require(token != address(0), \"__parseAssetsForLend: Unsupported ptToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = token;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = amount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = ptToken;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = amount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (address ptToken, uint256 amount) = __decodeCallArgs(_actionData);\n\n        // Prevent from invalid token/ptToken combination\n        address token = PoolTogetherV4PriceFeed(POOL_TOGETHER_V4_PRICE_FEED)\n            .getUnderlyingForDerivative(ptToken);\n        require(token != address(0), \"__parseAssetsForRedeem: Unsupported ptToken\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = ptToken;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = amount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = token;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = amount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Approve,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls\n    function __parseAssetsForClaimRewards()\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            new address[](0),\n            new uint256[](0),\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode callArgs for lend and redeem\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (address ptToken_, uint256 amount_)\n    {\n        return abi.decode(_actionData, (address, uint256));\n    }\n\n    /// @dev Helper to decode callArgs for claiming rewards tokens\n    function __decodeClaimRewardsCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address prizeDistributor_,\n            uint32[] memory drawIds_,\n            bytes memory winningPicks_\n        )\n    {\n        return abi.decode(_actionData, (address, uint32[], bytes));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `POOL_TOGETHER_V4_PRICE_FEED` variable\n    /// @return poolTogetherV4PriceFeed_ The `POOL_TOGETHER_V4_PRICE_FEED` variable value\n    function getPoolTogetherV4PriceFeed()\n        external\n        view\n        returns (address poolTogetherV4PriceFeed_)\n    {\n        return POOL_TOGETHER_V4_PRICE_FEED;\n    }\n}\n"
    },
    "contracts/mocks/MockGenericExternalPositionLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../persistent/external-positions/IExternalPosition.sol\";\nimport \"../release/utils/AddressArrayLib.sol\";\n\n/// @title MockGenericExternalPosition Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Provides a generic external position to be used on tests\ncontract MockGenericExternalPositionLib is IExternalPosition {\n    using AddressArrayLib for address[];\n\n    enum MockGenericExternalPositionActions {\n        AddManagedAssets,\n        RemoveManagedAssets,\n        AddDebtAssets,\n        RemoveDebtAssets\n    }\n\n    address[] private debtAssets;\n    address[] private managedAssets;\n\n    mapping(address => uint256) private debtAssetsToAmounts;\n    mapping(address => uint256) private managedAssetsToAmounts;\n\n    function init(bytes memory) external override {}\n\n    function receiveCallFromVault(bytes memory _actionData) external override {\n        (uint256 actionId, bytes memory actionArgs) = abi.decode(_actionData, (uint256, bytes));\n\n        (address[] memory assets, uint256[] memory amounts) = abi.decode(\n            actionArgs,\n            (address[], uint256[])\n        );\n        if (actionId == uint256(MockGenericExternalPositionActions.AddManagedAssets)) {\n            __addManagedAssets(assets, amounts);\n        } else if (actionId == uint256(MockGenericExternalPositionActions.RemoveManagedAssets)) {\n            __removeManagedAssets(assets);\n        } else if (actionId == uint256(MockGenericExternalPositionActions.AddDebtAssets)) {\n            __addDebtAssets(assets, amounts);\n        } else if (actionId == uint256(MockGenericExternalPositionActions.RemoveDebtAssets)) {\n            __removeDebtAssets(assets);\n        } else {\n            revert(\"receiveCallFromVault: Invalid actionId\");\n        }\n    }\n\n    /// @dev Adds an array of assets to the existing debt assets\n    function __addDebtAssets(address[] memory _assets, uint256[] memory _amounts) private {\n        for (uint256 i; i < _assets.length; i++) {\n            debtAssets.push(_assets[i]);\n\n            debtAssetsToAmounts[_assets[i]] = _amounts[i];\n        }\n    }\n\n    /// @dev Adds an array of assets to the existing managed assets\n    function __addManagedAssets(address[] memory _assets, uint256[] memory _amounts) private {\n        for (uint256 i; i < _assets.length; i++) {\n            managedAssets.push(_assets[i]);\n\n            managedAssetsToAmounts[_assets[i]] = _amounts[i];\n        }\n    }\n\n    /// @dev Removes an array of assets from the existing debt assets\n    function __removeDebtAssets(address[] memory _assets) private {\n        for (uint256 i; i < _assets.length; i++) {\n            if (debtAssetsToAmounts[_assets[i]] > 0) {\n                debtAssets.removeStorageItem(_assets[i]);\n                debtAssetsToAmounts[_assets[i]] = 0;\n            }\n        }\n    }\n\n    /// @dev Removes an array of assets from the existing managed assets\n    function __removeManagedAssets(address[] memory _assets) private {\n        for (uint256 i; i < _assets.length; i++) {\n            if (managedAssetsToAmounts[_assets[i]] > 0) {\n                managedAssets.removeStorageItem(_assets[i]);\n                managedAssetsToAmounts[_assets[i]] = 0;\n            }\n        }\n    }\n\n    /// @dev Gets the array of debt assets\n    function getDebtAssets()\n        external\n        override\n        returns (address[] memory assets_, uint256[] memory amounts_)\n    {\n        assets_ = new address[](debtAssets.length);\n        amounts_ = new uint256[](debtAssets.length);\n\n        for (uint256 i; i < debtAssets.length; i++) {\n            assets_[i] = debtAssets[i];\n            amounts_[i] = debtAssetsToAmounts[assets_[i]];\n        }\n        return (assets_, amounts_);\n    }\n\n    /// @dev Gets the array of managed assets\n    function getManagedAssets()\n        external\n        override\n        returns (address[] memory assets_, uint256[] memory amounts_)\n    {\n        assets_ = new address[](managedAssets.length);\n        amounts_ = new uint256[](managedAssets.length);\n\n        for (uint256 i; i < managedAssets.length; i++) {\n            assets_[i] = managedAssets[i];\n            amounts_[i] = managedAssetsToAmounts[assets_[i]];\n        }\n        return (assets_, amounts_);\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveLiquidityAaveAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.6.12;\n\nimport \"../utils/actions/CurveAaveLiquidityActionsMixin.sol\";\nimport \"../utils/actions/CurveGaugeV2RewardsHandlerBase.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CurveLiquidityAaveAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for liquidity provision in Curve's aave pool (https://www.curve.fi/aave)\n/// @dev Rewards tokens are not included as spend assets or incoming assets for claimRewards()\n/// or claimRewardsAndReinvest(). Rationale:\n/// - rewards tokens can be claimed to the vault outside of the IntegrationManager, so no need\n/// to enforce policy management or emit an event\n/// - rewards tokens can be outside of the asset universe, in which case they cannot be tracked\ncontract CurveLiquidityAaveAdapter is\n    AdapterBase,\n    CurveGaugeV2RewardsHandlerBase,\n    CurveAaveLiquidityActionsMixin\n{\n    address private immutable AAVE_DAI_TOKEN;\n    address private immutable AAVE_USDC_TOKEN;\n    address private immutable AAVE_USDT_TOKEN;\n\n    address private immutable DAI_TOKEN;\n    address private immutable USDC_TOKEN;\n    address private immutable USDT_TOKEN;\n\n    address private immutable LIQUIDITY_GAUGE_TOKEN;\n    address private immutable LP_TOKEN;\n\n    constructor(\n        address _integrationManager,\n        address _liquidityGaugeToken,\n        address _lpToken,\n        address _minter,\n        address _pool,\n        address _crvToken,\n        address[3] memory _aaveTokens, // [aDAI, aUSDC, aUSDT]\n        address[3] memory _underlyingTokens // [DAI, USDC, USDT]\n    )\n        public\n        AdapterBase(_integrationManager)\n        CurveAaveLiquidityActionsMixin(_pool, _aaveTokens, _underlyingTokens)\n        CurveGaugeV2RewardsHandlerBase(_minter, _crvToken)\n    {\n        AAVE_DAI_TOKEN = _aaveTokens[0];\n        AAVE_USDC_TOKEN = _aaveTokens[1];\n        AAVE_USDT_TOKEN = _aaveTokens[2];\n\n        DAI_TOKEN = _underlyingTokens[0];\n        USDC_TOKEN = _underlyingTokens[1];\n        USDT_TOKEN = _underlyingTokens[2];\n\n        LIQUIDITY_GAUGE_TOKEN = _liquidityGaugeToken;\n        LP_TOKEN = _lpToken;\n\n        // Max approve liquidity gauge to spend LP token\n        ERC20(_lpToken).safeApprove(_liquidityGaugeToken, type(uint256).max);\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Claims rewards from the Curve liquidity gauge as well as pool-specific rewards\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    function claimRewards(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        __curveGaugeV2ClaimAllRewards(LIQUIDITY_GAUGE_TOKEN, _vaultProxy);\n    }\n\n    /// @notice Lends assets for LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256[3] memory orderedOutgoingAmounts,\n            uint256 minIncomingLPTokenAmount,\n            bool useUnderlyings\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveAaveLend(orderedOutgoingAmounts, minIncomingLPTokenAmount, useUnderlyings);\n    }\n\n    /// @notice Lends assets for LP tokens, then stakes the received LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function lendAndStake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256[3] memory orderedOutgoingAmounts,\n            uint256 minIncomingLiquidityGaugeTokenAmount,\n            bool useUnderlyings\n        ) = __decodeLendCallArgs(_actionData);\n\n        __curveAaveLend(\n            orderedOutgoingAmounts,\n            minIncomingLiquidityGaugeTokenAmount,\n            useUnderlyings\n        );\n        __curveGaugeV2Stake(\n            LIQUIDITY_GAUGE_TOKEN,\n            LP_TOKEN,\n            ERC20(LP_TOKEN).balanceOf(address(this))\n        );\n    }\n\n    /// @notice Redeems LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLPTokenAmount,\n            uint256[3] memory orderedMinIncomingAssetAmounts,\n            bool redeemSingleAsset,\n            bool useUnderlyings\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveAaveRedeem(\n            outgoingLPTokenAmount,\n            orderedMinIncomingAssetAmounts,\n            redeemSingleAsset,\n            useUnderlyings\n        );\n    }\n\n    /// @notice Stakes LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function stake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        uint256 outgoingLPTokenAmount = __decodeStakeCallArgs(_actionData);\n\n        __curveGaugeV2Stake(LIQUIDITY_GAUGE_TOKEN, LP_TOKEN, outgoingLPTokenAmount);\n    }\n\n    /// @notice Unstakes LP tokens\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstake(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_actionData);\n\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\n    }\n\n    /// @notice Unstakes LP tokens, then redeems them\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function unstakeAndRedeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionIncomingAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256[3] memory orderedMinIncomingAssetAmounts,\n            bool redeemSingleAsset,\n            bool useUnderlyings\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __curveGaugeV2Unstake(LIQUIDITY_GAUGE_TOKEN, outgoingLiquidityGaugeTokenAmount);\n        __curveAaveRedeem(\n            outgoingLiquidityGaugeTokenAmount,\n            orderedMinIncomingAssetAmounts,\n            redeemSingleAsset,\n            useUnderlyings\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == CLAIM_REWARDS_SELECTOR) {\n            return __parseAssetsForClaimRewards();\n        } else if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == LEND_AND_STAKE_SELECTOR) {\n            return __parseAssetsForLendAndStake(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        } else if (_selector == STAKE_SELECTOR) {\n            return __parseAssetsForStake(_actionData);\n        } else if (_selector == UNSTAKE_SELECTOR) {\n            return __parseAssetsForUnstake(_actionData);\n        } else if (_selector == UNSTAKE_AND_REDEEM_SELECTOR) {\n            return __parseAssetsForUnstakeAndRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during claimRewards() calls.\n    /// No action required, all values empty.\n    function __parseAssetsForClaimRewards()\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            new address[](0),\n            new uint256[](0),\n            new address[](0),\n            new uint256[](0)\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256[3] memory orderedOutgoingAssetAmounts,\n            uint256 minIncomingLpTokenAmount,\n            bool useUnderlyings\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            orderedOutgoingAssetAmounts,\n            useUnderlyings\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lendAndStake() calls\n    function __parseAssetsForLendAndStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256[3] memory orderedOutgoingAssetAmounts,\n            uint256 minIncomingLiquidityGaugeTokenAmount,\n            bool useUnderlyings\n        ) = __decodeLendCallArgs(_actionData);\n\n        (spendAssets_, spendAssetAmounts_) = __parseSpendAssetsForLendingCalls(\n            orderedOutgoingAssetAmounts,\n            useUnderlyings\n        );\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLpTokenAmount,\n            uint256[3] memory orderedMinIncomingAssetAmounts,\n            bool receiveSingleAsset,\n            bool useUnderlyings\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            orderedMinIncomingAssetAmounts,\n            receiveSingleAsset,\n            useUnderlyings\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during stake() calls\n    function __parseAssetsForStake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLpTokenAmount = __decodeStakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LP_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLpTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstake() calls\n    function __parseAssetsForUnstake(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        uint256 outgoingLiquidityGaugeTokenAmount = __decodeUnstakeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = LP_TOKEN;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during unstakeAndRedeem() calls\n    function __parseAssetsForUnstakeAndRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingLiquidityGaugeTokenAmount,\n            uint256[3] memory orderedMinIncomingAssetAmounts,\n            bool receiveSingleAsset,\n            bool useUnderlyings\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = LIQUIDITY_GAUGE_TOKEN;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingLiquidityGaugeTokenAmount;\n\n        (incomingAssets_, minIncomingAssetAmounts_) = __parseIncomingAssetsForRedemptionCalls(\n            orderedMinIncomingAssetAmounts,\n            receiveSingleAsset,\n            useUnderlyings\n        );\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend assets for redeem() and unstakeAndRedeem() calls\n    function __parseIncomingAssetsForRedemptionCalls(\n        uint256[3] memory _orderedMinIncomingAssetAmounts,\n        bool _receiveSingleAsset,\n        bool _useUnderlyings\n    )\n        private\n        view\n        returns (address[] memory incomingAssets_, uint256[] memory minIncomingAssetAmounts_)\n    {\n        if (_receiveSingleAsset) {\n            incomingAssets_ = new address[](1);\n            minIncomingAssetAmounts_ = new uint256[](1);\n\n            for (uint256 i; i < _orderedMinIncomingAssetAmounts.length; i++) {\n                if (_orderedMinIncomingAssetAmounts[i] == 0) {\n                    continue;\n                }\n\n                // Validate that only one min asset amount is set\n                for (uint256 j = i + 1; j < _orderedMinIncomingAssetAmounts.length; j++) {\n                    require(\n                        _orderedMinIncomingAssetAmounts[j] == 0,\n                        \"__parseIncomingAssetsForRedemptionCalls: Too many min asset amounts specified\"\n                    );\n                }\n\n                incomingAssets_[0] = getAssetByPoolIndex(i, _useUnderlyings);\n                minIncomingAssetAmounts_[0] = _orderedMinIncomingAssetAmounts[i];\n\n                break;\n            }\n            require(\n                incomingAssets_[0] != address(0),\n                \"__parseIncomingAssetsForRedemptionCalls: No min asset amount\"\n            );\n        } else {\n            incomingAssets_ = new address[](3);\n            minIncomingAssetAmounts_ = new uint256[](3);\n            for (uint256 i; i < incomingAssets_.length; i++) {\n                incomingAssets_[i] = getAssetByPoolIndex(i, _useUnderlyings);\n                minIncomingAssetAmounts_[i] = _orderedMinIncomingAssetAmounts[i];\n            }\n        }\n\n        return (incomingAssets_, minIncomingAssetAmounts_);\n    }\n\n    /// @dev Helper function to parse spend assets for lend() and lendAndStake() calls\n    function __parseSpendAssetsForLendingCalls(\n        uint256[3] memory _orderedOutgoingAssetAmounts,\n        bool _useUnderlyings\n    ) private view returns (address[] memory spendAssets_, uint256[] memory spendAssetAmounts_) {\n        uint256 spendAssetsCount;\n        for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {\n            if (_orderedOutgoingAssetAmounts[i] > 0) {\n                spendAssetsCount++;\n            }\n        }\n\n        spendAssets_ = new address[](spendAssetsCount);\n        spendAssetAmounts_ = new uint256[](spendAssetsCount);\n        uint256 spendAssetsIndex;\n        for (uint256 i; i < _orderedOutgoingAssetAmounts.length; i++) {\n            if (_orderedOutgoingAssetAmounts[i] > 0) {\n                spendAssets_[spendAssetsIndex] = getAssetByPoolIndex(i, _useUnderlyings);\n                spendAssetAmounts_[spendAssetsIndex] = _orderedOutgoingAssetAmounts[i];\n                spendAssetsIndex++;\n            }\n        }\n\n        return (spendAssets_, spendAssetAmounts_);\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode the encoded call arguments for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256[3] memory orderedOutgoingAmounts_,\n            uint256 minIncomingAssetAmount_,\n            bool useUnderlyings_\n        )\n    {\n        return abi.decode(_actionData, (uint256[3], uint256, bool));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for redeeming.\n    /// If `receiveSingleAsset_` is `true`, then one (and only one) of\n    /// the orderedMinIncomingAmounts_ must be >0 to indicate which asset is to be received.\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingAssetAmount_,\n            uint256[3] memory orderedMinIncomingAmounts_,\n            bool receiveSingleAsset_,\n            bool useUnderlyings_\n        )\n    {\n        return abi.decode(_actionData, (uint256, uint256[3], bool, bool));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for staking\n    function __decodeStakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLPTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    /// @dev Helper to decode the encoded call arguments for unstaking\n    function __decodeUnstakeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (uint256 outgoingLiquidityGaugeTokenAmount_)\n    {\n        return abi.decode(_actionData, (uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `LIQUIDITY_GAUGE_TOKEN` variable\n    /// @return liquidityGaugeToken_ The `LIQUIDITY_GAUGE_TOKEN` variable value\n    function getLiquidityGaugeToken() external view returns (address liquidityGaugeToken_) {\n        return LIQUIDITY_GAUGE_TOKEN;\n    }\n\n    /// @notice Gets the `LP_TOKEN` variable\n    /// @return lpToken_ The `LP_TOKEN` variable value\n    function getLpToken() external view returns (address lpToken_) {\n        return LP_TOKEN;\n    }\n\n    /// @notice Gets an asset by its pool index and whether or not to use the underlying\n    /// instead of the aToken\n    function getAssetByPoolIndex(uint256 _index, bool _useUnderlying)\n        public\n        view\n        returns (address asset_)\n    {\n        if (_index == 0) {\n            if (_useUnderlying) {\n                return DAI_TOKEN;\n            }\n            return AAVE_DAI_TOKEN;\n        } else if (_index == 1) {\n            if (_useUnderlying) {\n                return USDC_TOKEN;\n            }\n            return AAVE_USDC_TOKEN;\n        } else if (_index == 2) {\n            if (_useUnderlying) {\n                return USDT_TOKEN;\n            }\n            return AAVE_USDT_TOKEN;\n        }\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveAaveLiquidityActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"../../../../../interfaces/ICurveStableSwapAave.sol\";\n\n/// @title CurveAaveLiquidityActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Curve Aave pool's liquidity functions\nabstract contract CurveAaveLiquidityActionsMixin {\n    using SafeERC20 for ERC20;\n\n    address private immutable CURVE_AAVE_LIQUIDITY_POOL;\n\n    constructor(\n        address _pool,\n        address[3] memory _aaveTokensToApprove,\n        address[3] memory _underlyingTokensToApprove\n    ) public {\n        CURVE_AAVE_LIQUIDITY_POOL = _pool;\n\n        // Pre-approve pool to use max of each aToken and underlying,\n        // as specified by the inheriting contract.\n        // Use address(0) to skip a particular ordered asset.\n        for (uint256 i; i < 3; i++) {\n            if (_aaveTokensToApprove[i] != address(0)) {\n                ERC20(_aaveTokensToApprove[i]).safeApprove(_pool, type(uint256).max);\n            }\n            if (_underlyingTokensToApprove[i] != address(0)) {\n                ERC20(_underlyingTokensToApprove[i]).safeApprove(_pool, type(uint256).max);\n            }\n        }\n    }\n\n    /// @dev Helper to add liquidity to the pool.\n    /// _orderedOutgoingAssetAmounts = [aDAI, aUSDC, aUSDT].\n    function __curveAaveLend(\n        uint256[3] memory _orderedOutgoingAssetAmounts,\n        uint256 _minIncomingLPTokenAmount,\n        bool _useUnderlyings\n    ) internal {\n        ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).add_liquidity(\n            _orderedOutgoingAssetAmounts,\n            _minIncomingLPTokenAmount,\n            _useUnderlyings\n        );\n    }\n\n    /// @dev Helper to remove liquidity from the pool.\n    /// if using _redeemSingleAsset, must pre-validate that one - and only one - asset\n    /// has a non-zero _orderedMinIncomingAssetAmounts value.\n    /// _orderedOutgoingAssetAmounts = [aDAI, aUSDC, aUSDT].\n    function __curveAaveRedeem(\n        uint256 _outgoingLPTokenAmount,\n        uint256[3] memory _orderedMinIncomingAssetAmounts,\n        bool _redeemSingleAsset,\n        bool _useUnderlyings\n    ) internal {\n        if (_redeemSingleAsset) {\n            // Assume that one - and only one - asset has a non-zero min incoming asset amount\n            for (uint256 i; i < _orderedMinIncomingAssetAmounts.length; i++) {\n                if (_orderedMinIncomingAssetAmounts[i] > 0) {\n                    ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).remove_liquidity_one_coin(\n                        _outgoingLPTokenAmount,\n                        int128(i),\n                        _orderedMinIncomingAssetAmounts[i],\n                        _useUnderlyings\n                    );\n                    return;\n                }\n            }\n        } else {\n            ICurveStableSwapAave(CURVE_AAVE_LIQUIDITY_POOL).remove_liquidity(\n                _outgoingLPTokenAmount,\n                _orderedMinIncomingAssetAmounts,\n                _useUnderlyings\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_AAVE_LIQUIDITY_POOL` variable\n    /// @return pool_ The `CURVE_AAVE_LIQUIDITY_POOL` variable value\n    function getCurveAaveLiquidityPool() public view returns (address pool_) {\n        return CURVE_AAVE_LIQUIDITY_POOL;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveStableSwapAave.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveStableSwapAave interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveStableSwapAave {\n    function add_liquidity(\n        uint256[3] calldata,\n        uint256,\n        bool\n    ) external returns (uint256);\n\n    function remove_liquidity(\n        uint256,\n        uint256[3] calldata,\n        bool\n    ) external returns (uint256[3] memory);\n\n    function remove_liquidity_one_coin(\n        uint256,\n        int128,\n        uint256,\n        bool\n    ) external returns (uint256);\n}\n"
    },
    "contracts/mocks/utils/SwapperBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"./EthConstantMixin.sol\";\n\nabstract contract SwapperBase is EthConstantMixin {\n    using SafeERC20 for ERC20;\n\n    receive() external payable {}\n\n    function __swapAssets(\n        address payable _trader,\n        address _srcToken,\n        uint256 _srcAmount,\n        address _destToken,\n        uint256 _actualRate\n    ) internal returns (uint256 destAmount_) {\n        address[] memory assetsToIntegratee = new address[](1);\n        assetsToIntegratee[0] = _srcToken;\n        uint256[] memory assetsToIntegrateeAmounts = new uint256[](1);\n        assetsToIntegrateeAmounts[0] = _srcAmount;\n\n        address[] memory assetsFromIntegratee = new address[](1);\n        assetsFromIntegratee[0] = _destToken;\n        uint256[] memory assetsFromIntegrateeAmounts = new uint256[](1);\n        assetsFromIntegrateeAmounts[0] = _actualRate;\n        __swap(\n            _trader,\n            assetsToIntegratee,\n            assetsToIntegrateeAmounts,\n            assetsFromIntegratee,\n            assetsFromIntegrateeAmounts\n        );\n\n        return assetsFromIntegrateeAmounts[0];\n    }\n\n    function __swap(\n        address payable _trader,\n        address[] memory _assetsToIntegratee,\n        uint256[] memory _assetsToIntegrateeAmounts,\n        address[] memory _assetsFromIntegratee,\n        uint256[] memory _assetsFromIntegrateeAmounts\n    ) internal {\n        // Take custody of incoming assets\n        for (uint256 i = 0; i < _assetsToIntegratee.length; i++) {\n            address asset = _assetsToIntegratee[i];\n            uint256 amount = _assetsToIntegrateeAmounts[i];\n\n            require(asset != address(0), \"__swap: empty value in _assetsToIntegratee\");\n            require(amount > 0, \"__swap: empty value in _assetsToIntegrateeAmounts\");\n\n            // Incoming ETH amounts can be ignored\n            if (asset == ETH_ADDRESS) {\n                continue;\n            }\n            ERC20(asset).safeTransferFrom(_trader, address(this), amount);\n        }\n\n        // Distribute outgoing assets\n        for (uint256 i = 0; i < _assetsFromIntegratee.length; i++) {\n            address asset = _assetsFromIntegratee[i];\n            uint256 amount = _assetsFromIntegrateeAmounts[i];\n\n            require(asset != address(0), \"__swap: empty value in _assetsFromIntegratee\");\n            require(amount > 0, \"__swap: empty value in _assetsFromIntegrateeAmounts\");\n\n            if (asset == ETH_ADDRESS) {\n                _trader.transfer(amount);\n            } else {\n                ERC20(asset).safeTransfer(_trader, amount);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mocks/utils/EthConstantMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nabstract contract EthConstantMixin {\n    address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n}\n"
    },
    "contracts/mocks/MockGenericIntegratee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/SwapperBase.sol\";\n\ncontract MockGenericIntegratee is SwapperBase {\n    function swap(\n        address[] calldata _assetsToIntegratee,\n        uint256[] calldata _assetsToIntegrateeAmounts,\n        address[] calldata _assetsFromIntegratee,\n        uint256[] calldata _assetsFromIntegrateeAmounts\n    ) external payable {\n        __swap(\n            msg.sender,\n            _assetsToIntegratee,\n            _assetsToIntegrateeAmounts,\n            _assetsFromIntegratee,\n            _assetsFromIntegrateeAmounts\n        );\n    }\n\n    function swapOnBehalf(\n        address payable _trader,\n        address[] calldata _assetsToIntegratee,\n        uint256[] calldata _assetsToIntegrateeAmounts,\n        address[] calldata _assetsFromIntegratee,\n        uint256[] calldata _assetsFromIntegrateeAmounts\n    ) external payable {\n        __swap(\n            _trader,\n            _assetsToIntegratee,\n            _assetsToIntegrateeAmounts,\n            _assetsFromIntegratee,\n            _assetsFromIntegrateeAmounts\n        );\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/CurveExchangeActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/ICurveAddressProvider.sol\";\nimport \"../../../../../interfaces/ICurveSwapsERC20.sol\";\nimport \"../../../../../interfaces/ICurveSwapsEther.sol\";\nimport \"../../../../../interfaces/IWETH.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title CurveExchangeActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Curve exchange functions\n/// @dev Inheriting contract must have a receive() function\nabstract contract CurveExchangeActionsMixin is AssetHelpers {\n    address\n        private constant CURVE_EXCHANGE_ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n    address private immutable CURVE_EXCHANGE_ADDRESS_PROVIDER;\n    address private immutable CURVE_EXCHANGE_WETH_TOKEN;\n\n    constructor(address _addressProvider, address _wethToken) public {\n        CURVE_EXCHANGE_ADDRESS_PROVIDER = _addressProvider;\n        CURVE_EXCHANGE_WETH_TOKEN = _wethToken;\n    }\n\n    /// @dev Helper to execute takeOrder\n    function __curveTakeOrder(\n        address _recipient,\n        address _pool,\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount,\n        address _incomingAsset,\n        uint256 _minIncomingAssetAmount\n    ) internal {\n        address swaps = ICurveAddressProvider(CURVE_EXCHANGE_ADDRESS_PROVIDER).get_address(2);\n\n        if (_outgoingAsset == CURVE_EXCHANGE_WETH_TOKEN) {\n            IWETH(CURVE_EXCHANGE_WETH_TOKEN).withdraw(_outgoingAssetAmount);\n\n            ICurveSwapsEther(swaps).exchange{value: _outgoingAssetAmount}(\n                _pool,\n                CURVE_EXCHANGE_ETH_ADDRESS,\n                _incomingAsset,\n                _outgoingAssetAmount,\n                _minIncomingAssetAmount,\n                _recipient\n            );\n        } else if (_incomingAsset == CURVE_EXCHANGE_WETH_TOKEN) {\n            __approveAssetMaxAsNeeded(_outgoingAsset, swaps, _outgoingAssetAmount);\n\n            ICurveSwapsERC20(swaps).exchange(\n                _pool,\n                _outgoingAsset,\n                CURVE_EXCHANGE_ETH_ADDRESS,\n                _outgoingAssetAmount,\n                _minIncomingAssetAmount,\n                address(this)\n            );\n\n            // Wrap received ETH and send back to the recipient\n            uint256 receivedAmount = payable(address(this)).balance;\n            IWETH(payable(CURVE_EXCHANGE_WETH_TOKEN)).deposit{value: receivedAmount}();\n            ERC20(CURVE_EXCHANGE_WETH_TOKEN).safeTransfer(_recipient, receivedAmount);\n        } else {\n            __approveAssetMaxAsNeeded(_outgoingAsset, swaps, _outgoingAssetAmount);\n\n            ICurveSwapsERC20(swaps).exchange(\n                _pool,\n                _outgoingAsset,\n                _incomingAsset,\n                _outgoingAssetAmount,\n                _minIncomingAssetAmount,\n                _recipient\n            );\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `CURVE_EXCHANGE_ADDRESS_PROVIDER` variable\n    /// @return curveExchangeAddressProvider_ The `CURVE_EXCHANGE_ADDRESS_PROVIDER` variable value\n    function getCurveExchangeAddressProvider()\n        public\n        view\n        returns (address curveExchangeAddressProvider_)\n    {\n        return CURVE_EXCHANGE_ADDRESS_PROVIDER;\n    }\n\n    /// @notice Gets the `CURVE_EXCHANGE_WETH_TOKEN` variable\n    /// @return curveExchangeWethToken_ The `CURVE_EXCHANGE_WETH_TOKEN` variable value\n    function getCurveExchangeWethToken() public view returns (address curveExchangeWethToken_) {\n        return CURVE_EXCHANGE_WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/release/interfaces/ICurveSwapsERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveSwapsERC20 Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveSwapsERC20 {\n    function exchange(\n        address,\n        address,\n        address,\n        uint256,\n        uint256,\n        address\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/ICurveSwapsEther.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ICurveSwapsEther Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ICurveSwapsEther {\n    function exchange(\n        address,\n        address,\n        address,\n        uint256,\n        uint256,\n        address\n    ) external payable returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/CurveExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../utils/actions/CurveExchangeActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title CurveExchangeAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for swapping assets on Curve <https://www.curve.fi/>\ncontract CurveExchangeAdapter is AdapterBase, CurveExchangeActionsMixin {\n    constructor(\n        address _integrationManager,\n        address _addressProvider,\n        address _wethToken\n    )\n        public\n        AdapterBase(_integrationManager)\n        CurveExchangeActionsMixin(_addressProvider, _wethToken)\n    {}\n\n    /// @dev Needed to receive ETH from swap and to unwrap WETH\n    receive() external payable {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Trades assets on Curve\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address pool,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            address incomingAsset,\n            uint256 minIncomingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        __curveTakeOrder(\n            _vaultProxy,\n            pool,\n            outgoingAsset,\n            outgoingAssetAmount,\n            incomingAsset,\n            minIncomingAssetAmount\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n        (\n            address pool,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            address incomingAsset,\n            uint256 minIncomingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        require(pool != address(0), \"parseAssetsForAction: No pool address provided\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = outgoingAsset;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = incomingAsset;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode the take order encoded call arguments\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address pool_,\n            address outgoingAsset_,\n            uint256 outgoingAssetAmount_,\n            address incomingAsset_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, address, uint256, address, uint256));\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/YearnVaultV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IYearnVaultV2.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title YearnVaultV2ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with Yearn v2 vaults\nabstract contract YearnVaultV2ActionsMixin is AssetHelpers {\n    /// @dev Helper to lend underlying for yVault shares\n    function __yearnVaultV2Lend(\n        address _recipient,\n        address _yVault,\n        address _underlying,\n        uint256 _underlyingAmount\n    ) internal {\n        console.log(\"__yearnVaultV2Lend :recipient:%s\", _recipient);\n        console.log(\"__yearnVaultV2Lend :_yVault:%s\", _yVault);\n        console.log(\"__yearnVaultV2Lend :_underlying:%s\", _underlying);\n        console.log(\"__yearnVaultV2Lend :_underlyingAmount:%d\", _underlyingAmount);\n\n        __approveAssetMaxAsNeeded(_underlying, _yVault, _underlyingAmount);\n        console.log(\"__yearnVaultV2Lend after approve\");\n\n        uint256 availableDepositLimit = IYearnVaultV2(_yVault).availableDepositLimit();\n        console.log(\"__yearnVaultV2Lend :availableDepositLimit:%d\", availableDepositLimit);\n        uint256 pricePerShare = IYearnVaultV2(_yVault).pricePerShare();\n        console.log(\"__yearnVaultV2Lend :pricePerShare:%d\", pricePerShare);\n        address token = IYearnVaultV2(_yVault).token();\n        console.log(\"__yearnVaultV2Lend :token:%s\", token);\n\n        IYearnVaultV2(_yVault).deposit(_underlyingAmount, _recipient);\n        console.log(\"__yearnVaultV2Lend after deposit\");\n    }\n\n    /// @dev Helper to redeem yVault shares for underlying\n    function __yearnVaultV2Redeem(\n        address _recipient,\n        address _yVault,\n        uint256 _yVaultSharesAmount,\n        uint256 _slippageToleranceBps\n    ) internal {\n        IYearnVaultV2(_yVault).withdraw(_yVaultSharesAmount, _recipient, _slippageToleranceBps);\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/YearnVaultV2Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../infrastructure/price-feeds/derivatives/feeds/YearnVaultV2PriceFeed.sol\";\nimport \"../utils/actions/YearnVaultV2ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title YearnVaultV2Adapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with Yearn v2 vaults\ncontract YearnVaultV2Adapter is AdapterBase, YearnVaultV2ActionsMixin {\n    address private immutable YEARN_VAULT_V2_PRICE_FEED;\n\n    constructor(address _integrationManager, address _yearnVaultV2PriceFeed)\n        public\n        AdapterBase(_integrationManager)\n    {\n        YEARN_VAULT_V2_PRICE_FEED = _yearnVaultV2PriceFeed;\n    }\n\n    /// @notice Deposits an amount of an underlying asset into its corresponding yVault\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    /// @dev Using postActionSpendAssetsTransferHandler is probably overkill, but since new\n    /// yVault v2 contracts can update logic, this protects against a future implementation in\n    /// which a partial underlying deposit amount is used if the desired amount exceeds the\n    /// deposit limit, for example.\n    function lend(\n        address _vaultProxy,\n        bytes calldata,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionSpendAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        // More efficient to parse all from _assetData\n        (\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts,\n            address[] memory incomingAssets\n        ) = __decodeAssetData(_assetData);\n        console.log(\"lend underlying:\");\n\n        __yearnVaultV2Lend(_vaultProxy, incomingAssets[0], spendAssets[0], spendAssetAmounts[0]);\n    }\n\n    /// @notice Redeems an amount of yVault shares for its underlying asset\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    /// @dev The amount of yVault shares to be redeemed can be adjusted in yVault.withdraw()\n    /// depending on the available underlying balance, so we must send unredeemed yVault shares\n    /// back to the _vaultProxy\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    )\n        external\n        onlyIntegrationManager\n        postActionSpendAssetsTransferHandler(_vaultProxy, _assetData)\n    {\n        (\n            address yVault,\n            uint256 maxOutgoingYVaultSharesAmount,\n            ,\n            uint256 slippageToleranceBps\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        __yearnVaultV2Redeem(\n            _vaultProxy,\n            yVault,\n            maxOutgoingYVaultSharesAmount,\n            slippageToleranceBps\n        );\n    }\n\n    /// @dev Helper to get the underlying for a given Yearn Vault\n    function __getUnderlyingForYVault(address _yVault) private view returns (address underlying_) {\n        return\n            YearnVaultV2PriceFeed(getYearnVaultV2PriceFeed()).getUnderlyingForDerivative(_yVault);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address yVault,\n            uint256 outgoingUnderlyingAmount,\n            uint256 minIncomingYVaultSharesAmount\n        ) = __decodeLendCallArgs(_actionData);\n        console.log(\"__parseAssetsForLend started\");\n        console.log(\"__parseAssetsForLend yVault:%s\", yVault);\n        console.log(\"__parseAssetsForLend outgoingUnderlyingAmount:%d\", outgoingUnderlyingAmount);\n        console.log(\n            \"__parseAssetsForLend minIncomingYVaultSharesAmount:%d\",\n            minIncomingYVaultSharesAmount\n        );\n\n        address underlying = __getUnderlyingForYVault(yVault);\n        require(underlying != address(0), \"__parseAssetsForLend: Unsupported yVault\");\n        console.log(\"__parseAssetsForLend underlying:%s\", underlying);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = underlying;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingUnderlyingAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = yVault;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingYVaultSharesAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address yVault,\n            uint256 maxOutgoingYVaultSharesAmount,\n            uint256 minIncomingUnderlyingAmount,\n\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        address underlying = __getUnderlyingForYVault(yVault);\n        require(underlying != address(0), \"__parseAssetsForRedeem: Unsupported yVault\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = yVault;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = maxOutgoingYVaultSharesAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = underlying;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingUnderlyingAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    ///////////////////////\n    // ENCODED CALL ARGS //\n    ///////////////////////\n\n    /// @dev Helper to decode callArgs for lending\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address yVault_,\n            uint256 outgoingUnderlyingAmount_,\n            uint256 minIncomingYVaultSharesAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, uint256));\n    }\n\n    /// @dev Helper to decode callArgs for redeeming\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address yVault_,\n            uint256 maxOutgoingYVaultSharesAmount_,\n            uint256 minIncomingUnderlyingAmount_,\n            uint256 slippageToleranceBps_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, uint256, uint256));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `YEARN_VAULT_V2_PRICE_FEED` variable\n    /// @return yearnVaultV2PriceFeed_ The `YEARN_VAULT_V2_PRICE_FEED` variable value\n    function getYearnVaultV2PriceFeed() public view returns (address yearnVaultV2PriceFeed_) {\n        return YEARN_VAULT_V2_PRICE_FEED;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/UniswapV3ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../../../../../interfaces/IUniswapV3SwapRouter.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title UniswapV3ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with Uniswap v3\nabstract contract UniswapV3ActionsMixin is AssetHelpers {\n    address private immutable UNISWAP_V3_ROUTER;\n\n    constructor(address _router) public {\n        UNISWAP_V3_ROUTER = _router;\n    }\n\n    /// @dev Helper to execute a swap\n    // UniswapV3 paths are packed encoded as (address(_pathAddresses[i]), uint24(_pathFees[i]), address(_pathAddresses[i + 1]), [...])\n    // _pathFees[i] represents the fee for the pool between _pathAddresses(i) and _pathAddresses(i+1)\n    function __uniswapV3Swap(\n        address _recipient,\n        address[] memory _pathAddresses,\n        uint24[] memory _pathFees,\n        uint256 _outgoingAssetAmount,\n        uint256 _minIncomingAssetAmount\n    ) internal {\n        __approveAssetMaxAsNeeded(_pathAddresses[0], UNISWAP_V3_ROUTER, _outgoingAssetAmount);\n\n        bytes memory encodedPath;\n\n        for (uint256 i; i < _pathAddresses.length; i++) {\n            if (i != _pathAddresses.length - 1) {\n                encodedPath = abi.encodePacked(encodedPath, _pathAddresses[i], _pathFees[i]);\n            } else {\n                encodedPath = abi.encodePacked(encodedPath, _pathAddresses[i]);\n            }\n        }\n\n        IUniswapV3SwapRouter.ExactInputParams memory input = IUniswapV3SwapRouter\n            .ExactInputParams({\n            path: encodedPath,\n            recipient: _recipient,\n            deadline: block.timestamp + 1,\n            amountIn: _outgoingAssetAmount,\n            amountOutMinimum: _minIncomingAssetAmount\n        });\n\n        // Execute fill\n        IUniswapV3SwapRouter(UNISWAP_V3_ROUTER).exactInput(input);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `UNISWAP_V3_ROUTER` variable\n    /// @return router_ The `UNISWAP_V3_ROUTER` variable value\n    function getUniswapV3Router() public view returns (address router_) {\n        return UNISWAP_V3_ROUTER;\n    }\n}\n"
    },
    "contracts/release/interfaces/IUniswapV3SwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title IUniswapV3Router Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev Minimal interface for our interactions with Uniswap V3's Router\ninterface IUniswapV3SwapRouter {\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    function exactInput(ExactInputParams calldata) external payable returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/UniswapV3Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/actions/UniswapV3ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title UniswapV3SwapAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with UniswapV3 swaps\ncontract UniswapV3Adapter is AdapterBase, UniswapV3ActionsMixin {\n    constructor(address _integrationManager, address _router)\n        public\n        AdapterBase(_integrationManager)\n        UniswapV3ActionsMixin(_router)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Trades assets on UniswapV3\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address[] memory pathAddresses,\n            uint24[] memory pathFees,\n            uint256 outgoingAssetAmount,\n            uint256 minIncomingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        __uniswapV3Swap(\n            _vaultProxy,\n            pathAddresses,\n            pathFees,\n            outgoingAssetAmount,\n            minIncomingAssetAmount\n        );\n    }\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        (\n            address[] memory pathAddresses,\n            uint24[] memory pathFees,\n            uint256 outgoingAssetAmount,\n            uint256 minIncomingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        require(pathAddresses.length >= 2, \"parseAssetsForAction: pathAddresses must be >= 2\");\n        require(\n            pathAddresses.length == pathFees.length + 1,\n            \"parseAssetsForAction: incorrect pathAddresses or pathFees length\"\n        );\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = pathAddresses[0];\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = pathAddresses[pathAddresses.length - 1];\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper to decode the encoded callOnIntegration call arguments\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address[] memory pathAddresses,\n            uint24[] memory pathFees,\n            uint256 outgoingAssetAmount,\n            uint256 minIncomingAssetAmount\n        )\n    {\n        return abi.decode(_actionData, (address[], uint24[], uint256, uint256));\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/UniswapV2ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IUniswapV2Router2.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title UniswapV2ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with Uniswap v2\nabstract contract UniswapV2ActionsMixin is AssetHelpers {\n    address private immutable UNISWAP_V2_ROUTER2;\n\n    constructor(address _router) public {\n        UNISWAP_V2_ROUTER2 = _router;\n    }\n\n    /// @dev Helper to add liquidity\n    function __uniswapV2Lend(\n        address _recipient,\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountADesired,\n        uint256 _amountBDesired,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal {\n        __approveAssetMaxAsNeeded(_tokenA, UNISWAP_V2_ROUTER2, _amountADesired);\n        __approveAssetMaxAsNeeded(_tokenB, UNISWAP_V2_ROUTER2, _amountBDesired);\n\n        // Execute lend on Uniswap\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).addLiquidity(\n            _tokenA,\n            _tokenB,\n            _amountADesired,\n            _amountBDesired,\n            _amountAMin,\n            _amountBMin,\n            _recipient,\n            __uniswapV2GetActionDeadline()\n        );\n    }\n\n    /// @dev Helper to remove liquidity\n    function __uniswapV2Redeem(\n        address _recipient,\n        address _poolToken,\n        uint256 _poolTokenAmount,\n        address _tokenA,\n        address _tokenB,\n        uint256 _amountAMin,\n        uint256 _amountBMin\n    ) internal {\n        __approveAssetMaxAsNeeded(_poolToken, UNISWAP_V2_ROUTER2, _poolTokenAmount);\n\n        // Execute redeem on Uniswap\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).removeLiquidity(\n            _tokenA,\n            _tokenB,\n            _poolTokenAmount,\n            _amountAMin,\n            _amountBMin,\n            _recipient,\n            __uniswapV2GetActionDeadline()\n        );\n    }\n\n    /// @dev Helper to execute a swap\n    function __uniswapV2Swap(\n        address _recipient,\n        uint256 _outgoingAssetAmount,\n        uint256 _minIncomingAssetAmount,\n        address[] memory _path\n    ) internal {\n        __approveAssetMaxAsNeeded(_path[0], UNISWAP_V2_ROUTER2, _outgoingAssetAmount);\n\n        // Execute fill\n        IUniswapV2Router2(UNISWAP_V2_ROUTER2).swapExactTokensForTokens(\n            _outgoingAssetAmount,\n            _minIncomingAssetAmount,\n            _path,\n            _recipient,\n            __uniswapV2GetActionDeadline()\n        );\n    }\n\n    /// @dev Helper to swap many assets to a single target asset.\n    /// The intermediary asset will generally be WETH, and though we could make it\n    // per-outgoing asset, seems like overkill until there is a need.\n    function __uniswapV2SwapManyToOne(\n        address _recipient,\n        address[] memory _outgoingAssets,\n        uint256[] memory _outgoingAssetAmounts,\n        address _incomingAsset,\n        address _intermediaryAsset\n    ) internal {\n        bool noIntermediary = _intermediaryAsset == address(0) ||\n            _intermediaryAsset == _incomingAsset;\n        for (uint256 i; i < _outgoingAssets.length; i++) {\n            // Skip cases where outgoing and incoming assets are the same, or\n            // there is no specified outgoing asset or amount\n            if (\n                _outgoingAssetAmounts[i] == 0 ||\n                _outgoingAssets[i] == address(0) ||\n                _outgoingAssets[i] == _incomingAsset\n            ) {\n                continue;\n            }\n\n            address[] memory uniswapPath;\n            if (noIntermediary || _outgoingAssets[i] == _intermediaryAsset) {\n                uniswapPath = new address[](2);\n                uniswapPath[0] = _outgoingAssets[i];\n                uniswapPath[1] = _incomingAsset;\n            } else {\n                uniswapPath = new address[](3);\n                uniswapPath[0] = _outgoingAssets[i];\n                uniswapPath[1] = _intermediaryAsset;\n                uniswapPath[2] = _incomingAsset;\n            }\n\n            __uniswapV2Swap(_recipient, _outgoingAssetAmounts[i], 1, uniswapPath);\n        }\n    }\n\n    /// @dev Helper to get the deadline for a Uniswap V2 action in a standardized way\n    function __uniswapV2GetActionDeadline() private view returns (uint256 deadline_) {\n        return block.timestamp + 1;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `UNISWAP_V2_ROUTER2` variable\n    /// @return router_ The `UNISWAP_V2_ROUTER2` variable value\n    function getUniswapV2Router2() public view returns (address router_) {\n        return UNISWAP_V2_ROUTER2;\n    }\n}\n"
    },
    "contracts/release/interfaces/IUniswapV2Router2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title UniswapV2Router2 Interface\n/// @author Enzyme Council <security@enzyme.finance>\n/// @dev Minimal interface for our interactions with Uniswap V2's Router2\ninterface IUniswapV2Router2 {\n    function addLiquidity(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        uint256\n    )\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function removeLiquidity(\n        address,\n        address,\n        uint256,\n        uint256,\n        uint256,\n        address,\n        uint256\n    ) external returns (uint256, uint256);\n\n    function swapExactTokensForTokens(\n        uint256,\n        uint256,\n        address[] calldata,\n        address,\n        uint256\n    ) external returns (uint256[] memory);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/UniswapV2LiquidityAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../interfaces/IUniswapV2Factory.sol\";\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title UniswapV2LiquidityAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with Uniswap v2 liquidity provision\ncontract UniswapV2LiquidityAdapter is AdapterBase, UniswapV2ActionsMixin {\n    address private immutable FACTORY;\n\n    constructor(\n        address _integrationManager,\n        address _router,\n        address _factory\n    ) public AdapterBase(_integrationManager) UniswapV2ActionsMixin(_router) {\n        FACTORY = _factory;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Lends assets for pool tokens on Uniswap\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function lend(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address[2] memory outgoingAssets,\n            uint256[2] memory maxOutgoingAssetAmounts,\n            uint256[2] memory minOutgoingAssetAmounts,\n\n        ) = __decodeLendCallArgs(_actionData);\n\n        __uniswapV2Lend(\n            _vaultProxy,\n            outgoingAssets[0],\n            outgoingAssets[1],\n            maxOutgoingAssetAmounts[0],\n            maxOutgoingAssetAmounts[1],\n            minOutgoingAssetAmounts[0],\n            minOutgoingAssetAmounts[1]\n        );\n    }\n\n    /// @notice Redeems pool tokens on Uniswap\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @param _assetData Parsed spend assets and incoming assets data for this action\n    function redeem(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata _assetData\n    ) external onlyIntegrationManager {\n        (\n            uint256 outgoingAssetAmount,\n            address[2] memory incomingAssets,\n            uint256[2] memory minIncomingAssetAmounts\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        // More efficient to parse pool token from _assetData than external call\n        (address[] memory spendAssets, , ) = __decodeAssetData(_assetData);\n\n        __uniswapV2Redeem(\n            _vaultProxy,\n            spendAssets[0],\n            outgoingAssetAmount,\n            incomingAssets[0],\n            incomingAssets[1],\n            minIncomingAssetAmounts[0],\n            minIncomingAssetAmounts[1]\n        );\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        if (_selector == LEND_SELECTOR) {\n            return __parseAssetsForLend(_actionData);\n        } else if (_selector == REDEEM_SELECTOR) {\n            return __parseAssetsForRedeem(_actionData);\n        }\n\n        revert(\"parseAssetsForAction: _selector invalid\");\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during lend() calls\n    function __parseAssetsForLend(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address[2] memory outgoingAssets,\n            uint256[2] memory maxOutgoingAssetAmounts,\n            ,\n            uint256 minIncomingAssetAmount\n        ) = __decodeLendCallArgs(_actionData);\n\n        spendAssets_ = new address[](2);\n        spendAssets_[0] = outgoingAssets[0];\n        spendAssets_[1] = outgoingAssets[1];\n\n        spendAssetAmounts_ = new uint256[](2);\n        spendAssetAmounts_[0] = maxOutgoingAssetAmounts[0];\n        spendAssetAmounts_[1] = maxOutgoingAssetAmounts[1];\n\n        incomingAssets_ = new address[](1);\n        // No need to validate not address(0), this will be caught in IntegrationManager\n        incomingAssets_[0] = IUniswapV2Factory(FACTORY).getPair(\n            outgoingAssets[0],\n            outgoingAssets[1]\n        );\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during redeem() calls\n    function __parseAssetsForRedeem(bytes calldata _actionData)\n        private\n        view\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            uint256 outgoingAssetAmount,\n            address[2] memory incomingAssets,\n            uint256[2] memory minIncomingAssetAmounts\n        ) = __decodeRedeemCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        // No need to validate not address(0), this will be caught in IntegrationManager\n        spendAssets_[0] = IUniswapV2Factory(FACTORY).getPair(incomingAssets[0], incomingAssets[1]);\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](2);\n        incomingAssets_[0] = incomingAssets[0];\n        incomingAssets_[1] = incomingAssets[1];\n\n        minIncomingAssetAmounts_ = new uint256[](2);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmounts[0];\n        minIncomingAssetAmounts_[1] = minIncomingAssetAmounts[1];\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode the lend encoded call arguments\n    function __decodeLendCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address[2] memory outgoingAssets_,\n            uint256[2] memory maxOutgoingAssetAmounts_,\n            uint256[2] memory minOutgoingAssetAmounts_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (address[2], uint256[2], uint256[2], uint256));\n    }\n\n    /// @dev Helper to decode the redeem encoded call arguments\n    function __decodeRedeemCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 outgoingAssetAmount_,\n            address[2] memory incomingAssets_,\n            uint256[2] memory minIncomingAssetAmounts_\n        )\n    {\n        return abi.decode(_actionData, (uint256, address[2], uint256[2]));\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `FACTORY` variable\n    /// @return factory_ The `FACTORY` variable value\n    function getFactory() external view returns (address factory_) {\n        return FACTORY;\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/UniswapV2ExchangeAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../utils/actions/UniswapV2ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title UniswapV2ExchangeAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with Uniswap v2 swaps\ncontract UniswapV2ExchangeAdapter is AdapterBase, UniswapV2ActionsMixin {\n    constructor(address _integrationManager, address _router)\n        public\n        AdapterBase(_integrationManager)\n        UniswapV2ActionsMixin(_router)\n    {}\n\n    /// @notice Trades assets on Uniswap\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address[] memory path,\n            uint256 outgoingAssetAmount,\n            uint256 minIncomingAssetAmount\n        ) = __decodeTakeOrderCallArgs(_actionData);\n\n        __uniswapV2Swap(_vaultProxy, outgoingAssetAmount, minIncomingAssetAmount, path);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        return __parseAssetsForTakeOrder(_actionData);\n    }\n\n    /// @dev Helper function to parse spend and incoming assets from encoded call args\n    /// during takeOrder() calls\n    function __parseAssetsForTakeOrder(bytes calldata _actionData)\n        private\n        pure\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        (\n            address[] memory path,\n            uint256 outgoingAssetAmount,\n            uint256 minIncomingAssetAmount\n        ) = __decodeTakeOrderCallArgs(_actionData);\n\n        require(path.length >= 2, \"__parseAssetsForTakeOrder: _path must be >= 2\");\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = path[0];\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = path[path.length - 1];\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode the take order encoded call arguments\n    function __decodeTakeOrderCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address[] memory path_,\n            uint256 outgoingAssetAmount_,\n            uint256 minIncomingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (address[], uint256, uint256));\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/SynthetixActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol\";\nimport \"../../../../../interfaces/ISynthetix.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title SynthetixActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with the Synthetix exchange functions\nabstract contract SynthetixActionsMixin is AssetHelpers {\n    address private immutable SYNTHETIX;\n    address private immutable SYNTHETIX_ORIGINATOR;\n    address private immutable SYNTHETIX_PRICE_FEED;\n    bytes32 private immutable SYNTHETIX_TRACKING_CODE;\n\n    constructor(\n        address _priceFeed,\n        address _originator,\n        address _synthetix,\n        bytes32 _trackingCode\n    ) public {\n        SYNTHETIX_PRICE_FEED = _priceFeed;\n        SYNTHETIX_ORIGINATOR = _originator;\n        SYNTHETIX = _synthetix;\n        SYNTHETIX_TRACKING_CODE = _trackingCode;\n    }\n\n    /// @dev Helper to execute takeOrder\n    function __synthetixTakeOrder(\n        address _recipient,\n        address _outgoingAsset,\n        uint256 _outgoingAssetAmount,\n        address _incomingAsset\n    ) internal {\n        address[] memory synths = new address[](2);\n        synths[0] = _outgoingAsset;\n        synths[1] = _incomingAsset;\n\n        bytes32[] memory currencyKeys = SynthetixPriceFeed(SYNTHETIX_PRICE_FEED)\n            .getCurrencyKeysForSynths(synths);\n\n        ISynthetix(SYNTHETIX).exchangeOnBehalfWithTracking(\n            _recipient,\n            currencyKeys[0],\n            _outgoingAssetAmount,\n            currencyKeys[1],\n            SYNTHETIX_ORIGINATOR,\n            SYNTHETIX_TRACKING_CODE\n        );\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `SYNTHETIX` variable\n    /// @return synthetix_ The `SYNTHETIX` variable value\n    function getSynthetix() public view returns (address synthetix_) {\n        return SYNTHETIX;\n    }\n\n    /// @notice Gets the `SYNTHETIX_ORIGINATOR` variable\n    /// @return synthetixOriginator_ The `SYNTHETIX_ORIGINATOR` variable value\n    function getSynthetixOriginator() public view returns (address synthetixOriginator_) {\n        return SYNTHETIX_ORIGINATOR;\n    }\n\n    /// @notice Gets the `SYNTHETIX_PRICE_FEED` variable\n    /// @return synthetixPriceFeed_ The `SYNTHETIX_PRICE_FEED` variable value\n    function getSynthetixPriceFeed() public view returns (address synthetixPriceFeed_) {\n        return SYNTHETIX_PRICE_FEED;\n    }\n\n    /// @notice Gets the `SYNTHETIX_TRACKING_CODE` variable\n    /// @return synthetixTrackingCode_ The `SYNTHETIX_TRACKING_CODE` variable value\n    function getSynthetixTrackingCode() public view returns (bytes32 synthetixTrackingCode_) {\n        return SYNTHETIX_TRACKING_CODE;\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/SynthetixPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../interfaces/ISynthetix.sol\";\nimport \"../../../../interfaces/ISynthetixAddressResolver.sol\";\nimport \"../../../../interfaces/ISynthetixExchangeRates.sol\";\nimport \"../../../../interfaces/ISynthetixProxyERC20.sol\";\nimport \"../../../../interfaces/ISynthetixSynth.sol\";\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../IDerivativePriceFeed.sol\";\n\n/// @title SynthetixPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A price feed that uses Synthetix oracles as price sources\ncontract SynthetixPriceFeed is IDerivativePriceFeed, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event SynthAdded(address indexed synth, bytes32 currencyKey);\n\n    event SynthRemoved(address indexed synth, bytes32 currencyKey);\n\n    uint256 private constant SYNTH_UNIT = 10**18;\n    address private immutable ADDRESS_RESOLVER;\n    address private immutable SUSD;\n\n    mapping(address => bytes32) private synthToCurrencyKey;\n\n    constructor(\n        address _fundDeployer,\n        address _addressResolver,\n        address _sUSD\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        ADDRESS_RESOLVER = _addressResolver;\n        SUSD = _sUSD;\n    }\n\n    /// @notice Converts a given amount of a derivative to its underlying asset values\n    /// @param _derivative The derivative to convert\n    /// @param _derivativeAmount The amount of the derivative to convert\n    /// @return underlyings_ The underlying assets for the _derivative\n    /// @return underlyingAmounts_ The amount of each underlying asset for the equivalent derivative amount\n    function calcUnderlyingValues(address _derivative, uint256 _derivativeAmount)\n        external\n        override\n        returns (address[] memory underlyings_, uint256[] memory underlyingAmounts_)\n    {\n        underlyings_ = new address[](1);\n        underlyings_[0] = getSUSD();\n        underlyingAmounts_ = new uint256[](1);\n\n        bytes32 currencyKey = getCurrencyKeyForSynth(_derivative);\n        require(currencyKey != 0, \"calcUnderlyingValues: _derivative is not supported\");\n\n        address exchangeRates = ISynthetixAddressResolver(getAddressResolver())\n            .requireAndGetAddress(\"ExchangeRates\", \"calcUnderlyingValues: Missing ExchangeRates\");\n\n        (uint256 rate, bool isInvalid) = ISynthetixExchangeRates(exchangeRates).rateAndInvalid(\n            currencyKey\n        );\n        require(!isInvalid, \"calcUnderlyingValues: _derivative rate is not valid\");\n\n        underlyingAmounts_[0] = _derivativeAmount.mul(rate).div(SYNTH_UNIT);\n\n        return (underlyings_, underlyingAmounts_);\n    }\n\n    /// @notice Checks whether an asset is a supported primitive of the price feed\n    /// @param _asset The asset to check\n    /// @return isSupported_ True if the asset is a supported primitive\n    function isSupportedAsset(address _asset) public view override returns (bool isSupported_) {\n        return getCurrencyKeyForSynth(_asset) != 0;\n    }\n\n    /////////////////////\n    // SYNTHS REGISTRY //\n    /////////////////////\n\n    /// @notice Adds Synths to the price feed\n    /// @param _synths Synths to add\n    function addSynths(address[] calldata _synths) external onlyFundDeployerOwner {\n        for (uint256 i; i < _synths.length; i++) {\n            require(getCurrencyKeyForSynth(_synths[i]) == 0, \"addSynths: Value already set\");\n\n            bytes32 currencyKey = __getCanonicalCurrencyKey(_synths[i]);\n            require(currencyKey != 0, \"addSynths: No currencyKey\");\n\n            synthToCurrencyKey[_synths[i]] = currencyKey;\n\n            emit SynthAdded(_synths[i], currencyKey);\n        }\n    }\n\n    /// @notice Removes Synths from the price feed\n    /// @param _synths Synths to remove\n    /// @dev Removing Synths from this feed will also affect the AssetFinalityResolver,\n    /// as this contract is its shortcut determining whether assets are Synths\n    function removeSynths(address[] calldata _synths) external onlyFundDeployerOwner {\n        for (uint256 i; i < _synths.length; i++) {\n            bytes32 currencyKey = getCurrencyKeyForSynth(_synths[i]);\n            require(currencyKey != 0, \"removeSynths: Synth not set\");\n\n            delete synthToCurrencyKey[_synths[i]];\n\n            emit SynthRemoved(_synths[i], currencyKey);\n        }\n    }\n\n    /// @dev Helper to query a currencyKey from Synthetix\n    function __getCanonicalCurrencyKey(address _synthProxy)\n        private\n        view\n        returns (bytes32 currencyKey_)\n    {\n        return ISynthetixSynth(ISynthetixProxyERC20(_synthProxy).target()).currencyKey();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Gets the currencyKey for multiple given Synths\n    /// @return currencyKeys_ The currencyKey values\n    function getCurrencyKeysForSynths(address[] calldata _synths)\n        external\n        view\n        returns (bytes32[] memory currencyKeys_)\n    {\n        currencyKeys_ = new bytes32[](_synths.length);\n        for (uint256 i; i < _synths.length; i++) {\n            currencyKeys_[i] = getCurrencyKeyForSynth(_synths[i]);\n        }\n\n        return currencyKeys_;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the `ADDRESS_RESOLVER` variable\n    /// @return addressResolver_ The `ADDRESS_RESOLVER` variable value\n    function getAddressResolver() public view returns (address) {\n        return ADDRESS_RESOLVER;\n    }\n\n    /// @notice Gets the currencyKey for a given Synth\n    /// @return currencyKey_ The currencyKey value\n    function getCurrencyKeyForSynth(address _synth) public view returns (bytes32 currencyKey_) {\n        return synthToCurrencyKey[_synth];\n    }\n\n    /// @notice Gets the `SUSD` variable\n    /// @return susd_ The `SUSD` variable value\n    function getSUSD() public view returns (address susd_) {\n        return SUSD;\n    }\n}\n"
    },
    "contracts/release/interfaces/ISynthetix.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetix Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetix {\n    function exchangeOnBehalfWithTracking(\n        address,\n        bytes32,\n        uint256,\n        bytes32,\n        address,\n        bytes32\n    ) external returns (uint256);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixAddressResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixAddressResolver Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixAddressResolver {\n    function requireAndGetAddress(bytes32, string calldata) external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixExchangeRates.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixExchangeRates Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixExchangeRates {\n    function rateAndInvalid(bytes32) external view returns (uint256, bool);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixProxyERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixProxyERC20 Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixProxyERC20 {\n    function target() external view returns (address);\n}\n"
    },
    "contracts/release/interfaces/ISynthetixSynth.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixSynth Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixSynth {\n    function currencyKey() external view returns (bytes32);\n}\n"
    },
    "contracts/release/infrastructure/asset-finality/AssetFinalityResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../interfaces/ISynthetixAddressResolver.sol\";\nimport \"../../interfaces/ISynthetixExchanger.sol\";\nimport \"../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../price-feeds/derivatives/feeds/SynthetixPriceFeed.sol\";\nimport \"./IAssetFinalityResolver.sol\";\n\n/// @title AssetFinalityResolver Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that helps achieve asset finality\ncontract AssetFinalityResolver is IAssetFinalityResolver, FundDeployerOwnerMixin {\n    event SynthetixPriceFeedSet(address nextSynthetixPriceFeed);\n\n    address private immutable SYNTHETIX_ADDRESS_RESOLVER;\n\n    address private synthetixPriceFeed;\n\n    constructor(\n        address _fundDeployer,\n        address _synthetixPriceFeed,\n        address _synthetixAddressResolver\n    ) public FundDeployerOwnerMixin(_fundDeployer) {\n        SYNTHETIX_ADDRESS_RESOLVER = _synthetixAddressResolver;\n        __setSynthetixPriceFeed(_synthetixPriceFeed);\n    }\n\n    /// @notice Helper to finalize asset balances according to the procedures of their protocols\n    /// @param _target The account that the assets belong to\n    /// @param _assets The assets to finalize\n    /// @dev Currently only handles Synths, and uses the SynthetixPriceFeed as a shortcut\n    /// to validate supported Synths\n    function finalizeAssets(address _target, address[] memory _assets) external override {\n        if (_assets.length == 0) {\n            return;\n        }\n\n        bytes32[] memory currencyKeys = SynthetixPriceFeed(getSynthetixPriceFeed())\n            .getCurrencyKeysForSynths(_assets);\n        address synthetixExchanger;\n        for (uint256 i; i < _assets.length; i++) {\n            if (currencyKeys[i] != 0) {\n                if (synthetixExchanger == address(0)) {\n                    synthetixExchanger = ISynthetixAddressResolver(getSynthetixAddressResolver())\n                        .requireAndGetAddress(\n                        \"Exchanger\",\n                        \"finalizeAssets: Missing Synthetix Exchanger\"\n                    );\n                }\n                ISynthetixExchanger(synthetixExchanger).settle(_target, currencyKeys[i]);\n            }\n        }\n    }\n\n    /// @notice Sets a new SynthetixPriceFeed for use within the contract\n    /// @param _nextSynthetixPriceFeed The address of the SynthetixPriceFeed contract\n    function setSynthetixPriceFeed(address _nextSynthetixPriceFeed)\n        external\n        onlyFundDeployerOwner\n    {\n        __setSynthetixPriceFeed(_nextSynthetixPriceFeed);\n    }\n\n    /// @dev Helper to set the synthetixPriceFeed\n    function __setSynthetixPriceFeed(address _nextSynthetixPriceFeed) private {\n        // Validates that the next SynthetixPriceFeed implements the required function\n        SynthetixPriceFeed(_nextSynthetixPriceFeed).getCurrencyKeysForSynths(new address[](0));\n\n        synthetixPriceFeed = _nextSynthetixPriceFeed;\n\n        emit SynthetixPriceFeedSet(_nextSynthetixPriceFeed);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `SYNTHETIX_ADDRESS_RESOLVER` variable\n    /// @return synthetixAddressResolver_ The `SYNTHETIX_ADDRESS_RESOLVER` variable value\n    function getSynthetixAddressResolver()\n        public\n        view\n        returns (address synthetixAddressResolver_)\n    {\n        return SYNTHETIX_ADDRESS_RESOLVER;\n    }\n\n    /// @notice Gets the `synthetixPriceFeed` variable\n    /// @return synthetixPriceFeed_ The `synthetixPriceFeed` variable value\n    function getSynthetixPriceFeed() public view returns (address synthetixPriceFeed_) {\n        return synthetixPriceFeed;\n    }\n}\n"
    },
    "contracts/release/interfaces/ISynthetixExchanger.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ISynthetixExchanger Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface ISynthetixExchanger {\n    function getAmountsForExchange(\n        uint256,\n        bytes32,\n        bytes32\n    )\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function settle(address, bytes32)\n        external\n        returns (\n            uint256,\n            uint256,\n            uint256\n        );\n}\n"
    },
    "contracts/release/infrastructure/asset-finality/NoOpAssetFinalityResolver.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IAssetFinalityResolver.sol\";\n\n/// @title NoOpAssetFinalityResolver Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that helps achieve asset finality\ncontract NoOpAssetFinalityResolver is IAssetFinalityResolver {\n    function finalizeAssets(address _target, address[] memory _assets) external override {}\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/SynthetixAdapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../utils/actions/SynthetixActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title SynthetixAdapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with Synthetix\ncontract SynthetixAdapter is AdapterBase, SynthetixActionsMixin {\n    constructor(\n        address _integrationManager,\n        address _synthetixPriceFeed,\n        address _originator,\n        address _synthetix,\n        bytes32 _trackingCode\n    )\n        public\n        AdapterBase(_integrationManager)\n        SynthetixActionsMixin(_synthetixPriceFeed, _originator, _synthetix, _trackingCode)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Trades assets on Synthetix\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            address incomingAsset,\n            ,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        __synthetixTakeOrder(_vaultProxy, outgoingAsset, outgoingAssetAmount, incomingAsset);\n    }\n\n    /////////////////////////////\n    // PARSE ASSETS FOR METHOD //\n    /////////////////////////////\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        (\n            address incomingAsset,\n            uint256 minIncomingAssetAmount,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount\n        ) = __decodeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = outgoingAsset;\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = incomingAsset;\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.None,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to decode the encoded call arguments\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            address incomingAsset_,\n            uint256 minIncomingAssetAmount_,\n            address outgoingAsset_,\n            uint256 outgoingAssetAmount_\n        )\n    {\n        return abi.decode(_actionData, (address, uint256, address, uint256));\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/ParaSwapV5ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IParaSwapV5AugustusSwapper.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title ParaSwapV5ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with ParaSwap (v5)\nabstract contract ParaSwapV5ActionsMixin is AssetHelpers {\n    address private immutable PARA_SWAP_V5_AUGUSTUS_SWAPPER;\n    address private immutable PARA_SWAP_V5_TOKEN_TRANSFER_PROXY;\n\n    constructor(address _augustusSwapper, address _tokenTransferProxy) public {\n        PARA_SWAP_V5_AUGUSTUS_SWAPPER = _augustusSwapper;\n        PARA_SWAP_V5_TOKEN_TRANSFER_PROXY = _tokenTransferProxy;\n    }\n\n    /// @dev Helper to execute a protectedMultiSwap() order\n    function __paraSwapV5ProtectedMultiSwap(\n        address _fromToken,\n        uint256 _fromAmount,\n        uint256 _toAmount,\n        uint256 _expectedAmount,\n        address payable _beneficiary,\n        bytes16 _uuid,\n        IParaSwapV5AugustusSwapper.Path[] memory _path\n    ) internal {\n        __approveAssetMaxAsNeeded(_fromToken, getParaSwapV5TokenTransferProxy(), _fromAmount);\n\n        IParaSwapV5AugustusSwapper.SellData memory sellData = IParaSwapV5AugustusSwapper.SellData({\n            fromToken: _fromToken,\n            fromAmount: _fromAmount,\n            toAmount: _toAmount,\n            expectedAmount: _expectedAmount,\n            beneficiary: _beneficiary,\n            path: _path,\n            partner: address(0),\n            feePercent: 0,\n            permit: \"\",\n            deadline: block.timestamp,\n            uuid: _uuid // Purely for data tracking by ParaSwap\n        });\n\n        IParaSwapV5AugustusSwapper(getParaSwapV5AugustusSwapper()).protectedMultiSwap(sellData);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `PARA_SWAP_V5_AUGUSTUS_SWAPPER` variable\n    /// @return augustusSwapper_ The `PARA_SWAP_V5_AUGUSTUS_SWAPPER` variable value\n    function getParaSwapV5AugustusSwapper() public view returns (address augustusSwapper_) {\n        return PARA_SWAP_V5_AUGUSTUS_SWAPPER;\n    }\n\n    /// @notice Gets the `PARA_SWAP_V5_TOKEN_TRANSFER_PROXY` variable\n    /// @return tokenTransferProxy_ The `PARA_SWAP_V5_TOKEN_TRANSFER_PROXY` variable value\n    function getParaSwapV5TokenTransferProxy() public view returns (address tokenTransferProxy_) {\n        return PARA_SWAP_V5_TOKEN_TRANSFER_PROXY;\n    }\n}\n"
    },
    "contracts/release/interfaces/IParaSwapV5AugustusSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title ParaSwap V5 IAugustusSwapper interface\ninterface IParaSwapV5AugustusSwapper {\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee;\n        Route[] route;\n    }\n\n    struct Route {\n        uint256 index;\n        address targetExchange;\n        uint256 percent;\n        bytes payload;\n        uint256 networkFee;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee;\n        Adapter[] adapters;\n    }\n\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    function protectedMultiSwap(SellData calldata) external payable returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/ParaSwapV5Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/actions/ParaSwapV5ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title ParaSwapV5Adapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with ParaSwap (v5)\n/// @dev Does not support any protocol that collects additional protocol fees as ETH/WETH, e.g., 0x v3\ncontract ParaSwapV5Adapter is AdapterBase, ParaSwapV5ActionsMixin {\n    constructor(\n        address _integrationManager,\n        address _augustusSwapper,\n        address _tokenTransferProxy\n    )\n        public\n        AdapterBase(_integrationManager)\n        ParaSwapV5ActionsMixin(_augustusSwapper, _tokenTransferProxy)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Trades assets on ParaSwap\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @dev ParaSwap v5 completely uses entire outgoing asset balance and incoming asset\n    /// is sent directly to the beneficiary (the _vaultProxy)\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            uint256 minIncomingAssetAmount,\n            uint256 expectedIncomingAssetAmount,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            bytes16 uuid,\n            IParaSwapV5AugustusSwapper.Path[] memory paths\n        ) = __decodeCallArgs(_actionData);\n\n        __paraSwapV5ProtectedMultiSwap(\n            outgoingAsset,\n            outgoingAssetAmount,\n            minIncomingAssetAmount,\n            expectedIncomingAssetAmount,\n            payable(_vaultProxy),\n            uuid,\n            paths\n        );\n    }\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        (\n            uint256 minIncomingAssetAmount,\n            ,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            ,\n            IParaSwapV5AugustusSwapper.Path[] memory paths\n        ) = __decodeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = outgoingAsset;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = paths[paths.length - 1].to;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper to decode the encoded callOnIntegration call arguments\n    function __decodeCallArgs(bytes calldata _actionData)\n        private\n        pure\n        returns (\n            uint256 minIncomingAssetAmount_,\n            uint256 expectedIncomingAssetAmount_, // Passed as a courtesy to ParaSwap for analytics\n            address outgoingAsset_,\n            uint256 outgoingAssetAmount_,\n            bytes16 uuid_,\n            IParaSwapV5AugustusSwapper.Path[] memory paths_\n        )\n    {\n        return\n            abi.decode(\n                _actionData,\n                (uint256, uint256, address, uint256, bytes16, IParaSwapV5AugustusSwapper.Path[])\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/utils/actions/ParaSwapV4ActionsMixin.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../interfaces/IParaSwapV4AugustusSwapper.sol\";\nimport \"../../../../../utils/AssetHelpers.sol\";\n\n/// @title ParaSwapV4ActionsMixin Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Mixin contract for interacting with ParaSwap (v4)\nabstract contract ParaSwapV4ActionsMixin is AssetHelpers {\n    string private constant REFERRER = \"enzyme\";\n\n    address private immutable PARA_SWAP_V4_AUGUSTUS_SWAPPER;\n    address private immutable PARA_SWAP_V4_TOKEN_TRANSFER_PROXY;\n\n    constructor(address _augustusSwapper, address _tokenTransferProxy) public {\n        PARA_SWAP_V4_AUGUSTUS_SWAPPER = _augustusSwapper;\n        PARA_SWAP_V4_TOKEN_TRANSFER_PROXY = _tokenTransferProxy;\n    }\n\n    /// @dev Helper to execute a multiSwap() order\n    function __paraSwapV4MultiSwap(\n        address _fromToken,\n        uint256 _fromAmount,\n        uint256 _toAmount,\n        uint256 _expectedAmount,\n        address payable _beneficiary,\n        IParaSwapV4AugustusSwapper.Path[] memory _path\n    ) internal {\n        __approveAssetMaxAsNeeded(_fromToken, PARA_SWAP_V4_TOKEN_TRANSFER_PROXY, _fromAmount);\n\n        IParaSwapV4AugustusSwapper.SellData memory sellData = IParaSwapV4AugustusSwapper.SellData({\n            fromToken: _fromToken,\n            fromAmount: _fromAmount,\n            toAmount: _toAmount,\n            expectedAmount: _expectedAmount,\n            beneficiary: _beneficiary,\n            referrer: REFERRER,\n            useReduxToken: false,\n            path: _path\n        });\n\n        IParaSwapV4AugustusSwapper(PARA_SWAP_V4_AUGUSTUS_SWAPPER).multiSwap(sellData);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `PARA_SWAP_V4_AUGUSTUS_SWAPPER` variable\n    /// @return augustusSwapper_ The `PARA_SWAP_V4_AUGUSTUS_SWAPPER` variable value\n    function getParaSwapV4AugustusSwapper() public view returns (address augustusSwapper_) {\n        return PARA_SWAP_V4_AUGUSTUS_SWAPPER;\n    }\n\n    /// @notice Gets the `PARA_SWAP_V4_TOKEN_TRANSFER_PROXY` variable\n    /// @return tokenTransferProxy_ The `PARA_SWAP_V4_TOKEN_TRANSFER_PROXY` variable value\n    function getParaSwapV4TokenTransferProxy() public view returns (address tokenTransferProxy_) {\n        return PARA_SWAP_V4_TOKEN_TRANSFER_PROXY;\n    }\n}\n"
    },
    "contracts/release/interfaces/IParaSwapV4AugustusSwapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\n/// @title ParaSwap V4 IAugustusSwapper interface\ninterface IParaSwapV4AugustusSwapper {\n    struct Route {\n        address payable exchange;\n        address targetExchange;\n        uint256 percent;\n        bytes payload;\n        uint256 networkFee;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee;\n        Route[] routes;\n    }\n\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        string referrer;\n        bool useReduxToken;\n        Path[] path;\n    }\n\n    function multiSwap(SellData calldata) external payable returns (uint256);\n}\n"
    },
    "contracts/release/extensions/integration-manager/integrations/adapters/ParaSwapV4Adapter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/actions/ParaSwapV4ActionsMixin.sol\";\nimport \"../utils/AdapterBase.sol\";\n\n/// @title ParaSwapV4Adapter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Adapter for interacting with ParaSwap (v4)\n/// @dev Does not allow any protocol that collects protocol fees in ETH, e.g., 0x v3\ncontract ParaSwapV4Adapter is AdapterBase, ParaSwapV4ActionsMixin {\n    constructor(\n        address _integrationManager,\n        address _augustusSwapper,\n        address _tokenTransferProxy\n    )\n        public\n        AdapterBase(_integrationManager)\n        ParaSwapV4ActionsMixin(_augustusSwapper, _tokenTransferProxy)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Trades assets on ParaSwap\n    /// @param _vaultProxy The VaultProxy of the calling fund\n    /// @param _actionData Data specific to this action\n    /// @dev ParaSwap v4 completely uses entire outgoing asset balance and incoming asset\n    /// is sent directly to the beneficiary (the _vaultProxy)\n    function takeOrder(\n        address _vaultProxy,\n        bytes calldata _actionData,\n        bytes calldata\n    ) external onlyIntegrationManager {\n        (\n            uint256 minIncomingAssetAmount,\n            uint256 expectedIncomingAssetAmount,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            IParaSwapV4AugustusSwapper.Path[] memory paths\n        ) = __decodeCallArgs(_actionData);\n\n        __paraSwapV4MultiSwap(\n            outgoingAsset,\n            outgoingAssetAmount,\n            minIncomingAssetAmount,\n            expectedIncomingAssetAmount,\n            payable(_vaultProxy),\n            paths\n        );\n    }\n\n    /// @notice Parses the expected assets in a particular action\n    /// @param _selector The function selector for the callOnIntegration\n    /// @param _actionData Data specific to this action\n    /// @return spendAssetsHandleType_ A type that dictates how to handle granting\n    /// the adapter access to spend assets (`None` by default)\n    /// @return spendAssets_ The assets to spend in the call\n    /// @return spendAssetAmounts_ The max asset amounts to spend in the call\n    /// @return incomingAssets_ The assets to receive in the call\n    /// @return minIncomingAssetAmounts_ The min asset amounts to receive in the call\n    function parseAssetsForAction(\n        address,\n        bytes4 _selector,\n        bytes calldata _actionData\n    )\n        external\n        view\n        override\n        returns (\n            IIntegrationManager.SpendAssetsHandleType spendAssetsHandleType_,\n            address[] memory spendAssets_,\n            uint256[] memory spendAssetAmounts_,\n            address[] memory incomingAssets_,\n            uint256[] memory minIncomingAssetAmounts_\n        )\n    {\n        require(_selector == TAKE_ORDER_SELECTOR, \"parseAssetsForAction: _selector invalid\");\n\n        (\n            uint256 minIncomingAssetAmount,\n            ,\n            address outgoingAsset,\n            uint256 outgoingAssetAmount,\n            IParaSwapV4AugustusSwapper.Path[] memory paths\n        ) = __decodeCallArgs(_actionData);\n\n        spendAssets_ = new address[](1);\n        spendAssets_[0] = outgoingAsset;\n\n        spendAssetAmounts_ = new uint256[](1);\n        spendAssetAmounts_[0] = outgoingAssetAmount;\n\n        incomingAssets_ = new address[](1);\n        incomingAssets_[0] = paths[paths.length - 1].to;\n\n        minIncomingAssetAmounts_ = new uint256[](1);\n        minIncomingAssetAmounts_[0] = minIncomingAssetAmount;\n\n        return (\n            IIntegrationManager.SpendAssetsHandleType.Transfer,\n            spendAssets_,\n            spendAssetAmounts_,\n            incomingAssets_,\n            minIncomingAssetAmounts_\n        );\n    }\n\n    /// @dev Helper to decode the encoded callOnIntegration call arguments\n    function __decodeCallArgs(bytes memory _actionData)\n        private\n        pure\n        returns (\n            uint256 minIncomingAssetAmount_,\n            uint256 expectedIncomingAssetAmount_, // Passed as a courtesy to ParaSwap for analytics\n            address outgoingAsset_,\n            uint256 outgoingAssetAmount_,\n            IParaSwapV4AugustusSwapper.Path[] memory paths_\n        )\n    {\n        return\n            abi.decode(\n                _actionData,\n                (uint256, uint256, address, uint256, IParaSwapV4AugustusSwapper.Path[])\n            );\n    }\n}\n"
    },
    "contracts/mocks/MockToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract MockToken is ERC20Burnable, Ownable {\n    using SafeMath for uint256;\n\n    mapping(address => bool) private addressToIsMinter;\n\n    modifier onlyMinter() {\n        require(\n            addressToIsMinter[msg.sender] || owner() == msg.sender,\n            \"msg.sender is not owner or minter\"\n        );\n        _;\n    }\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _decimals\n    ) public ERC20(_name, _symbol) {\n        _setupDecimals(_decimals);\n        _mint(msg.sender, uint256(100000000).mul(10**uint256(_decimals)));\n    }\n\n    function mintFor(address _who, uint256 _amount) external onlyMinter {\n        _mint(_who, _amount);\n    }\n\n    function mint(uint256 _amount) external onlyMinter {\n        _mint(msg.sender, _amount);\n    }\n\n    function addMinters(address[] memory _minters) public onlyOwner {\n        for (uint256 i = 0; i < _minters.length; i++) {\n            addressToIsMinter[_minters[i]] = true;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0 <0.8.0;\n\nimport \"../utils/Context.sol\";\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor () internal {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    },
    "contracts/mocks/MockReentrancyToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/core/fund/comptroller/ComptrollerLib.sol\";\nimport \"./MockToken.sol\";\n\n/// @title MockReentrancyToken Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mock ERC20 token implementation that is able to re-entrance redeemShares and buyShares functions\ncontract MockReentrancyToken is MockToken(\"Mock Reentrancy Token\", \"MRT\", 18) {\n    bool public bad;\n    address public comptrollerProxy;\n\n    function makeItReentracyToken(address _comptrollerProxy) external {\n        bad = true;\n        comptrollerProxy = _comptrollerProxy;\n    }\n\n    function transfer(address recipient, uint256 amount) public override returns (bool) {\n        if (bad) {\n            ComptrollerLib(comptrollerProxy).redeemSharesInKind(\n                address(this),\n                amount,\n                new address[](0),\n                new address[](0)\n            );\n        } else {\n            _transfer(_msgSender(), recipient, amount);\n        }\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public override returns (bool) {\n        if (bad) {\n            ComptrollerLib(comptrollerProxy).buyShares(0, 0);\n        } else {\n            _transfer(sender, recipient, amount);\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/release/infrastructure/price-feeds/derivatives/feeds/LidoStethPriceFeed.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/SinglePeggedDerivativePriceFeedBase.sol\";\n\n/// @title LidoStethPriceFeed Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Price source oracle for Lido stETH, which maps 1:1 with ETH (https://lido.fi/)\ncontract LidoStethPriceFeed is SinglePeggedDerivativePriceFeedBase {\n    constructor(address _steth, address _weth)\n        public\n        SinglePeggedDerivativePriceFeedBase(_steth, _weth)\n    {}\n}\n"
    },
    "contracts/release/utils/beacon-proxy/BeaconProxyFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../FundDeployerOwnerMixin.sol\";\nimport \"./BeaconProxy.sol\";\nimport \"./IBeaconProxyFactory.sol\";\n\n/// @title BeaconProxyFactory Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Factory contract that deploys beacon proxies\nabstract contract BeaconProxyFactory is IBeaconProxyFactory {\n    event CanonicalLibSet(address nextCanonicalLib);\n\n    event ProxyDeployed(address indexed caller, address proxy, bytes constructData);\n\n    address private canonicalLib;\n\n    constructor(address _canonicalLib) public {\n        __setCanonicalLib(_canonicalLib);\n    }\n\n    /// @notice Deploys a new proxy instance\n    /// @param _constructData The constructor data with which to call `init()` on the deployed proxy\n    /// @return proxy_ The proxy address\n    function deployProxy(bytes memory _constructData) external override returns (address proxy_) {\n        proxy_ = address(new BeaconProxy(_constructData, address(this)));\n\n        emit ProxyDeployed(msg.sender, proxy_, _constructData);\n\n        return proxy_;\n    }\n\n    /// @notice Gets the canonical lib used by all proxies\n    /// @return canonicalLib_ The canonical lib\n    function getCanonicalLib() public view override returns (address canonicalLib_) {\n        return canonicalLib;\n    }\n\n    /// @notice Gets the contract owner\n    /// @return owner_ The contract owner\n    function getOwner() public view virtual returns (address owner_);\n\n    /// @notice Sets the next canonical lib used by all proxies\n    /// @param _nextCanonicalLib The next canonical lib\n    function setCanonicalLib(address _nextCanonicalLib) public override {\n        require(\n            msg.sender == getOwner(),\n            \"setCanonicalLib: Only the owner can call this function\"\n        );\n\n        __setCanonicalLib(_nextCanonicalLib);\n    }\n\n    /// @dev Helper to set the next canonical lib\n    function __setCanonicalLib(address _nextCanonicalLib) private {\n        canonicalLib = _nextCanonicalLib;\n\n        emit CanonicalLibSet(_nextCanonicalLib);\n    }\n}\n"
    },
    "contracts/release/utils/beacon-proxy/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./IBeacon.sol\";\n\n/// @title BeaconProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract that uses the beacon pattern for instant upgrades\ncontract BeaconProxy {\n    address private immutable BEACON;\n\n    constructor(bytes memory _constructData, address _beacon) public {\n        BEACON = _beacon;\n\n        (bool success, bytes memory returnData) = IBeacon(_beacon).getCanonicalLib().delegatecall(\n            _constructData\n        );\n        require(success, string(returnData));\n    }\n\n    // solhint-disable-next-line no-complex-fallback\n    fallback() external payable {\n        address contractLogic = IBeacon(BEACON).getCanonicalLib();\n        assembly {\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n\n    receive() external payable {}\n}\n"
    },
    "contracts/release/infrastructure/gas-relayer/GasRelayPaymasterFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../persistent/dispatcher/IDispatcher.sol\";\nimport \"../../utils/beacon-proxy/BeaconProxyFactory.sol\";\n\n/// @title GasRelayPaymasterFactory Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Factory contract that deploys paymaster proxies for gas relaying\ncontract GasRelayPaymasterFactory is BeaconProxyFactory {\n    address private immutable DISPATCHER;\n\n    constructor(address _dispatcher, address _paymasterLib)\n        public\n        BeaconProxyFactory(_paymasterLib)\n    {\n        DISPATCHER = _dispatcher;\n    }\n\n    /// @notice Gets the contract owner\n    /// @return owner_ The contract owner\n    function getOwner() public view override returns (address owner_) {\n        return IDispatcher(getDispatcher()).getOwner();\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/bases/ProtocolFeeReserveLibBaseCore.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../dispatcher/IDispatcher.sol\";\nimport \"../utils/ProxiableProtocolFeeReserveLib.sol\";\n\n/// @title ProtocolFeeReserveLibBaseCore Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The core implementation of ProtocolFeeReserveLib\n/// @dev To be inherited by the first ProtocolFeeReserveLibBase implementation only.\n/// DO NOT EDIT CONTRACT.\nabstract contract ProtocolFeeReserveLibBaseCore is ProxiableProtocolFeeReserveLib {\n    event ProtocolFeeReserveLibSet(address nextProtocolFeeReserveLib);\n\n    address private dispatcher;\n\n    modifier onlyDispatcherOwner {\n        require(\n            msg.sender == IDispatcher(getDispatcher()).getOwner(),\n            \"Only the Dispatcher owner can call this function\"\n        );\n\n        _;\n    }\n\n    /// @notice Initializes the ProtocolFeeReserveProxy with core configuration\n    /// @param _dispatcher The Dispatcher contract\n    /// @dev Serves as a pseudo-constructor\n    function init(address _dispatcher) external {\n        require(getDispatcher() == address(0), \"init: Proxy already initialized\");\n\n        dispatcher = _dispatcher;\n\n        emit ProtocolFeeReserveLibSet(getProtocolFeeReserveLib());\n    }\n\n    /// @notice Sets the ProtocolFeeReserveLib target for the ProtocolFeeReserveProxy\n    /// @param _nextProtocolFeeReserveLib The address to set as the ProtocolFeeReserveLib\n    /// @dev This function is absolutely critical. __updateCodeAddress() validates that the\n    /// target is a valid Proxiable contract instance.\n    /// Does not block _nextProtocolFeeReserveLib from being the same as the current ProtocolFeeReserveLib\n    function setProtocolFeeReserveLib(address _nextProtocolFeeReserveLib)\n        external\n        onlyDispatcherOwner\n    {\n        __updateCodeAddress(_nextProtocolFeeReserveLib);\n\n        emit ProtocolFeeReserveLibSet(_nextProtocolFeeReserveLib);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `dispatcher` variable\n    /// @return dispatcher_ The `dispatcher` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return dispatcher;\n    }\n\n    /// @notice Gets the ProtocolFeeReserveLib target for the ProtocolFeeReserveProxy\n    /// @return protocolFeeReserveLib_ The address of the ProtocolFeeReserveLib target\n    function getProtocolFeeReserveLib() public view returns (address protocolFeeReserveLib_) {\n        assembly {\n            protocolFeeReserveLib_ := sload(EIP_1967_SLOT)\n        }\n\n        return protocolFeeReserveLib_;\n    }\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/utils/ProxiableProtocolFeeReserveLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\nimport \"./ProtocolFeeProxyConstants.sol\";\n\npragma solidity 0.6.12;\n\n/// @title ProxiableProtocolFeeReserveLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract that defines the upgrade behavior for ProtocolFeeReserveLib instances\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\n/// See: https://eips.ethereum.org/EIPS/eip-1822\n/// See: https://eips.ethereum.org/EIPS/eip-1967\nabstract contract ProxiableProtocolFeeReserveLib is ProtocolFeeProxyConstants {\n    /// @dev Updates the target of the proxy to be the contract at _nextProtocolFeeReserveLib\n    function __updateCodeAddress(address _nextProtocolFeeReserveLib) internal {\n        require(\n            ProxiableProtocolFeeReserveLib(_nextProtocolFeeReserveLib).proxiableUUID() ==\n                bytes32(EIP_1822_PROXIABLE_UUID),\n            \"__updateCodeAddress: _nextProtocolFeeReserveLib not compatible\"\n        );\n        assembly {\n            sstore(EIP_1967_SLOT, _nextProtocolFeeReserveLib)\n        }\n    }\n\n    /// @notice Returns a unique bytes32 hash for ProtocolFeeReserveLib instances\n    /// @return uuid_ The bytes32 hash representing the UUID\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\n        return EIP_1822_PROXIABLE_UUID;\n    }\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/utils/ProtocolFeeProxyConstants.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\n/// @title ProtocolFeeProxyConstants Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Constant values used in ProtocolFee proxy-related contracts\nabstract contract ProtocolFeeProxyConstants {\n    // `bytes32(keccak256('mln.proxiable.protocolFeeReserveLib'))`\n    bytes32\n        internal constant EIP_1822_PROXIABLE_UUID = 0xbc966524590ce702cc9340e80d86ea9095afa6b8eecbb5d6213f576332239181;\n    // `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`\n    bytes32\n        internal constant EIP_1967_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/ProtocolFeeReserveProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/ProtocolFeeProxyConstants.sol\";\nimport \"./utils/ProxiableProtocolFeeReserveLib.sol\";\n\n/// @title ProtocolFeeReserveProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for a protocol fee reserve, slightly modified from EIP-1822\n/// @dev Adapted from the recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\n/// and using the EIP-1967 storage slot for the proxiable implementation.\n/// See: https://eips.ethereum.org/EIPS/eip-1822\n/// See: https://eips.ethereum.org/EIPS/eip-1967\ncontract ProtocolFeeReserveProxy is ProtocolFeeProxyConstants {\n    constructor(bytes memory _constructData, address _protocolFeeReserveLib) public {\n        // Validate constants\n        require(\n            EIP_1822_PROXIABLE_UUID == bytes32(keccak256(\"mln.proxiable.protocolFeeReserveLib\")),\n            \"constructor: Invalid EIP_1822_PROXIABLE_UUID\"\n        );\n        require(\n            EIP_1967_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1),\n            \"constructor: Invalid EIP_1967_SLOT\"\n        );\n\n        require(\n            ProxiableProtocolFeeReserveLib(_protocolFeeReserveLib).proxiableUUID() ==\n                EIP_1822_PROXIABLE_UUID,\n            \"constructor: _protocolFeeReserveLib not compatible\"\n        );\n\n        assembly {\n            sstore(EIP_1967_SLOT, _protocolFeeReserveLib)\n        }\n\n        (bool success, bytes memory returnData) = _protocolFeeReserveLib.delegatecall(\n            _constructData\n        );\n        require(success, string(returnData));\n    }\n\n    fallback() external payable {\n        assembly {\n            let contractLogic := sload(EIP_1967_SLOT)\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/bases/ProtocolFeeReserveLibBase1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./ProtocolFeeReserveLibBaseCore.sol\";\n\n/// @title ProtocolFeeReserveLibBase1 Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A base implementation for ProtocolFeeReserveLib\n/// @dev Each next base implementation inherits the previous base implementation,\n/// e.g., `ProtocolFeeReserveLibBase2 is ProtocolFeeReserveLibBase1`\n/// DO NOT EDIT CONTRACT.\nabstract contract ProtocolFeeReserveLibBase1 is ProtocolFeeReserveLibBaseCore {\n    event SharesBoughtBack(\n        address indexed vaultProxy,\n        uint256 sharesAmount,\n        uint256 mlnValue,\n        uint256 mlnBurned\n    );\n}\n"
    },
    "contracts/persistent/protocol-fee-reserve/ProtocolFeeReserveLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./bases/ProtocolFeeReserveLibBase1.sol\";\nimport \"./interfaces/IProtocolFeeReserve1.sol\";\n\n/// @title ProtocolFeeReserveLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The proxiable library contract for ProtocolFeeReserveProxy\ncontract ProtocolFeeReserveLib is IProtocolFeeReserve1, ProtocolFeeReserveLibBase1 {\n    using SafeMath for uint256;\n\n    // Equates to a 50% discount\n    uint256 private constant BUYBACK_DISCOUNT_DIVISOR = 2;\n\n    /// @notice Indicates that the calling VaultProxy is buying back shares collected as protocol fee,\n    /// and returns the amount of MLN that should be burned for the buyback\n    /// @param _sharesAmount The amount of shares to buy back\n    /// @param _mlnValue The MLN-denominated market value of _sharesAmount\n    /// @return mlnAmountToBurn_ The amount of MLN to burn\n    /// @dev Since VaultProxy instances are completely trusted, all the work of calculating and\n    /// burning the appropriate amount of shares and MLN can be done by the calling VaultProxy.\n    /// This contract only needs to provide the discounted MLN amount to burn.\n    /// Though it is currently unused, passing in GAV would allow creating a tiered system of\n    /// discounts in a new library, for example.\n    function buyBackSharesViaTrustedVaultProxy(\n        uint256 _sharesAmount,\n        uint256 _mlnValue,\n        uint256\n    ) external override returns (uint256 mlnAmountToBurn_) {\n        mlnAmountToBurn_ = _mlnValue.div(BUYBACK_DISCOUNT_DIVISOR);\n\n        if (mlnAmountToBurn_ == 0) {\n            return 0;\n        }\n\n        emit SharesBoughtBack(msg.sender, _sharesAmount, _mlnValue, mlnAmountToBurn_);\n\n        return mlnAmountToBurn_;\n    }\n}\n"
    },
    "contracts/persistent/off-chain/fund-value-calculator/FundValueCalculatorRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../dispatcher/IDispatcher.sol\";\nimport \"./IFundValueCalculator.sol\";\n\n/// @title FundValueCalculatorRouter Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A peripheral contract for routing value calculation requests\n/// to the correct FundValueCalculator instance for a particular release\n/// @dev These values should generally only be consumed from off-chain,\n/// unless you understand how each release interprets each calculation\ncontract FundValueCalculatorRouter {\n    event FundValueCalculatorUpdated(address indexed fundDeployer, address fundValueCalculator);\n\n    address private immutable DISPATCHER;\n\n    mapping(address => address) private fundDeployerToFundValueCalculator;\n\n    constructor(\n        address _dispatcher,\n        address[] memory _fundDeployers,\n        address[] memory _fundValueCalculators\n    ) public {\n        DISPATCHER = _dispatcher;\n\n        __setFundValueCalculators(_fundDeployers, _fundValueCalculators);\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the GAV for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return gav_ The GAV quoted in the denomination asset\n    function calcGav(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 gav_)\n    {\n        return getFundValueCalculatorForVault(_vaultProxy).calcGav(_vaultProxy);\n    }\n\n    /// @notice Calculates the GAV for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return gav_ The GAV quoted in _quoteAsset\n    function calcGavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 gav_)\n    {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcGavInAsset(_vaultProxy, _quoteAsset);\n    }\n\n    /// @notice Calculates the gross value of one shares unit (10 ** 18) for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return grossShareValue_ The gross share value quoted in the denomination asset\n    function calcGrossShareValue(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 grossShareValue_)\n    {\n        return getFundValueCalculatorForVault(_vaultProxy).calcGrossShareValue(_vaultProxy);\n    }\n\n    /// @notice Calculates the gross value of one shares unit (10 ** 18) for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return grossShareValue_ The gross share value quoted in _quoteAsset\n    function calcGrossShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 grossShareValue_)\n    {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcGrossShareValueInAsset(\n                _vaultProxy,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the NAV for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return nav_ The NAV quoted in the denomination asset\n    function calcNav(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 nav_)\n    {\n        return getFundValueCalculatorForVault(_vaultProxy).calcNav(_vaultProxy);\n    }\n\n    /// @notice Calculates the NAV for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return nav_ The NAV quoted in _quoteAsset\n    function calcNavInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 nav_)\n    {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcNavInAsset(_vaultProxy, _quoteAsset);\n    }\n\n    /// @notice Calculates the net value of one shares unit (10 ** 18) for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return netShareValue_ The net share value quoted in the denomination asset\n    function calcNetShareValue(address _vaultProxy)\n        external\n        returns (address denominationAsset_, uint256 netShareValue_)\n    {\n        return getFundValueCalculatorForVault(_vaultProxy).calcNetShareValue(_vaultProxy);\n    }\n\n    /// @notice Calculates the net value of one shares unit (10 ** 18) for a given fund, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _quoteAsset The quote asset\n    /// @return netShareValue_ The net share value quoted in _quoteAsset\n    function calcNetShareValueInAsset(address _vaultProxy, address _quoteAsset)\n        external\n        returns (uint256 netShareValue_)\n    {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcNetShareValueInAsset(\n                _vaultProxy,\n                _quoteAsset\n            );\n    }\n\n    /// @notice Calculates the net value of all shares held by a specified account\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _sharesHolder The account holding shares\n    /// @return denominationAsset_ The denomination asset of the fund\n    /// @return netValue_ The net value of all shares held by _sharesHolder\n    function calcNetValueForSharesHolder(address _vaultProxy, address _sharesHolder)\n        external\n        returns (address denominationAsset_, uint256 netValue_)\n    {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcNetValueForSharesHolder(\n                _vaultProxy,\n                _sharesHolder\n            );\n    }\n\n    /// @notice Calculates the net value of all shares held by a specified account, quoted in a given asset\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _sharesHolder The account holding shares\n    /// @param _quoteAsset The quote asset\n    /// @return netValue_ The net value of all shares held by _sharesHolder quoted in _quoteAsset\n    function calcNetValueForSharesHolderInAsset(\n        address _vaultProxy,\n        address _sharesHolder,\n        address _quoteAsset\n    ) external returns (uint256 netValue_) {\n        return\n            getFundValueCalculatorForVault(_vaultProxy).calcNetValueForSharesHolderInAsset(\n                _vaultProxy,\n                _sharesHolder,\n                _quoteAsset\n            );\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Gets the FundValueCalculator instance to use for a given fund\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return fundValueCalculatorContract_ The FundValueCalculator instance\n    function getFundValueCalculatorForVault(address _vaultProxy)\n        public\n        view\n        returns (IFundValueCalculator fundValueCalculatorContract_)\n    {\n        address fundDeployer = IDispatcher(DISPATCHER).getFundDeployerForVaultProxy(_vaultProxy);\n        require(fundDeployer != address(0), \"getFundValueCalculatorForVault: Invalid _vaultProxy\");\n\n        address fundValueCalculator = getFundValueCalculatorForFundDeployer(fundDeployer);\n        require(\n            fundValueCalculator != address(0),\n            \"getFundValueCalculatorForVault: No FundValueCalculator set\"\n        );\n\n        return IFundValueCalculator(fundValueCalculator);\n    }\n\n    ////////////////////////////\n    // FUND VALUE CALCULATORS //\n    ////////////////////////////\n\n    /// @notice Sets FundValueCalculator instances for a list of FundDeployer instances\n    /// @param _fundDeployers The FundDeployer instances\n    /// @param _fundValueCalculators The FundValueCalculator instances corresponding\n    /// to each instance in _fundDeployers\n    function setFundValueCalculators(\n        address[] memory _fundDeployers,\n        address[] memory _fundValueCalculators\n    ) external {\n        require(\n            msg.sender == IDispatcher(getDispatcher()).getOwner(),\n            \"Only the Dispatcher owner can call this function\"\n        );\n\n        __setFundValueCalculators(_fundDeployers, _fundValueCalculators);\n    }\n\n    /// @dev Helper to set FundValueCalculator addresses respectively for given FundDeployers\n    function __setFundValueCalculators(\n        address[] memory _fundDeployers,\n        address[] memory _fundValueCalculators\n    ) private {\n        require(\n            _fundDeployers.length == _fundValueCalculators.length,\n            \"__setFundValueCalculators: Unequal array lengths\"\n        );\n\n        for (uint256 i; i < _fundDeployers.length; i++) {\n            fundDeployerToFundValueCalculator[_fundDeployers[i]] = _fundValueCalculators[i];\n\n            emit FundValueCalculatorUpdated(_fundDeployers[i], _fundValueCalculators[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the FundValueCalculator address for a given FundDeployer\n    /// @param _fundDeployer The FundDeployer for which to get the FundValueCalculator address\n    /// @return fundValueCalculator_ The FundValueCalculator address\n    function getFundValueCalculatorForFundDeployer(address _fundDeployer)\n        public\n        view\n        returns (address fundValueCalculator_)\n    {\n        return fundDeployerToFundValueCalculator[_fundDeployer];\n    }\n}\n"
    },
    "contracts/persistent/off-chain/fund-value-calculator-usd-wrapper/FundValueCalculatorUsdWrapper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../fund-value-calculator/FundValueCalculatorRouter.sol\";\n\n/// @title IChainlinkAggregatorFundValueCalculatorUsdWrapper Interface\n/// @author Enzyme Council <security@enzyme.finance>\ninterface IChainlinkAggregatorFundValueCalculatorUsdWrapper {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80,\n            int256,\n            uint256,\n            uint256,\n            uint80\n        );\n}\n\n/// @title FundValueCalculatorUsdWrapper Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Wraps the FundValueCalculatorRouter to get fund values with USD as the quote asset\n/// @dev USD values are normalized to a precision of 18 decimals.\n/// These values should generally only be consumed from off-chain,\n/// unless you understand how each release interprets each calculation.\ncontract FundValueCalculatorUsdWrapper {\n    using SafeMath for uint256;\n\n    uint256 private constant ETH_USD_AGGREGATOR_DECIMALS = 8;\n\n    address private immutable ETH_USD_AGGREGATOR;\n    address private immutable FUND_VALUE_CALCULATOR_ROUTER;\n    uint256 private immutable STALE_RATE_THRESHOLD;\n    address private immutable WETH_TOKEN;\n\n    constructor(\n        address _fundValueCalculatorRouter,\n        address _wethToken,\n        address _ethUsdAggregator,\n        uint256 _staleRateThreshold\n    ) public {\n        ETH_USD_AGGREGATOR = _ethUsdAggregator;\n        FUND_VALUE_CALCULATOR_ROUTER = _fundValueCalculatorRouter;\n        STALE_RATE_THRESHOLD = _staleRateThreshold;\n        WETH_TOKEN = _wethToken;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Calculates the GAV for a given fund in USD\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return gav_ The GAV quoted in USD\n    function calcGav(address _vaultProxy) external returns (uint256 gav_) {\n        uint256 valueInEth = FundValueCalculatorRouter(getFundValueCalculatorRouter())\n            .calcGavInAsset(_vaultProxy, getWethToken());\n\n        return __convertEthToUsd(valueInEth);\n    }\n\n    /// @notice Calculates the gross value of one shares unit (10 ** 18) for a given fund in USD\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return grossShareValue_ The gross share value quoted in USD\n    function calcGrossShareValue(address _vaultProxy) external returns (uint256 grossShareValue_) {\n        uint256 valueInEth = FundValueCalculatorRouter(getFundValueCalculatorRouter())\n            .calcGrossShareValueInAsset(_vaultProxy, getWethToken());\n\n        return __convertEthToUsd(valueInEth);\n    }\n\n    /// @notice Calculates the NAV for a given fund in USD\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return nav_ The NAV quoted in USD\n    function calcNav(address _vaultProxy) external returns (uint256 nav_) {\n        uint256 valueInEth = FundValueCalculatorRouter(getFundValueCalculatorRouter())\n            .calcNavInAsset(_vaultProxy, getWethToken());\n\n        return __convertEthToUsd(valueInEth);\n    }\n\n    /// @notice Calculates the net value of one shares unit (10 ** 18) for a given fund in USD\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @return netShareValue_ The net share value quoted in USD\n    function calcNetShareValue(address _vaultProxy) external returns (uint256 netShareValue_) {\n        uint256 valueInEth = FundValueCalculatorRouter(getFundValueCalculatorRouter())\n            .calcNetShareValueInAsset(_vaultProxy, getWethToken());\n\n        return __convertEthToUsd(valueInEth);\n    }\n\n    /// @notice Calculates the net value of all shares held by a specified account in USD\n    /// @param _vaultProxy The VaultProxy of the fund\n    /// @param _sharesHolder The account holding shares\n    /// @return netValue_ The net value of all shares held by _sharesHolder quoted in USD\n    function calcNetValueForSharesHolder(address _vaultProxy, address _sharesHolder)\n        external\n        returns (uint256 netValue_)\n    {\n        uint256 valueInEth = FundValueCalculatorRouter(getFundValueCalculatorRouter())\n            .calcNetValueForSharesHolderInAsset(_vaultProxy, _sharesHolder, getWethToken());\n\n        return __convertEthToUsd(valueInEth);\n    }\n\n    /// @dev Helper to convert an ETH amount to USD\n    function __convertEthToUsd(uint256 _ethAmount) private view returns (uint256 usdAmount_) {\n        (, int256 usdPerEthRate, , uint256 updatedAt, ) = getEthUsdAggregatorContract()\n            .latestRoundData();\n        require(usdPerEthRate > 0, \"__convertEthToUsd: Bad ethUsd rate\");\n        require(\n            updatedAt >= block.timestamp.sub(getStaleRateThreshold()),\n            \"__convertEthToUsd: Stale rate detected\"\n        );\n\n        return _ethAmount.mul(uint256(usdPerEthRate)).div(10**ETH_USD_AGGREGATOR_DECIMALS);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ETH_USD_AGGREGATOR` variable value\n    /// @return ethUsdAggregatorContract_ The `ETH_USD_AGGREGATOR` variable value\n    function getEthUsdAggregatorContract()\n        public\n        view\n        returns (IChainlinkAggregatorFundValueCalculatorUsdWrapper ethUsdAggregatorContract_)\n    {\n        return IChainlinkAggregatorFundValueCalculatorUsdWrapper(ETH_USD_AGGREGATOR);\n    }\n\n    /// @notice Gets the `FUND_VALUE_CALCULATOR_ROUTER` variable\n    /// @return fundValueCalculatorRouter_ The `FUND_VALUE_CALCULATOR_ROUTER` variable value\n    function getFundValueCalculatorRouter()\n        public\n        view\n        returns (address fundValueCalculatorRouter_)\n    {\n        return FUND_VALUE_CALCULATOR_ROUTER;\n    }\n\n    /// @notice Gets the `STALE_RATE_THRESHOLD` variable value\n    /// @return staleRateThreshold_ The `STALE_RATE_THRESHOLD` value\n    function getStaleRateThreshold() public view returns (uint256 staleRateThreshold_) {\n        return STALE_RATE_THRESHOLD;\n    }\n\n    /// @notice Gets the `WETH_TOKEN` variable value\n    /// @return wethToken_ The `WETH_TOKEN` variable value\n    function getWethToken() public view returns (address wethToken_) {\n        return WETH_TOKEN;\n    }\n}\n"
    },
    "contracts/persistent/dispatcher/Dispatcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../vault/interfaces/IMigratableVault.sol\";\nimport \"../vault/VaultProxy.sol\";\nimport \"./IDispatcher.sol\";\nimport \"./IMigrationHookHandler.sol\";\n\n/// @title Dispatcher Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice The top-level contract linking multiple releases.\n/// It handles the deployment of new VaultProxy instances,\n/// and the regulation of fund migration from a previous release to the current one.\n/// It can also be referred to for access-control based on this contract's owner.\n/// @dev DO NOT EDIT CONTRACT\ncontract Dispatcher is IDispatcher {\n    event CurrentFundDeployerSet(address prevFundDeployer, address nextFundDeployer);\n\n    event MigrationCancelled(\n        address indexed vaultProxy,\n        address indexed prevFundDeployer,\n        address indexed nextFundDeployer,\n        address nextVaultAccessor,\n        address nextVaultLib,\n        uint256 executableTimestamp\n    );\n\n    event MigrationExecuted(\n        address indexed vaultProxy,\n        address indexed prevFundDeployer,\n        address indexed nextFundDeployer,\n        address nextVaultAccessor,\n        address nextVaultLib,\n        uint256 executableTimestamp\n    );\n\n    event MigrationSignaled(\n        address indexed vaultProxy,\n        address indexed prevFundDeployer,\n        address indexed nextFundDeployer,\n        address nextVaultAccessor,\n        address nextVaultLib,\n        uint256 executableTimestamp\n    );\n\n    event MigrationTimelockSet(uint256 prevTimelock, uint256 nextTimelock);\n\n    event NominatedOwnerSet(address indexed nominatedOwner);\n\n    event NominatedOwnerRemoved(address indexed nominatedOwner);\n\n    event OwnershipTransferred(address indexed prevOwner, address indexed nextOwner);\n\n    event MigrationInCancelHookFailed(\n        bytes failureReturnData,\n        address indexed vaultProxy,\n        address indexed prevFundDeployer,\n        address indexed nextFundDeployer,\n        address nextVaultAccessor,\n        address nextVaultLib\n    );\n\n    event MigrationOutHookFailed(\n        bytes failureReturnData,\n        IMigrationHookHandler.MigrationOutHook hook,\n        address indexed vaultProxy,\n        address indexed prevFundDeployer,\n        address indexed nextFundDeployer,\n        address nextVaultAccessor,\n        address nextVaultLib\n    );\n\n    event SharesTokenSymbolSet(string _nextSymbol);\n\n    event VaultProxyDeployed(\n        address indexed fundDeployer,\n        address indexed owner,\n        address vaultProxy,\n        address indexed vaultLib,\n        address vaultAccessor,\n        string fundName\n    );\n\n    struct MigrationRequest {\n        address nextFundDeployer;\n        address nextVaultAccessor;\n        address nextVaultLib;\n        uint256 executableTimestamp;\n    }\n\n    address private currentFundDeployer;\n    address private nominatedOwner;\n    address private owner;\n    uint256 private migrationTimelock;\n    string private sharesTokenSymbol;\n    mapping(address => address) private vaultProxyToFundDeployer;\n    mapping(address => MigrationRequest) private vaultProxyToMigrationRequest;\n\n    modifier onlyCurrentFundDeployer() {\n        require(\n            msg.sender == currentFundDeployer,\n            \"Only the current FundDeployer can call this function\"\n        );\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only the contract owner can call this function\");\n        _;\n    }\n\n    constructor() public {\n        migrationTimelock = 2 days;\n        owner = msg.sender;\n        sharesTokenSymbol = \"ENZF\";\n    }\n\n    /////////////\n    // GENERAL //\n    /////////////\n\n    /// @notice Sets a new `symbol` value for VaultProxy instances\n    /// @param _nextSymbol The symbol value to set\n    function setSharesTokenSymbol(string calldata _nextSymbol) external override onlyOwner {\n        sharesTokenSymbol = _nextSymbol;\n\n        emit SharesTokenSymbolSet(_nextSymbol);\n    }\n\n    ////////////////////\n    // ACCESS CONTROL //\n    ////////////////////\n\n    /// @notice Claim ownership of the contract\n    function claimOwnership() external override {\n        address nextOwner = nominatedOwner;\n        require(\n            msg.sender == nextOwner,\n            \"claimOwnership: Only the nominatedOwner can call this function\"\n        );\n\n        delete nominatedOwner;\n\n        address prevOwner = owner;\n        owner = nextOwner;\n\n        emit OwnershipTransferred(prevOwner, nextOwner);\n    }\n\n    /// @notice Revoke the nomination of a new contract owner\n    function removeNominatedOwner() external override onlyOwner {\n        address removedNominatedOwner = nominatedOwner;\n        require(\n            removedNominatedOwner != address(0),\n            \"removeNominatedOwner: There is no nominated owner\"\n        );\n\n        delete nominatedOwner;\n\n        emit NominatedOwnerRemoved(removedNominatedOwner);\n    }\n\n    /// @notice Set a new FundDeployer for use within the contract\n    /// @param _nextFundDeployer The address of the FundDeployer contract\n    function setCurrentFundDeployer(address _nextFundDeployer) external override onlyOwner {\n        require(\n            _nextFundDeployer != address(0),\n            \"setCurrentFundDeployer: _nextFundDeployer cannot be empty\"\n        );\n        require(\n            __isContract(_nextFundDeployer),\n            \"setCurrentFundDeployer: Non-contract _nextFundDeployer\"\n        );\n\n        address prevFundDeployer = currentFundDeployer;\n        require(\n            _nextFundDeployer != prevFundDeployer,\n            \"setCurrentFundDeployer: _nextFundDeployer is already currentFundDeployer\"\n        );\n\n        currentFundDeployer = _nextFundDeployer;\n\n        emit CurrentFundDeployerSet(prevFundDeployer, _nextFundDeployer);\n    }\n\n    /// @notice Nominate a new contract owner\n    /// @param _nextNominatedOwner The account to nominate\n    /// @dev Does not prohibit overwriting the current nominatedOwner\n    function setNominatedOwner(address _nextNominatedOwner) external override onlyOwner {\n        require(\n            _nextNominatedOwner != address(0),\n            \"setNominatedOwner: _nextNominatedOwner cannot be empty\"\n        );\n        require(\n            _nextNominatedOwner != owner,\n            \"setNominatedOwner: _nextNominatedOwner is already the owner\"\n        );\n        require(\n            _nextNominatedOwner != nominatedOwner,\n            \"setNominatedOwner: _nextNominatedOwner is already nominated\"\n        );\n\n        nominatedOwner = _nextNominatedOwner;\n\n        emit NominatedOwnerSet(_nextNominatedOwner);\n    }\n\n    /// @dev Helper to check whether an address is a deployed contract\n    function __isContract(address _who) private view returns (bool isContract_) {\n        uint256 size;\n        assembly {\n            size := extcodesize(_who)\n        }\n\n        return size > 0;\n    }\n\n    ////////////////\n    // DEPLOYMENT //\n    ////////////////\n\n    /// @notice Deploys a VaultProxy\n    /// @param _vaultLib The VaultLib library with which to instantiate the VaultProxy\n    /// @param _owner The account to set as the VaultProxy's owner\n    /// @param _vaultAccessor The account to set as the VaultProxy's permissioned accessor\n    /// @param _fundName The name of the fund\n    /// @dev Input validation should be handled by the VaultProxy during deployment\n    function deployVaultProxy(\n        address _vaultLib,\n        address _owner,\n        address _vaultAccessor,\n        string calldata _fundName\n    ) external override onlyCurrentFundDeployer returns (address vaultProxy_) {\n        require(__isContract(_vaultAccessor), \"deployVaultProxy: Non-contract _vaultAccessor\");\n\n        bytes memory constructData = abi.encodeWithSelector(\n            IMigratableVault.init.selector,\n            _owner,\n            _vaultAccessor,\n            _fundName\n        );\n        vaultProxy_ = address(new VaultProxy(constructData, _vaultLib));\n\n        address fundDeployer = msg.sender;\n        vaultProxyToFundDeployer[vaultProxy_] = fundDeployer;\n\n        emit VaultProxyDeployed(\n            fundDeployer,\n            _owner,\n            vaultProxy_,\n            _vaultLib,\n            _vaultAccessor,\n            _fundName\n        );\n\n        return vaultProxy_;\n    }\n\n    ////////////////\n    // MIGRATIONS //\n    ////////////////\n\n    /// @notice Cancels a pending migration request\n    /// @param _vaultProxy The VaultProxy contract for which to cancel the migration request\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\n    /// @dev Because this function must also be callable by a permissioned migrator, it has an\n    /// extra migration hook to the nextFundDeployer for the case where cancelMigration()\n    /// is called directly (rather than via the nextFundDeployer).\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external override {\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\n        address nextFundDeployer = request.nextFundDeployer;\n        require(nextFundDeployer != address(0), \"cancelMigration: No migration request exists\");\n\n        // TODO: confirm that if canMigrate() does not exist but the caller is a valid FundDeployer, this still works.\n        require(\n            msg.sender == nextFundDeployer || IMigratableVault(_vaultProxy).canMigrate(msg.sender),\n            \"cancelMigration: Not an allowed caller\"\n        );\n\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\n        address nextVaultAccessor = request.nextVaultAccessor;\n        address nextVaultLib = request.nextVaultLib;\n        uint256 executableTimestamp = request.executableTimestamp;\n\n        delete vaultProxyToMigrationRequest[_vaultProxy];\n\n        __invokeMigrationOutHook(\n            IMigrationHookHandler.MigrationOutHook.PostCancel,\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            _bypassFailure\n        );\n        __invokeMigrationInCancelHook(\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            _bypassFailure\n        );\n\n        emit MigrationCancelled(\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            executableTimestamp\n        );\n    }\n\n    /// @notice Executes a pending migration request\n    /// @param _vaultProxy The VaultProxy contract for which to execute the migration request\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external override {\n        MigrationRequest memory request = vaultProxyToMigrationRequest[_vaultProxy];\n        address nextFundDeployer = request.nextFundDeployer;\n        require(\n            nextFundDeployer != address(0),\n            \"executeMigration: No migration request exists for _vaultProxy\"\n        );\n        require(\n            msg.sender == nextFundDeployer,\n            \"executeMigration: Only the target FundDeployer can call this function\"\n        );\n        require(\n            nextFundDeployer == currentFundDeployer,\n            \"executeMigration: The target FundDeployer is no longer the current FundDeployer\"\n        );\n        uint256 executableTimestamp = request.executableTimestamp;\n        require(\n            block.timestamp >= executableTimestamp,\n            \"executeMigration: The migration timelock has not elapsed\"\n        );\n\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\n        address nextVaultAccessor = request.nextVaultAccessor;\n        address nextVaultLib = request.nextVaultLib;\n\n        __invokeMigrationOutHook(\n            IMigrationHookHandler.MigrationOutHook.PreMigrate,\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            _bypassFailure\n        );\n\n        // Upgrade the VaultProxy to a new VaultLib and update the accessor via the new VaultLib\n        IMigratableVault(_vaultProxy).setVaultLib(nextVaultLib);\n        IMigratableVault(_vaultProxy).setAccessor(nextVaultAccessor);\n\n        // Update the FundDeployer that migrated the VaultProxy\n        vaultProxyToFundDeployer[_vaultProxy] = nextFundDeployer;\n\n        // Remove the migration request\n        delete vaultProxyToMigrationRequest[_vaultProxy];\n\n        __invokeMigrationOutHook(\n            IMigrationHookHandler.MigrationOutHook.PostMigrate,\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            _bypassFailure\n        );\n\n        emit MigrationExecuted(\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            nextVaultAccessor,\n            nextVaultLib,\n            executableTimestamp\n        );\n    }\n\n    /// @notice Sets a new migration timelock\n    /// @param _nextTimelock The number of seconds for the new timelock\n    function setMigrationTimelock(uint256 _nextTimelock) external override onlyOwner {\n        uint256 prevTimelock = migrationTimelock;\n        require(\n            _nextTimelock != prevTimelock,\n            \"setMigrationTimelock: _nextTimelock is the current timelock\"\n        );\n\n        migrationTimelock = _nextTimelock;\n\n        emit MigrationTimelockSet(prevTimelock, _nextTimelock);\n    }\n\n    /// @notice Signals a migration by creating a migration request\n    /// @param _vaultProxy The VaultProxy contract for which to signal migration\n    /// @param _nextVaultAccessor The account that will be the next `accessor` on the VaultProxy\n    /// @param _nextVaultLib The next VaultLib library contract address to set on the VaultProxy\n    /// @param _bypassFailure True if a failure in either migration hook should be ignored\n    function signalMigration(\n        address _vaultProxy,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) external override onlyCurrentFundDeployer {\n        require(\n            __isContract(_nextVaultAccessor),\n            \"signalMigration: Non-contract _nextVaultAccessor\"\n        );\n\n        address prevFundDeployer = vaultProxyToFundDeployer[_vaultProxy];\n        require(prevFundDeployer != address(0), \"signalMigration: _vaultProxy does not exist\");\n\n        address nextFundDeployer = msg.sender;\n        require(\n            nextFundDeployer != prevFundDeployer,\n            \"signalMigration: Can only migrate to a new FundDeployer\"\n        );\n\n        __invokeMigrationOutHook(\n            IMigrationHookHandler.MigrationOutHook.PreSignal,\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            _nextVaultAccessor,\n            _nextVaultLib,\n            _bypassFailure\n        );\n\n        uint256 executableTimestamp = block.timestamp + migrationTimelock;\n        vaultProxyToMigrationRequest[_vaultProxy] = MigrationRequest({\n            nextFundDeployer: nextFundDeployer,\n            nextVaultAccessor: _nextVaultAccessor,\n            nextVaultLib: _nextVaultLib,\n            executableTimestamp: executableTimestamp\n        });\n\n        __invokeMigrationOutHook(\n            IMigrationHookHandler.MigrationOutHook.PostSignal,\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            _nextVaultAccessor,\n            _nextVaultLib,\n            _bypassFailure\n        );\n\n        emit MigrationSignaled(\n            _vaultProxy,\n            prevFundDeployer,\n            nextFundDeployer,\n            _nextVaultAccessor,\n            _nextVaultLib,\n            executableTimestamp\n        );\n    }\n\n    /// @dev Helper to invoke a MigrationInCancelHook on the next FundDeployer being \"migrated in\" to,\n    /// which can optionally be implemented on the FundDeployer\n    function __invokeMigrationInCancelHook(\n        address _vaultProxy,\n        address _prevFundDeployer,\n        address _nextFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) private {\n        (bool success, bytes memory returnData) = _nextFundDeployer.call(\n            abi.encodeWithSelector(\n                IMigrationHookHandler.invokeMigrationInCancelHook.selector,\n                _vaultProxy,\n                _prevFundDeployer,\n                _nextVaultAccessor,\n                _nextVaultLib\n            )\n        );\n        if (!success) {\n            require(\n                _bypassFailure,\n                string(abi.encodePacked(\"MigrationOutCancelHook: \", returnData))\n            );\n\n            emit MigrationInCancelHookFailed(\n                returnData,\n                _vaultProxy,\n                _prevFundDeployer,\n                _nextFundDeployer,\n                _nextVaultAccessor,\n                _nextVaultLib\n            );\n        }\n    }\n\n    /// @dev Helper to invoke a IMigrationHookHandler.MigrationOutHook on the previous FundDeployer being \"migrated out\" of,\n    /// which can optionally be implemented on the FundDeployer\n    function __invokeMigrationOutHook(\n        IMigrationHookHandler.MigrationOutHook _hook,\n        address _vaultProxy,\n        address _prevFundDeployer,\n        address _nextFundDeployer,\n        address _nextVaultAccessor,\n        address _nextVaultLib,\n        bool _bypassFailure\n    ) private {\n        (bool success, bytes memory returnData) = _prevFundDeployer.call(\n            abi.encodeWithSelector(\n                IMigrationHookHandler.invokeMigrationOutHook.selector,\n                _hook,\n                _vaultProxy,\n                _nextFundDeployer,\n                _nextVaultAccessor,\n                _nextVaultLib\n            )\n        );\n        if (!success) {\n            require(\n                _bypassFailure,\n                string(abi.encodePacked(__migrationOutHookFailureReasonPrefix(_hook), returnData))\n            );\n\n            emit MigrationOutHookFailed(\n                returnData,\n                _hook,\n                _vaultProxy,\n                _prevFundDeployer,\n                _nextFundDeployer,\n                _nextVaultAccessor,\n                _nextVaultLib\n            );\n        }\n    }\n\n    /// @dev Helper to return a revert reason string prefix for a given MigrationOutHook\n    function __migrationOutHookFailureReasonPrefix(IMigrationHookHandler.MigrationOutHook _hook)\n        private\n        pure\n        returns (string memory failureReasonPrefix_)\n    {\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreSignal) {\n            return \"MigrationOutHook.PreSignal: \";\n        }\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostSignal) {\n            return \"MigrationOutHook.PostSignal: \";\n        }\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PreMigrate) {\n            return \"MigrationOutHook.PreMigrate: \";\n        }\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostMigrate) {\n            return \"MigrationOutHook.PostMigrate: \";\n        }\n        if (_hook == IMigrationHookHandler.MigrationOutHook.PostCancel) {\n            return \"MigrationOutHook.PostCancel: \";\n        }\n\n        return \"\";\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    // Provides several potentially helpful getters that are not strictly necessary\n\n    /// @notice Gets the current FundDeployer that is allowed to deploy and migrate funds\n    /// @return currentFundDeployer_ The current FundDeployer contract address\n    function getCurrentFundDeployer()\n        external\n        view\n        override\n        returns (address currentFundDeployer_)\n    {\n        return currentFundDeployer;\n    }\n\n    /// @notice Gets the FundDeployer with which a given VaultProxy is associated\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return fundDeployer_ The FundDeployer contract address\n    function getFundDeployerForVaultProxy(address _vaultProxy)\n        external\n        view\n        override\n        returns (address fundDeployer_)\n    {\n        return vaultProxyToFundDeployer[_vaultProxy];\n    }\n\n    /// @notice Gets the details of a pending migration request for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return nextFundDeployer_ The FundDeployer contract address from which the migration\n    /// request was made\n    /// @return nextVaultAccessor_ The account that will be the next `accessor` on the VaultProxy\n    /// @return nextVaultLib_ The next VaultLib library contract address to set on the VaultProxy\n    /// @return executableTimestamp_ The timestamp at which the migration request can be executed\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\n        external\n        view\n        override\n        returns (\n            address nextFundDeployer_,\n            address nextVaultAccessor_,\n            address nextVaultLib_,\n            uint256 executableTimestamp_\n        )\n    {\n        MigrationRequest memory r = vaultProxyToMigrationRequest[_vaultProxy];\n        if (r.executableTimestamp > 0) {\n            return (\n                r.nextFundDeployer,\n                r.nextVaultAccessor,\n                r.nextVaultLib,\n                r.executableTimestamp\n            );\n        }\n    }\n\n    /// @notice Gets the amount of time that must pass between signaling and executing a migration\n    /// @return migrationTimelock_ The timelock value (in seconds)\n    function getMigrationTimelock() external view override returns (uint256 migrationTimelock_) {\n        return migrationTimelock;\n    }\n\n    /// @notice Gets the account that is nominated to be the next owner of this contract\n    /// @return nominatedOwner_ The account that is nominated to be the owner\n    function getNominatedOwner() external view override returns (address nominatedOwner_) {\n        return nominatedOwner;\n    }\n\n    /// @notice Gets the owner of this contract\n    /// @return owner_ The account that is the owner\n    function getOwner() external view override returns (address owner_) {\n        return owner;\n    }\n\n    /// @notice Gets the shares token `symbol` value for use in VaultProxy instances\n    /// @return sharesTokenSymbol_ The `symbol` value\n    function getSharesTokenSymbol()\n        external\n        view\n        override\n        returns (string memory sharesTokenSymbol_)\n    {\n        return sharesTokenSymbol;\n    }\n\n    /// @notice Gets the time remaining until the migration request of a given VaultProxy can be executed\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return secondsRemaining_ The number of seconds remaining on the timelock\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\n        external\n        view\n        override\n        returns (uint256 secondsRemaining_)\n    {\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\n            .executableTimestamp;\n        if (executableTimestamp == 0) {\n            return 0;\n        }\n\n        if (block.timestamp >= executableTimestamp) {\n            return 0;\n        }\n\n        return executableTimestamp - block.timestamp;\n    }\n\n    /// @notice Checks whether a migration request that is executable exists for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return hasExecutableRequest_ True if a migration request exists and is executable\n    function hasExecutableMigrationRequest(address _vaultProxy)\n        external\n        view\n        override\n        returns (bool hasExecutableRequest_)\n    {\n        uint256 executableTimestamp = vaultProxyToMigrationRequest[_vaultProxy]\n            .executableTimestamp;\n\n        return executableTimestamp > 0 && block.timestamp >= executableTimestamp;\n    }\n\n    /// @notice Checks whether a migration request exists for a given VaultProxy\n    /// @param _vaultProxy The VaultProxy instance\n    /// @return hasMigrationRequest_ True if a migration request exists\n    function hasMigrationRequest(address _vaultProxy)\n        external\n        view\n        override\n        returns (bool hasMigrationRequest_)\n    {\n        return vaultProxyToMigrationRequest[_vaultProxy].executableTimestamp > 0;\n    }\n}\n"
    },
    "contracts/persistent/vault/VaultProxy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/ProxiableVaultLib.sol\";\n\n/// @title VaultProxy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A proxy contract for all VaultProxy instances, slightly modified from EIP-1822\n/// @dev Adapted from the recommended implementation of a Proxy in EIP-1822, updated for solc 0.6.12,\n/// and using the EIP-1967 storage slot for the proxiable implementation.\n/// i.e., `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`, which is\n/// \"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\"\n/// See: https://eips.ethereum.org/EIPS/eip-1822\ncontract VaultProxy {\n    constructor(bytes memory _constructData, address _vaultLib) public {\n        // \"0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5\" corresponds to\n        // `bytes32(keccak256('mln.proxiable.vaultlib'))`\n        require(\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\n                ProxiableVaultLib(_vaultLib).proxiableUUID(),\n            \"constructor: _vaultLib not compatible\"\n        );\n\n        assembly {\n            // solium-disable-line\n            sstore(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc, _vaultLib)\n        }\n\n        (bool success, bytes memory returnData) = _vaultLib.delegatecall(_constructData); // solium-disable-line\n        require(success, string(returnData));\n    }\n\n    fallback() external payable {\n        assembly {\n            // solium-disable-line\n            let contractLogic := sload(\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\n            )\n            calldatacopy(0x0, 0x0, calldatasize())\n            let success := delegatecall(\n                sub(gas(), 10000),\n                contractLogic,\n                0x0,\n                calldatasize(),\n                0,\n                0\n            )\n            let retSz := returndatasize()\n            returndatacopy(0, 0, retSz)\n            switch success\n                case 0 {\n                    revert(0, retSz)\n                }\n                default {\n                    return(0, retSz)\n                }\n        }\n    }\n}\n"
    },
    "contracts/mocks/MockVaultLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../persistent/vault/VaultLibBaseCore.sol\";\n\n/// @title MockVaultLib Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A mock VaultLib implementation that only extends VaultLibBaseCore\ncontract MockVaultLib is VaultLibBaseCore {\n    function getAccessor() external view returns (address) {\n        return accessor;\n    }\n\n    function getCreator() external view returns (address) {\n        return creator;\n    }\n\n    function getMigrator() external view returns (address) {\n        return migrator;\n    }\n\n    function getOwner() external view returns (address) {\n        return owner;\n    }\n}\n"
    },
    "contracts/persistent/address-list-registry/AddressListRegistry.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../dispatcher/IDispatcher.sol\";\n\n/// @title AddressListRegistry Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A contract for creating and updating lists of addresses\ncontract AddressListRegistry {\n    enum UpdateType {None, AddOnly, RemoveOnly, AddAndRemove}\n\n    event ItemAddedToList(uint256 indexed id, address item);\n\n    event ItemRemovedFromList(uint256 indexed id, address item);\n\n    event ListAttested(uint256 indexed id, string description);\n\n    event ListCreated(\n        address indexed creator,\n        address indexed owner,\n        uint256 id,\n        UpdateType updateType\n    );\n\n    event ListOwnerSet(uint256 indexed id, address indexed nextOwner);\n\n    event ListUpdateTypeSet(\n        uint256 indexed id,\n        UpdateType prevUpdateType,\n        UpdateType indexed nextUpdateType\n    );\n\n    struct ListInfo {\n        address owner;\n        UpdateType updateType;\n        mapping(address => bool) itemToIsInList;\n    }\n\n    address private immutable DISPATCHER;\n\n    ListInfo[] private lists;\n\n    modifier onlyListOwner(uint256 _id) {\n        require(__isListOwner(msg.sender, _id), \"Only callable by list owner\");\n        _;\n    }\n\n    constructor(address _dispatcher) public {\n        DISPATCHER = _dispatcher;\n\n        // Create the first list as completely empty and immutable, to protect the default `id`\n        lists.push(ListInfo({owner: address(0), updateType: UpdateType.None}));\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Adds items to a given list\n    /// @param _id The id of the list\n    /// @param _items The items to add to the list\n    function addToList(uint256 _id, address[] calldata _items) external onlyListOwner(_id) {\n        UpdateType updateType = getListUpdateType(_id);\n        require(\n            updateType == UpdateType.AddOnly || updateType == UpdateType.AddAndRemove,\n            \"addToList: Cannot add to list\"\n        );\n\n        __addToList(_id, _items);\n    }\n\n    /// @notice Attests active ownership for lists and (optionally) a description of each list's content\n    /// @param _ids The ids of the lists\n    /// @param _descriptions The descriptions of the lists' content\n    /// @dev Since UserA can create a list on behalf of UserB, this function provides a mechanism\n    /// for UserB to attest to their management of the items therein. It will not be visible\n    /// on-chain, but will be available in event logs.\n    function attestLists(uint256[] calldata _ids, string[] calldata _descriptions) external {\n        require(_ids.length == _descriptions.length, \"attestLists: Unequal arrays\");\n\n        for (uint256 i; i < _ids.length; i++) {\n            require(\n                __isListOwner(msg.sender, _ids[i]),\n                \"attestLists: Only callable by list owner\"\n            );\n\n            emit ListAttested(_ids[i], _descriptions[i]);\n        }\n    }\n\n    /// @notice Creates a new list\n    /// @param _owner The owner of the list\n    /// @param _updateType The UpdateType for the list\n    /// @param _initialItems The initial items to add to the list\n    /// @return id_ The id of the newly-created list\n    /// @dev Specify the DISPATCHER as the _owner to make the Enzyme Council the owner\n    function createList(\n        address _owner,\n        UpdateType _updateType,\n        address[] calldata _initialItems\n    ) external returns (uint256 id_) {\n        id_ = getListCount();\n\n        lists.push(ListInfo({owner: _owner, updateType: _updateType}));\n\n        emit ListCreated(msg.sender, _owner, id_, _updateType);\n\n        __addToList(id_, _initialItems);\n\n        return id_;\n    }\n\n    /// @notice Removes items from a given list\n    /// @param _id The id of the list\n    /// @param _items The items to remove from the list\n    function removeFromList(uint256 _id, address[] calldata _items) external onlyListOwner(_id) {\n        UpdateType updateType = getListUpdateType(_id);\n        require(\n            updateType == UpdateType.RemoveOnly || updateType == UpdateType.AddAndRemove,\n            \"removeFromList: Cannot remove from list\"\n        );\n\n        // Silently ignores items that are not in the list\n        for (uint256 i; i < _items.length; i++) {\n            if (isInList(_id, _items[i])) {\n                lists[_id].itemToIsInList[_items[i]] = false;\n\n                emit ItemRemovedFromList(_id, _items[i]);\n            }\n        }\n    }\n\n    /// @notice Sets the owner for a given list\n    /// @param _id The id of the list\n    /// @param _nextOwner The owner to set\n    function setListOwner(uint256 _id, address _nextOwner) external onlyListOwner(_id) {\n        lists[_id].owner = _nextOwner;\n\n        emit ListOwnerSet(_id, _nextOwner);\n    }\n\n    /// @notice Sets the UpdateType for a given list\n    /// @param _id The id of the list\n    /// @param _nextUpdateType The UpdateType to set\n    /// @dev Can only change to a less mutable option (e.g., both add and remove => add only)\n    function setListUpdateType(uint256 _id, UpdateType _nextUpdateType)\n        external\n        onlyListOwner(_id)\n    {\n        UpdateType prevUpdateType = getListUpdateType(_id);\n        require(\n            _nextUpdateType == UpdateType.None || prevUpdateType == UpdateType.AddAndRemove,\n            \"setListUpdateType: _nextUpdateType not allowed\"\n        );\n\n        lists[_id].updateType = _nextUpdateType;\n\n        emit ListUpdateTypeSet(_id, prevUpdateType, _nextUpdateType);\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to add items to a list\n    function __addToList(uint256 _id, address[] memory _items) private {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInList(_id, _items[i])) {\n                lists[_id].itemToIsInList[_items[i]] = true;\n\n                emit ItemAddedToList(_id, _items[i]);\n            }\n        }\n    }\n\n    /// @dev Helper to check if an account is the owner of a given list\n    function __isListOwner(address _who, uint256 _id) private view returns (bool isListOwner_) {\n        address owner = getListOwner(_id);\n        return\n            _who == owner ||\n            (owner == getDispatcher() && _who == IDispatcher(getDispatcher()).getOwner());\n    }\n\n    /////////////////\n    // LIST SEARCH //\n    /////////////////\n\n    // These functions are concerned with exiting quickly and do not consider empty params.\n    // Developers should sanitize empty params as necessary for their own use cases.\n\n    // EXTERNAL FUNCTIONS\n\n    // Multiple items, single list\n\n    /// @notice Checks if multiple items are all in a given list\n    /// @param _id The list id\n    /// @param _items The items to check\n    /// @return areAllInList_ True if all items are in the list\n    function areAllInList(uint256 _id, address[] memory _items)\n        external\n        view\n        returns (bool areAllInList_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInList(_id, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all absent from a given list\n    /// @param _id The list id\n    /// @param _items The items to check\n    /// @return areAllNotInList_ True if no items are in the list\n    function areAllNotInList(uint256 _id, address[] memory _items)\n        external\n        view\n        returns (bool areAllNotInList_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (isInList(_id, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Multiple items, multiple lists\n\n    /// @notice Checks if multiple items are all in all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllInAllLists_ True if all items are in all of the lists\n    function areAllInAllLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllInAllLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInAllLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all in one of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllInSomeOfLists_ True if all items are in one of the lists\n    function areAllInSomeOfLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllInSomeOfLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (!isInSomeOfLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if multiple items are all absent from all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _items The items to check\n    /// @return areAllNotInAnyOfLists_ True if all items are absent from all lists\n    function areAllNotInAnyOfLists(uint256[] memory _ids, address[] memory _items)\n        external\n        view\n        returns (bool areAllNotInAnyOfLists_)\n    {\n        for (uint256 i; i < _items.length; i++) {\n            if (isInSomeOfLists(_ids, _items[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // PUBLIC FUNCTIONS\n\n    // Single item, multiple lists\n\n    /// @notice Checks if an item is in all of a given set of lists\n    /// @param _ids The list ids\n    /// @param _item The item to check\n    /// @return isInAllLists_ True if item is in all of the lists\n    function isInAllLists(uint256[] memory _ids, address _item)\n        public\n        view\n        returns (bool isInAllLists_)\n    {\n        for (uint256 i; i < _ids.length; i++) {\n            if (!isInList(_ids[i], _item)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /// @notice Checks if an item is in at least one of a given set of lists\n    /// @param _ids The list ids\n    /// @param _item The item to check\n    /// @return isInSomeOfLists_ True if item is in one of the lists\n    function isInSomeOfLists(uint256[] memory _ids, address _item)\n        public\n        view\n        returns (bool isInSomeOfLists_)\n    {\n        for (uint256 i; i < _ids.length; i++) {\n            if (isInList(_ids[i], _item)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `DISPATCHER` variable\n    /// @return dispatcher_ The `DISPATCHER` variable value\n    function getDispatcher() public view returns (address dispatcher_) {\n        return DISPATCHER;\n    }\n\n    /// @notice Gets the total count of lists\n    /// @return count_ The total count\n    function getListCount() public view returns (uint256 count_) {\n        return lists.length;\n    }\n\n    /// @notice Gets the owner of a given list\n    /// @param _id The list id\n    /// @return owner_ The owner\n    function getListOwner(uint256 _id) public view returns (address owner_) {\n        return lists[_id].owner;\n    }\n\n    /// @notice Gets the UpdateType of a given list\n    /// @param _id The list id\n    /// @return updateType_ The UpdateType\n    function getListUpdateType(uint256 _id) public view returns (UpdateType updateType_) {\n        return lists[_id].updateType;\n    }\n\n    /// @notice Checks if an item is in a given list\n    /// @param _id The list id\n    /// @param _item The item to check\n    /// @return isInList_ True if the item is in the list\n    function isInList(uint256 _id, address _item) public view returns (bool isInList_) {\n        return lists[_id].itemToIsInList[_item];\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/CumulativeSlippageTolerancePolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../../persistent/address-list-registry/AddressListRegistry.sol\";\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../../../../infrastructure/value-interpreter/ValueInterpreter.sol\";\nimport \"../utils/PolicyBase.sol\";\nimport \"../utils/PricelessAssetBypassMixin.sol\";\n\n/// @title CumulativeSlippageTolerancePolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits cumulative slippage (i.e., value loss) via adapter actions\n/// @dev Slippage tolerance and accumulation values use 10^18 rather than 10^19 (the greatest 10^n uint64 value)\n/// since it is a more natural and common in rates elsewhere\ncontract CumulativeSlippageTolerancePolicy is PolicyBase, PricelessAssetBypassMixin {\n    using SafeMath for uint256;\n\n    event CumulativeSlippageUpdatedForFund(\n        address indexed comptrollerProxy,\n        uint256 nextCumulativeSlippage\n    );\n\n    event FundSettingsSet(address indexed comptrollerProxy, uint256 tolerance);\n\n    struct PolicyInfo {\n        uint64 tolerance;\n        uint64 cumulativeSlippage;\n        uint128 lastSlippageTimestamp;\n    }\n\n    uint256 private constant ONE_HUNDRED_PERCENT = 1 ether; // 10 ** 18\n\n    address private immutable ADDRESS_LIST_REGISTRY;\n    uint256 private immutable BYPASSABLE_ADAPTERS_LIST_ID;\n    uint256 private immutable TOLERANCE_PERIOD_DURATION;\n\n    mapping(address => PolicyInfo) private comptrollerProxyToPolicyInfo;\n\n    constructor(\n        address _policyManager,\n        address _addressListRegistry,\n        address _valueInterpreter,\n        address _wethToken,\n        uint256 _bypassableAdaptersListId,\n        uint256 _tolerancePeriodDuration,\n        uint256 _pricelessAssetBypassTimelock,\n        uint256 _pricelessAssetBypassTimeLimit\n    )\n        public\n        PolicyBase(_policyManager)\n        PricelessAssetBypassMixin(\n            _valueInterpreter,\n            _wethToken,\n            _pricelessAssetBypassTimelock,\n            _pricelessAssetBypassTimeLimit\n        )\n    {\n        ADDRESS_LIST_REGISTRY = _addressListRegistry;\n        BYPASSABLE_ADAPTERS_LIST_ID = _bypassableAdaptersListId;\n        TOLERANCE_PERIOD_DURATION = _tolerancePeriodDuration;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        uint64 tolerance = abi.decode(_encodedSettings, (uint64));\n        require(tolerance < ONE_HUNDRED_PERCENT, \"addFundSettings: Max tolerance exceeded\");\n\n        comptrollerProxyToPolicyInfo[_comptrollerProxy] = PolicyInfo({\n            tolerance: tolerance,\n            cumulativeSlippage: 0,\n            lastSlippageTimestamp: 0\n        });\n\n        emit FundSettingsSet(_comptrollerProxy, tolerance);\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"CUMULATIVE_SLIPPAGE_TOLERANCE\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostCallOnIntegration;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev Requires onlyPolicyManager as it updates state using passed data\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override onlyPolicyManager returns (bool isValid_) {\n        (\n            ,\n            address adapter,\n            ,\n            address[] memory incomingAssets,\n            uint256[] memory incomingAssetAmounts,\n            address[] memory spendAssets,\n            uint256[] memory spendAssetAmounts\n        ) = __decodePostCallOnIntegrationValidationData(_encodedArgs);\n\n        if (__isBypassableAction(adapter)) {\n            return true;\n        }\n\n        uint256 newSlippage = __calcSlippage(\n            _comptrollerProxy,\n            incomingAssets,\n            incomingAssetAmounts,\n            spendAssets,\n            spendAssetAmounts\n        );\n        if (newSlippage == 0) {\n            return true;\n        }\n\n        uint256 tolerance = comptrollerProxyToPolicyInfo[_comptrollerProxy].tolerance;\n\n        return __updateCumulativeSlippage(_comptrollerProxy, newSlippage, tolerance) <= tolerance;\n    }\n\n    // PRIVATE FUNCTIONS\n\n    /// @dev Helper to calculate slippage\n    function __calcSlippage(\n        address _comptrollerProxy,\n        address[] memory _incomingAssets,\n        uint256[] memory _incomingAssetAmounts,\n        address[] memory _spendAssets,\n        uint256[] memory _spendAssetAmounts\n    ) private returns (uint256 slippage_) {\n        uint256 outgoingValue = __calcTotalValueExlcudingBypassablePricelessAssets(\n            _comptrollerProxy,\n            _spendAssets,\n            _spendAssetAmounts,\n            getPricelessAssetBypassWethToken()\n        );\n\n        // In case there are only incoming assets (e.g., claiming rewards), return early\n        if (outgoingValue == 0) {\n            return 0;\n        }\n\n        uint256 incomingValue = __calcTotalValueExlcudingBypassablePricelessAssets(\n            _comptrollerProxy,\n            _incomingAssets,\n            _incomingAssetAmounts,\n            getPricelessAssetBypassWethToken()\n        );\n\n        if (outgoingValue > incomingValue) {\n            uint256 loss = outgoingValue.sub(incomingValue);\n\n            return loss.mul(ONE_HUNDRED_PERCENT).div(outgoingValue);\n        }\n\n        return 0;\n    }\n\n    /// @dev Helper to determine if an adapter is bypassable\n    function __isBypassableAction(address _adapter) private view returns (bool isBypassable_) {\n        return\n            AddressListRegistry(getAddressListRegistry()).isInList(\n                getBypassableAdaptersListId(),\n                _adapter\n            );\n    }\n\n    /// @dev Helper to update the cumulative slippage for a given fund.\n    /// The stored `cumulativeSlippage` is replenished at a constant rate,\n    /// relative to the fund's tolerance over the TOLERANCE_PERIOD_DURATION.\n    function __updateCumulativeSlippage(\n        address _comptrollerProxy,\n        uint256 _newSlippage,\n        uint256 _tolerance\n    ) private returns (uint256 nextCumulativeSlippage_) {\n        PolicyInfo storage policyInfo = comptrollerProxyToPolicyInfo[_comptrollerProxy];\n\n        nextCumulativeSlippage_ = policyInfo.cumulativeSlippage;\n\n        // Deduct the slippage that is replenishable given the previous slippage timestamp\n        if (nextCumulativeSlippage_ > 0) {\n            uint256 cumulativeSlippageToRestore = _tolerance\n                .mul(block.timestamp.sub(policyInfo.lastSlippageTimestamp))\n                .div(getTolerancePeriodDuration());\n            if (cumulativeSlippageToRestore < nextCumulativeSlippage_) {\n                nextCumulativeSlippage_ = nextCumulativeSlippage_.sub(cumulativeSlippageToRestore);\n            } else {\n                nextCumulativeSlippage_ = 0;\n            }\n        }\n\n        // Add the new slippage\n        nextCumulativeSlippage_ = nextCumulativeSlippage_.add(_newSlippage);\n\n        policyInfo.cumulativeSlippage = uint64(nextCumulativeSlippage_);\n        policyInfo.lastSlippageTimestamp = uint128(block.timestamp);\n\n        emit CumulativeSlippageUpdatedForFund(_comptrollerProxy, nextCumulativeSlippage_);\n\n        return nextCumulativeSlippage_;\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ADDRESS_LIST_REGISTRY` variable\n    /// @return addressListRegistry_ The `ADDRESS_LIST_REGISTRY` variable value\n    function getAddressListRegistry() public view returns (address addressListRegistry_) {\n        return ADDRESS_LIST_REGISTRY;\n    }\n\n    /// @notice Gets the `BYPASSABLE_ADAPTERS_LIST_ID` variable\n    /// @return bypassableAdaptersListId_ The `BYPASSABLE_ADAPTERS_LIST_ID` variable value\n    function getBypassableAdaptersListId()\n        public\n        view\n        returns (uint256 bypassableAdaptersListId_)\n    {\n        return BYPASSABLE_ADAPTERS_LIST_ID;\n    }\n\n    /// @notice Gets the PolicyInfo for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return policyInfo_ The PolicyInfo values\n    function getPolicyInfoForFund(address _comptrollerProxy)\n        public\n        view\n        returns (PolicyInfo memory policyInfo_)\n    {\n        return comptrollerProxyToPolicyInfo[_comptrollerProxy];\n    }\n\n    /// @notice Gets the `TOLERANCE_PERIOD_DURATION` variable\n    /// @return tolerancePeriodDuration_ The `TOLERANCE_PERIOD_DURATION` variable value\n    function getTolerancePeriodDuration() public view returns (uint256 tolerancePeriodDuration_) {\n        return TOLERANCE_PERIOD_DURATION;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/utils/AddressListRegistryPolicyBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../../persistent/address-list-registry/AddressListRegistry.sol\";\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../utils/PolicyBase.sol\";\n\n/// @title AddressListRegistryPolicyBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Base contract inheritable by any policy that uses the AddressListRegistry\nabstract contract AddressListRegistryPolicyBase is PolicyBase {\n    event ListsSetForFund(address indexed comptrollerProxy, uint256[] listIds);\n\n    address private immutable ADDRESS_LIST_REGISTRY;\n\n    mapping(address => uint256[]) private comptrollerProxyToListIds;\n\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        PolicyBase(_policyManager)\n    {\n        ADDRESS_LIST_REGISTRY = _addressListRegistry;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Adds the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        virtual\n        override\n        onlyPolicyManager\n    {\n        __updateListsForFund(_comptrollerProxy, _encodedSettings);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /// @dev Helper to create new list from encoded data\n    function __createAddressListFromData(address _vaultProxy, bytes memory _newListData)\n        internal\n        returns (uint256 listId_)\n    {\n        (\n            AddressListRegistry.UpdateType updateType,\n            address[] memory initialItems\n        ) = __decodeNewListData(_newListData);\n\n        return\n            AddressListRegistry(getAddressListRegistry()).createList(\n                _vaultProxy,\n                updateType,\n                initialItems\n            );\n    }\n\n    /// @dev Helper to decode new list data\n    function __decodeNewListData(bytes memory _newListData)\n        internal\n        pure\n        returns (AddressListRegistry.UpdateType updateType_, address[] memory initialItems_)\n    {\n        return abi.decode(_newListData, (AddressListRegistry.UpdateType, address[]));\n    }\n\n    /// @dev Helper to set the lists to be used by a given fund.\n    /// This is done in a simple manner rather than the most gas-efficient way possible\n    /// (e.g., comparing already-stored items with an updated list would save on storage operations during updates).\n    function __updateListsForFund(address _comptrollerProxy, bytes calldata _encodedSettings)\n        internal\n    {\n        (uint256[] memory existingListIds, bytes[] memory newListsData) = abi.decode(\n            _encodedSettings,\n            (uint256[], bytes[])\n        );\n\n        uint256[] memory nextListIds = new uint256[](existingListIds.length + newListsData.length);\n        require(nextListIds.length != 0, \"__updateListsForFund: No lists specified\");\n\n        // Clear the previously stored list ids as needed\n        if (comptrollerProxyToListIds[_comptrollerProxy].length > 0) {\n            delete comptrollerProxyToListIds[_comptrollerProxy];\n        }\n\n        // Add existing list ids.\n        // No need to validate existence, policy will just fail if out-of-bounds index.\n        for (uint256 i; i < existingListIds.length; i++) {\n            nextListIds[i] = existingListIds[i];\n            comptrollerProxyToListIds[_comptrollerProxy].push(existingListIds[i]);\n        }\n\n        // Create and add any new lists\n        if (newListsData.length > 0) {\n            address vaultProxy = ComptrollerLib(_comptrollerProxy).getVaultProxy();\n            for (uint256 i; i < newListsData.length; i++) {\n                uint256 nextListIdsIndex = existingListIds.length + i;\n                nextListIds[nextListIdsIndex] = __createAddressListFromData(\n                    vaultProxy,\n                    newListsData[i]\n                );\n                comptrollerProxyToListIds[_comptrollerProxy].push(nextListIds[nextListIdsIndex]);\n            }\n        }\n\n        emit ListsSetForFund(_comptrollerProxy, nextListIds);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `ADDRESS_LIST_REGISTRY` variable value\n    /// @return addressListRegistry_ The `ADDRESS_LIST_REGISTRY` variable value\n    function getAddressListRegistry() public view returns (address addressListRegistry_) {\n        return ADDRESS_LIST_REGISTRY;\n    }\n\n    /// @notice Gets the list ids used by a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return listIds_ The list ids\n    function getListIdsForFund(address _comptrollerProxy)\n        public\n        view\n        returns (uint256[] memory listIds_)\n    {\n        return comptrollerProxyToListIds[_comptrollerProxy];\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/new-shareholders/AllowedSharesTransferRecipientsPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/AddressListRegistryPolicyBase.sol\";\n\n/// @title AllowedSharesTransferRecipientsPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits the accounts that can receive shares via transfer\ncontract AllowedSharesTransferRecipientsPolicy is AddressListRegistryPolicyBase {\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        AddressListRegistryPolicyBase(_policyManager, _addressListRegistry)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return true;\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifer string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_SHARES_TRANSFER_RECIPIENTS\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PreTransferShares;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Updates the policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    /// @dev Used to assign a new list (not update items in that list)\n    function updateFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        __updateListsForFund(_comptrollerProxy, _encodedSettings);\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, address recipient, ) = __decodePreTransferSharesValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, recipient);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _recipient The recipient of shares from the transfer\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address _recipient)\n        public\n        view\n        returns (bool isValid_)\n    {\n        return\n            AddressListRegistry(getAddressListRegistry()).isInSomeOfLists(\n                getListIdsForFund(_comptrollerProxy),\n                _recipient\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/new-shareholders/AllowedDepositRecipientsPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/AddressListRegistryPolicyBase.sol\";\n\n/// @title AllowedDepositRecipientsPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits the accounts that can receive shares via deposit\ncontract AllowedDepositRecipientsPolicy is AddressListRegistryPolicyBase {\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        AddressListRegistryPolicyBase(_policyManager, _addressListRegistry)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return true;\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifer string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_DEPOSIT_RECIPIENTS\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostBuyShares;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Updates the policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    /// @dev Used to assign a new list (not update items in that list)\n    function updateFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        __updateListsForFund(_comptrollerProxy, _encodedSettings);\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (address buyer, , , ) = __decodePostBuySharesValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, buyer);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _recipient The recipient of shares from the deposit\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address _recipient)\n        public\n        view\n        returns (bool isValid_)\n    {\n        return\n            AddressListRegistry(getAddressListRegistry()).isInSomeOfLists(\n                getListIdsForFund(_comptrollerProxy),\n                _recipient\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/current-shareholders/AllowedAssetsForRedemptionPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/AddressListRegistryPolicyBase.sol\";\n\n/// @title AllowedAssetsForRedemptionPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits assets that can be redeemed by specific asset redemption\ncontract AllowedAssetsForRedemptionPolicy is AddressListRegistryPolicyBase {\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        AddressListRegistryPolicyBase(_policyManager, _addressListRegistry)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Whether or not the policy can be disabled\n    /// @return canDisable_ True if the policy can be disabled\n    function canDisable() external pure virtual override returns (bool canDisable_) {\n        return true;\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_ASSETS_FOR_REDEMPTION\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.RedeemSharesForSpecificAssets;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, , , address[] memory assets, , ) = __decodeRedeemSharesForSpecificAssetsValidationData(\n            _encodedArgs\n        );\n\n        return passesRule(_comptrollerProxy, assets);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _assets The assets for which to check the rule\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address[] memory _assets)\n        public\n        view\n        returns (bool isValid_)\n    {\n        return\n            AddressListRegistry(getAddressListRegistry()).areAllInSomeOfLists(\n                getListIdsForFund(_comptrollerProxy),\n                _assets\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/AllowedAdaptersPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/AddressListRegistryPolicyBase.sol\";\n\n/// @title AllowedAdaptersPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits adapters that can be used by a fund\ncontract AllowedAdaptersPolicy is AddressListRegistryPolicyBase {\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        AddressListRegistryPolicyBase(_policyManager, _addressListRegistry)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifer string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_ADAPTERS\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostCallOnIntegration;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, address adapter, , , , , ) = __decodePostCallOnIntegrationValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, adapter);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _adapter The adapter for which to check the rule\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address _adapter)\n        public\n        view\n        returns (bool isValid_)\n    {\n        return\n            AddressListRegistry(getAddressListRegistry()).isInSomeOfLists(\n                getListIdsForFund(_comptrollerProxy),\n                _adapter\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/AllowedAdapterIncomingAssetsPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"../utils/AddressListRegistryPolicyBase.sol\";\n\n/// @title AllowedAdapterIncomingAssetsPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that limits assets that can be received via an adapter action\ncontract AllowedAdapterIncomingAssetsPolicy is AddressListRegistryPolicyBase {\n    constructor(address _policyManager, address _addressListRegistry)\n        public\n        AddressListRegistryPolicyBase(_policyManager, _addressListRegistry)\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ALLOWED_ADAPTER_INCOMING_ASSETS\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostCallOnIntegration;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (\n            ,\n            ,\n            ,\n            address[] memory incomingAssets,\n            ,\n            ,\n\n        ) = __decodePostCallOnIntegrationValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, incomingAssets);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _assets The assets for which to check the rule\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address[] memory _assets)\n        public\n        view\n        returns (bool isValid_)\n    {\n        return\n            AddressListRegistry(getAddressListRegistry()).areAllInSomeOfLists(\n                getListIdsForFund(_comptrollerProxy),\n                _assets\n            );\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/OnlyRemoveDustExternalPositionPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../../../../core/fund/comptroller/ComptrollerLib.sol\";\nimport \"../utils/DustEvaluatorMixin.sol\";\nimport \"../utils/PolicyBase.sol\";\nimport \"../utils/PricelessAssetBypassMixin.sol\";\n\n/// @title OnlyRemoveDustExternalPositionPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that only allows removing external positions whose value can be considered negligible\n/// @dev Assets that do not have a valid price can be signaled via PricelessAssetBypassMixin to be valued at `0`\ncontract OnlyRemoveDustExternalPositionPolicy is\n    PolicyBase,\n    DustEvaluatorMixin,\n    PricelessAssetBypassMixin\n{\n    constructor(\n        address _policyManager,\n        address _fundDeployer,\n        address _valueInterpreter,\n        address _wethToken,\n        uint256 _pricelessAssetBypassTimelock,\n        uint256 _pricelessAssetBypassTimeLimit\n    )\n        public\n        PolicyBase(_policyManager)\n        DustEvaluatorMixin(_fundDeployer)\n        PricelessAssetBypassMixin(\n            _valueInterpreter,\n            _wethToken,\n            _pricelessAssetBypassTimelock,\n            _pricelessAssetBypassTimeLimit\n        )\n    {}\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial policy settings for a fund\n    function addFundSettings(address, bytes calldata) external override {\n        // Not implemented\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifier string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"ONLY_REMOVE_DUST_EXTERNAL_POSITION\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.RemoveExternalPosition;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary as no state is updated,\n    /// but is cheap and nice-to-have since an event is fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override onlyPolicyManager returns (bool isValid_) {\n        (, address externalPosition) = __decodeRemoveExternalPositionValidationData(_encodedArgs);\n\n        return __isDust(__calcExternalPositionValue(_comptrollerProxy, externalPosition));\n    }\n\n    // PRIVATE FUNCTIONS\n\n    // @dev Helper for calculating an external position's value\n    function __calcExternalPositionValue(address _comptrollerProxy, address _externalPosition)\n        private\n        returns (uint256 value_)\n    {\n        (\n            address[] memory managedAssets,\n            uint256[] memory managedAssetBalances\n        ) = IExternalPosition(_externalPosition).getManagedAssets();\n\n        uint256 managedAssetsValue = __calcTotalValueExlcudingBypassablePricelessAssets(\n            _comptrollerProxy,\n            managedAssets,\n            managedAssetBalances,\n            getPricelessAssetBypassWethToken()\n        );\n\n        (address[] memory debtAssets, uint256[] memory debtAssetBalances) = IExternalPosition(\n            _externalPosition\n        )\n            .getDebtAssets();\n\n        uint256 debtAssetsValue = __calcTotalValueExlcudingBypassablePricelessAssets(\n            _comptrollerProxy,\n            debtAssets,\n            debtAssetBalances,\n            getPricelessAssetBypassWethToken()\n        );\n\n        if (managedAssetsValue > debtAssetsValue) {\n            return managedAssetsValue.sub(debtAssetsValue);\n        }\n\n        return 0;\n    }\n}\n"
    },
    "contracts/release/extensions/policy-manager/policies/asset-managers/GuaranteedRedemptionPolicy.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../../../utils/FundDeployerOwnerMixin.sol\";\nimport \"../utils/PolicyBase.sol\";\n\n/// @title GuaranteedRedemptionPolicy Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice A policy that guarantees that shares will either be continuously redeemable or\n/// redeemable within a predictable daily window by preventing trading during a configurable daily period\ncontract GuaranteedRedemptionPolicy is PolicyBase, FundDeployerOwnerMixin {\n    using SafeMath for uint256;\n\n    event AdapterAdded(address adapter);\n\n    event AdapterRemoved(address adapter);\n\n    event FundSettingsSet(\n        address indexed comptrollerProxy,\n        uint128 startTimestamp,\n        uint128 duration\n    );\n\n    event RedemptionWindowBufferSet(uint256 prevBuffer, uint256 nextBuffer);\n\n    struct RedemptionWindow {\n        uint128 startTimestamp;\n        uint128 duration;\n    }\n\n    uint256 private constant ONE_DAY = 24 * 60 * 60;\n\n    mapping(address => bool) private adapterToCanBlockRedemption;\n    mapping(address => RedemptionWindow) private comptrollerProxyToRedemptionWindow;\n    uint256 private redemptionWindowBuffer;\n\n    constructor(\n        address _policyManager,\n        address _fundDeployer,\n        uint256 _redemptionWindowBuffer,\n        address[] memory _redemptionBlockingAdapters\n    ) public PolicyBase(_policyManager) FundDeployerOwnerMixin(_fundDeployer) {\n        redemptionWindowBuffer = _redemptionWindowBuffer;\n\n        __addRedemptionBlockingAdapters(_redemptionBlockingAdapters);\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial policy settings for a fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedSettings Encoded settings to apply to a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _encodedSettings)\n        external\n        override\n        onlyPolicyManager\n    {\n        (uint128 startTimestamp, uint128 duration) = abi.decode(\n            _encodedSettings,\n            (uint128, uint128)\n        );\n\n        if (startTimestamp == 0) {\n            require(duration == 0, \"addFundSettings: duration must be 0 if startTimestamp is 0\");\n            return;\n        }\n\n        // Require start timestamp to be in the past for simpler logic\n        require(\n            startTimestamp < block.timestamp,\n            \"addFundSettings: startTimestamp must be in past\"\n        );\n\n        // Use 23 hours instead of 1 day to allow up to 1 hr of redemptionWindowBuffer\n        require(\n            duration > 0 && duration <= 23 hours,\n            \"addFundSettings: duration must be between 1 second and 23 hours\"\n        );\n\n        comptrollerProxyToRedemptionWindow[_comptrollerProxy].startTimestamp = startTimestamp;\n        comptrollerProxyToRedemptionWindow[_comptrollerProxy].duration = duration;\n\n        emit FundSettingsSet(_comptrollerProxy, startTimestamp, duration);\n    }\n\n    /// @notice Provides a constant string identifier for a policy\n    /// @return identifier_ The identifer string\n    function identifier() external pure override returns (string memory identifier_) {\n        return \"GUARANTEED_REDEMPTION\";\n    }\n\n    /// @notice Gets the implemented PolicyHooks for a policy\n    /// @return implementedHooks_ The implemented PolicyHooks\n    function implementedHooks()\n        external\n        pure\n        override\n        returns (IPolicyManager.PolicyHook[] memory implementedHooks_)\n    {\n        implementedHooks_ = new IPolicyManager.PolicyHook[](1);\n        implementedHooks_[0] = IPolicyManager.PolicyHook.PostCallOnIntegration;\n\n        return implementedHooks_;\n    }\n\n    /// @notice Checks whether a particular condition passes the rule for a particular fund\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _adapter The adapter for which to check the rule\n    /// @return isValid_ True if the rule passes\n    function passesRule(address _comptrollerProxy, address _adapter)\n        public\n        view\n        returns (bool isValid_)\n    {\n        if (!adapterCanBlockRedemption(_adapter)) {\n            return true;\n        }\n\n\n            RedemptionWindow memory redemptionWindow\n         = comptrollerProxyToRedemptionWindow[_comptrollerProxy];\n\n        // If no RedemptionWindow is set, the fund can never use redemption-blocking adapters\n        if (redemptionWindow.startTimestamp == 0) {\n            return false;\n        }\n\n        uint256 latestRedemptionWindowStart = calcLatestRedemptionWindowStart(\n            redemptionWindow.startTimestamp\n        );\n\n        // A fund can't trade during its redemption window, nor in the buffer beforehand\n        if (\n            block.timestamp > latestRedemptionWindowStart.add(redemptionWindow.duration) &&\n            block.timestamp < latestRedemptionWindowStart.add(ONE_DAY).sub(redemptionWindowBuffer)\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /// @notice Sets a new value for the redemptionWindowBuffer variable\n    /// @param _nextRedemptionWindowBuffer The number of seconds for the redemptionWindowBuffer\n    /// @dev The redemptionWindowBuffer is added to the beginning of the redemption window,\n    /// and should always be >= the longest potential block on redemption amongst all adapters.\n    /// (e.g., Synthetix blocks token transfers during a timelock after trading synths)\n    function setRedemptionWindowBuffer(uint256 _nextRedemptionWindowBuffer)\n        external\n        onlyFundDeployerOwner\n    {\n        uint256 prevRedemptionWindowBuffer = redemptionWindowBuffer;\n        require(\n            _nextRedemptionWindowBuffer != prevRedemptionWindowBuffer,\n            \"setRedemptionWindowBuffer: Value already set\"\n        );\n\n        redemptionWindowBuffer = _nextRedemptionWindowBuffer;\n\n        emit RedemptionWindowBufferSet(prevRedemptionWindowBuffer, _nextRedemptionWindowBuffer);\n    }\n\n    /// @notice Apply the rule with the specified parameters of a PolicyHook\n    /// @param _comptrollerProxy The fund's ComptrollerProxy address\n    /// @param _encodedArgs Encoded args with which to validate the rule\n    /// @return isValid_ True if the rule passes\n    /// @dev onlyPolicyManager validation not necessary, as state is not updated and no events are fired\n    function validateRule(\n        address _comptrollerProxy,\n        IPolicyManager.PolicyHook,\n        bytes calldata _encodedArgs\n    ) external override returns (bool isValid_) {\n        (, address adapter, , , , , ) = __decodePostCallOnIntegrationValidationData(_encodedArgs);\n\n        return passesRule(_comptrollerProxy, adapter);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    /// @notice Calculates the start of the most recent redemption window\n    /// @param _startTimestamp The initial startTimestamp for the redemption window\n    /// @return latestRedemptionWindowStart_ The starting timestamp of the most recent redemption window\n    function calcLatestRedemptionWindowStart(uint256 _startTimestamp)\n        public\n        view\n        returns (uint256 latestRedemptionWindowStart_)\n    {\n        uint256 timeSinceStartTimestamp = block.timestamp.sub(_startTimestamp);\n        uint256 timeSincePeriodStart = timeSinceStartTimestamp.mod(ONE_DAY);\n\n        return block.timestamp.sub(timeSincePeriodStart);\n    }\n\n    ///////////////////////////////////////////\n    // REDEMPTION-BLOCKING ADAPTERS REGISTRY //\n    ///////////////////////////////////////////\n\n    /// @notice Add adapters which can block shares redemption\n    /// @param _adapters The addresses of adapters to be added\n    function addRedemptionBlockingAdapters(address[] calldata _adapters)\n        external\n        onlyFundDeployerOwner\n    {\n        require(\n            _adapters.length > 0,\n            \"__addRedemptionBlockingAdapters: _adapters cannot be empty\"\n        );\n\n        __addRedemptionBlockingAdapters(_adapters);\n    }\n\n    /// @notice Remove adapters which can block shares redemption\n    /// @param _adapters The addresses of adapters to be removed\n    function removeRedemptionBlockingAdapters(address[] calldata _adapters)\n        external\n        onlyFundDeployerOwner\n    {\n        require(\n            _adapters.length > 0,\n            \"removeRedemptionBlockingAdapters: _adapters cannot be empty\"\n        );\n\n        for (uint256 i; i < _adapters.length; i++) {\n            require(\n                adapterCanBlockRedemption(_adapters[i]),\n                \"removeRedemptionBlockingAdapters: adapter is not added\"\n            );\n\n            adapterToCanBlockRedemption[_adapters[i]] = false;\n\n            emit AdapterRemoved(_adapters[i]);\n        }\n    }\n\n    /// @dev Helper to mark adapters that can block shares redemption\n    function __addRedemptionBlockingAdapters(address[] memory _adapters) private {\n        for (uint256 i; i < _adapters.length; i++) {\n            require(\n                _adapters[i] != address(0),\n                \"__addRedemptionBlockingAdapters: adapter cannot be empty\"\n            );\n            require(\n                !adapterCanBlockRedemption(_adapters[i]),\n                \"__addRedemptionBlockingAdapters: adapter already added\"\n            );\n\n            adapterToCanBlockRedemption[_adapters[i]] = true;\n\n            emit AdapterAdded(_adapters[i]);\n        }\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `redemptionWindowBuffer` variable\n    /// @return redemptionWindowBuffer_ The `redemptionWindowBuffer` variable value\n    function getRedemptionWindowBuffer() external view returns (uint256 redemptionWindowBuffer_) {\n        return redemptionWindowBuffer;\n    }\n\n    /// @notice Gets the RedemptionWindow settings for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @return redemptionWindow_ The RedemptionWindow settings\n    function getRedemptionWindowForFund(address _comptrollerProxy)\n        external\n        view\n        returns (RedemptionWindow memory redemptionWindow_)\n    {\n        return comptrollerProxyToRedemptionWindow[_comptrollerProxy];\n    }\n\n    /// @notice Checks whether an adapter can block shares redemption\n    /// @param _adapter The address of the adapter to check\n    /// @return canBlockRedemption_ True if the adapter can block shares redemption\n    function adapterCanBlockRedemption(address _adapter)\n        public\n        view\n        returns (bool canBlockRedemption_)\n    {\n        return adapterToCanBlockRedemption[_adapter];\n    }\n}\n"
    },
    "contracts/mocks/MockGenericExternalPositionParser.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"../release/extensions/external-position-manager/external-positions/IExternalPositionParser.sol\";\n\n/// @title MockGenericExternalPositionParser Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Provides a generic external position parser to be used on tests\ncontract MockGenericExternalPositionParser is IExternalPositionParser {\n    struct AssetsForAction {\n        address[] assetsToTransfer;\n        uint256[] amountsToTransfer;\n        address[] assetsToReceive;\n    }\n\n    bytes private initArgs;\n\n    mapping(uint256 => AssetsForAction) private actionIdToAssetsForAction;\n\n    /// @dev Returns the default assetsForAction stored for a given actionID\n    function parseAssetsForAction(\n        address,\n        uint256 _actionId,\n        bytes memory\n    )\n        external\n        override\n        returns (\n            address[] memory assetsToTransfer_,\n            uint256[] memory amountsToTransfer_,\n            address[] memory assetsToReceive_\n        )\n    {\n        AssetsForAction memory assetsForAction = actionIdToAssetsForAction[_actionId];\n        return (\n            assetsForAction.assetsToTransfer,\n            assetsForAction.amountsToTransfer,\n            assetsForAction.assetsToReceive\n        );\n    }\n\n    /// @dev Sets the assets for action for a given actionId\n    function setAssetsForAction(\n        uint256 actionId,\n        address[] memory _assetsToTransfer,\n        uint256[] memory _amountsToTransfer,\n        address[] memory _assetsToReceive\n    ) external {\n        actionIdToAssetsForAction[actionId] = AssetsForAction({\n            assetsToTransfer: _assetsToTransfer,\n            amountsToTransfer: _amountsToTransfer,\n            assetsToReceive: _assetsToReceive\n        });\n    }\n\n    /// @dev Sets the initArgs variable\n    function setInitArgs(bytes memory _initArgs) external {\n        initArgs = _initArgs;\n    }\n\n    /// @dev Sets the initArgs variable\n    function parseInitArgs(address, bytes memory)\n        external\n        override\n        returns (bytes memory initArgs_)\n    {\n        return initArgs;\n    }\n\n    /// @dev Returns the initArgs variable\n    function getInitArgs() public view returns (bytes memory initArgs_) {\n        return initArgs;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/utils/EntranceRateFeeBase.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"./FeeBase.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title EntranceRateFeeBase Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice Calculates a fee based on a rate to be charged to an investor upon entering a fund\nabstract contract EntranceRateFeeBase is FeeBase {\n    using SafeMath for uint256;\n\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate);\n\n    event Settled(address indexed comptrollerProxy, address indexed payer, uint256 sharesQuantity);\n\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\n    IFeeManager.SettlementType private immutable SETTLEMENT_TYPE;\n\n    mapping(address => uint256) private comptrollerProxyToRate;\n\n    constructor(address _feeManager, IFeeManager.SettlementType _settlementType)\n        public\n        FeeBase(_feeManager)\n    {\n        require(\n            _settlementType == IFeeManager.SettlementType.Burn ||\n                _settlementType == IFeeManager.SettlementType.Direct,\n            \"constructor: Invalid _settlementType\"\n        );\n        SETTLEMENT_TYPE = _settlementType;\n    }\n\n    // EXTERNAL FUNCTIONS\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        public\n        virtual\n        override\n        onlyFeeManager\n    {\n        console.log(\"EntraceRateFeeBase begin\");\n        uint256 rate = abi.decode(_settingsData, (uint256));\n        console.log(\"EntraceRateFeeBase rate:%d\", rate);\n        require(rate > 0, \"addFundSettings: Fee rate must be >0\");\n        require(rate < ONE_HUNDRED_PERCENT, \"addFundSettings: Fee rate max exceeded\");\n        console.log(\"EntraceRateFeeBase after requires _comptrollerProxy:%s\", _comptrollerProxy);\n\n        comptrollerProxyToRate[_comptrollerProxy] = rate;\n\n        console.log(\"EntraceRateFeeBase after comptrollerProxyToRate\");\n        emit FundSettingsAdded(_comptrollerProxy, rate);\n        console.log(\"EntraceRateFeeBase after FundSettingsAdded\");\n    }\n\n    /// @notice Settles the fee\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settlementData Encoded args to use in calculating the settlement\n    /// @return settlementType_ The type of settlement\n    /// @return payer_ The payer of shares due\n    /// @return sharesDue_ The amount of shares due\n    function settle(\n        address _comptrollerProxy,\n        address,\n        IFeeManager.FeeHook,\n        bytes calldata _settlementData,\n        uint256\n    )\n        external\n        override\n        onlyFeeManager\n        returns (\n            IFeeManager.SettlementType settlementType_,\n            address payer_,\n            uint256 sharesDue_\n        )\n    {\n        uint256 sharesBought;\n        (payer_, , sharesBought) = __decodePostBuySharesSettlementData(_settlementData);\n\n        uint256 rate = comptrollerProxyToRate[_comptrollerProxy];\n        sharesDue_ = sharesBought.mul(rate).div(ONE_HUNDRED_PERCENT);\n\n        if (sharesDue_ == 0) {\n            return (IFeeManager.SettlementType.None, address(0), 0);\n        }\n\n        emit Settled(_comptrollerProxy, payer_, sharesDue_);\n\n        return (SETTLEMENT_TYPE, payer_, sharesDue_);\n    }\n\n    /// @notice Gets whether the fee settles and requires GAV on a particular hook\n    /// @param _hook The FeeHook\n    /// @return settles_ True if the fee settles on the _hook\n    /// @return usesGav_ True if the fee uses GAV during settle() for the _hook\n    function settlesOnHook(IFeeManager.FeeHook _hook)\n        external\n        view\n        override\n        returns (bool settles_, bool usesGav_)\n    {\n        if (_hook == IFeeManager.FeeHook.PostBuyShares) {\n            return (true, false);\n        }\n\n        return (false, false);\n    }\n\n    ///////////////////\n    // STATE GETTERS //\n    ///////////////////\n\n    /// @notice Gets the `rate` variable for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return rate_ The `rate` variable value\n    function getRateForFund(address _comptrollerProxy) external view returns (uint256 rate_) {\n        return comptrollerProxyToRate[_comptrollerProxy];\n    }\n\n    /// @notice Gets the `SETTLEMENT_TYPE` variable\n    /// @return settlementType_ The `SETTLEMENT_TYPE` variable value\n    function getSettlementType()\n        external\n        view\n        returns (IFeeManager.SettlementType settlementType_)\n    {\n        return SETTLEMENT_TYPE;\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/EntranceRateDirectFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/EntranceRateFeeBase.sol\";\nimport \"./utils/UpdatableFeeRecipientBase.sol\";\n\n/// @title EntranceRateDirectFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An EntranceRateFee that transfers the fee shares to a recipient\ncontract EntranceRateDirectFee is EntranceRateFeeBase, UpdatableFeeRecipientBase {\n    constructor(address _feeManager)\n        public\n        EntranceRateFeeBase(_feeManager, IFeeManager.SettlementType.Direct)\n    {}\n\n    /// @notice Add the initial fee settings for a fund\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\n    /// @dev onlyFeeManager validated by parent\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\n        public\n        override\n    {\n        super.addFundSettings(_comptrollerProxy, _settingsData);\n\n        (, address recipient) = abi.decode(_settingsData, (uint256, address));\n\n        if (recipient != address(0)) {\n            __setRecipientForFund(_comptrollerProxy, recipient);\n        }\n    }\n\n    /// @notice Gets the recipient of the fee for a given fund\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\n    /// @return recipient_ The recipient\n    function getRecipientForFund(address _comptrollerProxy)\n        public\n        view\n        override(FeeBase, SettableFeeRecipientBase)\n        returns (address recipient_)\n    {\n        return SettableFeeRecipientBase.getRecipientForFund(_comptrollerProxy);\n    }\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/EntranceRateBurnFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/EntranceRateFeeBase.sol\";\n\n/// @title EntranceRateBurnFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An EntranceRateFee that burns the fee shares\ncontract EntranceRateBurnFee is EntranceRateFeeBase {\n    constructor(address _feeManager)\n        public\n        EntranceRateFeeBase(_feeManager, IFeeManager.SettlementType.Burn)\n    {}\n}\n"
    },
    "contracts/release/extensions/fee-manager/fees/ExitRateBurnFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\n/*\n    This file is part of the Enzyme Protocol.\n\n    (c) Enzyme Council <council@enzyme.finance>\n\n    For the full license information, please view the LICENSE\n    file that was distributed with this source code.\n*/\n\npragma solidity 0.6.12;\n\nimport \"./utils/ExitRateFeeBase.sol\";\n\n/// @title ExitRateBurnFee Contract\n/// @author Enzyme Council <security@enzyme.finance>\n/// @notice An ExitRateFee that burns the fee shares\ncontract ExitRateBurnFee is ExitRateFeeBase {\n    constructor(address _feeManager)\n        public\n        ExitRateFeeBase(_feeManager, IFeeManager.SettlementType.Burn)\n    {}\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200,
      "details": {
        "yul": false
      }
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}