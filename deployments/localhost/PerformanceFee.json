{
  "address": "0xe1708FA6bb2844D5384613ef0846F9Bc1e8eC55E",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_feeManager",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "highWaterMark",
          "type": "uint256"
        }
      ],
      "name": "ActivatedForFund",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "rate",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "period",
          "type": "uint256"
        }
      ],
      "name": "FundSettingsAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prevSharePrice",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nextSharePrice",
          "type": "uint256"
        }
      ],
      "name": "LastSharePriceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prevHighWaterMark",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nextHighWaterMark",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "aggregateValueDue",
          "type": "uint256"
        }
      ],
      "name": "PaidOut",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "prevAggregateValueDue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "nextAggregateValueDue",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "int256",
          "name": "sharesOutstandingDiff",
          "type": "int256"
        }
      ],
      "name": "PerformanceUpdated",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "comptrollerProxy",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        }
      ],
      "name": "RecipientSetForFund",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "activateForFund",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_settingsData",
          "type": "bytes"
        }
      ],
      "name": "addFundSettings",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        }
      ],
      "name": "getFeeInfoForFund",
      "outputs": [
        {
          "components": [
            {
              "internalType": "uint16",
              "name": "rate",
              "type": "uint16"
            },
            {
              "internalType": "uint64",
              "name": "period",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "activated",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "lastPaid",
              "type": "uint64"
            },
            {
              "internalType": "uint256",
              "name": "highWaterMark",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "lastSharePrice",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "aggregateValueDue",
              "type": "uint256"
            }
          ],
          "internalType": "struct PerformanceFee.FeeInfo",
          "name": "feeInfo_",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getFeeManager",
      "outputs": [
        {
          "internalType": "address",
          "name": "feeManager_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        }
      ],
      "name": "getRecipientForFund",
      "outputs": [
        {
          "internalType": "address",
          "name": "recipient_",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "payout",
      "outputs": [
        {
          "internalType": "bool",
          "name": "isPayable_",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        }
      ],
      "name": "payoutAllowed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "payoutAllowed_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_recipient",
          "type": "address"
        }
      ],
      "name": "setRecipientForFund",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vaultProxy",
          "type": "address"
        },
        {
          "internalType": "enum IFeeManager.FeeHook",
          "name": "",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_gav",
          "type": "uint256"
        }
      ],
      "name": "settle",
      "outputs": [
        {
          "internalType": "enum IFeeManager.SettlementType",
          "name": "settlementType_",
          "type": "uint8"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "sharesDue_",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IFeeManager.FeeHook",
          "name": "_hook",
          "type": "uint8"
        }
      ],
      "name": "settlesOnHook",
      "outputs": [
        {
          "internalType": "bool",
          "name": "settles_",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "usesGav_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_comptrollerProxy",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_vaultProxy",
          "type": "address"
        },
        {
          "internalType": "enum IFeeManager.FeeHook",
          "name": "_hook",
          "type": "uint8"
        },
        {
          "internalType": "bytes",
          "name": "_settlementData",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "_gav",
          "type": "uint256"
        }
      ],
      "name": "update",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "enum IFeeManager.FeeHook",
          "name": "_hook",
          "type": "uint8"
        }
      ],
      "name": "updatesOnHook",
      "outputs": [
        {
          "internalType": "bool",
          "name": "updates_",
          "type": "bool"
        },
        {
          "internalType": "bool",
          "name": "usesGav_",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xdb993e278437fd13abb4e9daa19a9fb6b8d7e4625084146c86545c248d1078a0",
  "receipt": {
    "to": null,
    "from": "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266",
    "contractAddress": "0xe1708FA6bb2844D5384613ef0846F9Bc1e8eC55E",
    "transactionIndex": 0,
    "gasUsed": "2035169",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa1fa00fb17991b46d48f6ff591bacc5bda25093d7ab38ee050dcee04c3c1af43",
    "transactionHash": "0xdb993e278437fd13abb4e9daa19a9fb6b8d7e4625084146c86545c248d1078a0",
    "logs": [],
    "blockNumber": 14508061,
    "cumulativeGasUsed": "2035169",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x071586BA1b380B00B793Cc336fe01106B0BFbE6D"
  ],
  "linkedData": {
    "type": "FEE"
  },
  "solcInputHash": "e128c99a7ad98ab17bfe5eac6103458b",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_feeManager\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"highWaterMark\",\"type\":\"uint256\"}],\"name\":\"ActivatedForFund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"period\",\"type\":\"uint256\"}],\"name\":\"FundSettingsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevSharePrice\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextSharePrice\",\"type\":\"uint256\"}],\"name\":\"LastSharePriceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevHighWaterMark\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextHighWaterMark\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"aggregateValueDue\",\"type\":\"uint256\"}],\"name\":\"PaidOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"prevAggregateValueDue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"nextAggregateValueDue\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"int256\",\"name\":\"sharesOutstandingDiff\",\"type\":\"int256\"}],\"name\":\"PerformanceUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"comptrollerProxy\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"RecipientSetForFund\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"activateForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_settingsData\",\"type\":\"bytes\"}],\"name\":\"addFundSettings\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getFeeInfoForFund\",\"outputs\":[{\"components\":[{\"internalType\":\"uint16\",\"name\":\"rate\",\"type\":\"uint16\"},{\"internalType\":\"uint64\",\"name\":\"period\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"activated\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"lastPaid\",\"type\":\"uint64\"},{\"internalType\":\"uint256\",\"name\":\"highWaterMark\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lastSharePrice\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"aggregateValueDue\",\"type\":\"uint256\"}],\"internalType\":\"struct PerformanceFee.FeeInfo\",\"name\":\"feeInfo_\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFeeManager\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"feeManager_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"getRecipientForFund\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"recipient_\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"payout\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"isPayable_\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"}],\"name\":\"payoutAllowed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"payoutAllowed_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"setRecipientForFund\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"enum IFeeManager.FeeHook\",\"name\":\"\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gav\",\"type\":\"uint256\"}],\"name\":\"settle\",\"outputs\":[{\"internalType\":\"enum IFeeManager.SettlementType\",\"name\":\"settlementType_\",\"type\":\"uint8\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"sharesDue_\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IFeeManager.FeeHook\",\"name\":\"_hook\",\"type\":\"uint8\"}],\"name\":\"settlesOnHook\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"settles_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"usesGav_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_comptrollerProxy\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_vaultProxy\",\"type\":\"address\"},{\"internalType\":\"enum IFeeManager.FeeHook\",\"name\":\"_hook\",\"type\":\"uint8\"},{\"internalType\":\"bytes\",\"name\":\"_settlementData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"_gav\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"enum IFeeManager.FeeHook\",\"name\":\"_hook\",\"type\":\"uint8\"}],\"name\":\"updatesOnHook\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"updates_\",\"type\":\"bool\"},{\"internalType\":\"bool\",\"name\":\"usesGav_\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"Enzyme Council <security@enzyme.finance>\",\"details\":\"This contract assumes that all shares in the VaultProxy are shares outstanding, which is fine for this release. Even if they are not, they are still shares that are only claimable by the fund owner.\",\"kind\":\"dev\",\"methods\":{\"activateForFund(address,address)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\"}},\"addFundSettings(address,bytes)\":{\"details\":\"`highWaterMark`, `lastSharePrice`, and `activated` are set during activation\",\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\",\"_settingsData\":\"Encoded settings to apply to the fee for a fund\"}},\"getFeeInfoForFund(address)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy contract of the fund\"},\"returns\":{\"feeInfo_\":\"The feeInfo\"}},\"getFeeManager()\":{\"returns\":{\"feeManager_\":\"The `FEE_MANAGER` variable value\"}},\"getRecipientForFund(address)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy contract for the fund\"},\"returns\":{\"recipient_\":\"The recipient\"}},\"payout(address,address)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\"},\"returns\":{\"isPayable_\":\"True if shares outstanding can be paid out\"}},\"payoutAllowed(address)\":{\"details\":\"Payout is allowed if fees have not yet been settled in a crystallization period, and at least 1 crystallization period has passed since activation\",\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\"},\"returns\":{\"payoutAllowed_\":\"True if the fee payment is due\"}},\"setRecipientForFund(address,address)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy contract for the fund\",\"_recipient\":\"The fee recipient\"}},\"settle(address,address,uint8,bytes,uint256)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\",\"_gav\":\"The GAV of the fund\",\"_vaultProxy\":\"The VaultProxy of the fund\"},\"returns\":{\"_1\":\"(unused) The payer of shares due\",\"settlementType_\":\"The type of settlement\",\"sharesDue_\":\"The amount of shares due\"}},\"settlesOnHook(uint8)\":{\"params\":{\"_hook\":\"The FeeHook\"},\"returns\":{\"settles_\":\"True if the fee settles on the _hook\",\"usesGav_\":\"True if the fee uses GAV during settle() for the _hook\"}},\"update(address,address,uint8,bytes,uint256)\":{\"params\":{\"_comptrollerProxy\":\"The ComptrollerProxy of the fund\",\"_gav\":\"The GAV of the fund\",\"_hook\":\"The FeeHook being executed\",\"_settlementData\":\"Encoded args to use in calculating the settlement\",\"_vaultProxy\":\"The VaultProxy of the fund\"}},\"updatesOnHook(uint8)\":{\"params\":{\"_hook\":\"The FeeHook\"},\"returns\":{\"updates_\":\"True if the fee updates on the _hook\",\"usesGav_\":\"True if the fee uses GAV during update() for the _hook\"}}},\"title\":\"PerformanceFee Contract\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"activateForFund(address,address)\":{\"notice\":\"Activates the fee for a fund\"},\"addFundSettings(address,bytes)\":{\"notice\":\"Add the initial fee settings for a fund\"},\"getFeeInfoForFund(address)\":{\"notice\":\"Gets the feeInfo for a given fund\"},\"getFeeManager()\":{\"notice\":\"Gets the `FEE_MANAGER` variable\"},\"getRecipientForFund(address)\":{\"notice\":\"Gets the recipient of the fee for a given fund\"},\"payout(address,address)\":{\"notice\":\"Checks whether the shares outstanding for the fee can be paid out, and updates the info for the fee's last payout\"},\"payoutAllowed(address)\":{\"notice\":\"Checks whether the shares outstanding can be paid out\"},\"setRecipientForFund(address,address)\":{\"notice\":\"Sets the fee recipient for the given fund\"},\"settle(address,address,uint8,bytes,uint256)\":{\"notice\":\"Settles the fee and calculates shares due\"},\"settlesOnHook(uint8)\":{\"notice\":\"Gets whether the fee settles and requires GAV on a particular hook\"},\"update(address,address,uint8,bytes,uint256)\":{\"notice\":\"Updates the fee state after all fees have finished settle()\"},\"updatesOnHook(uint8)\":{\"notice\":\"Gets whether the fee updates and requires GAV on a particular hook\"}},\"notice\":\"A performance-based fee with configurable rate and crystallization period, using a high watermark\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/release/extensions/fee-manager/fees/PerformanceFee.sol\":\"PerformanceFee\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"details\":{\"constantOptimizer\":true,\"cse\":true,\"deduplicate\":true,\"jumpdestRemover\":true,\"orderLiterals\":true,\"peephole\":true,\"yul\":false},\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"@openzeppelin/contracts/math/SignedSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @title SignedSafeMath\\n * @dev Signed math operations with safety checks that revert on error.\\n */\\nlibrary SignedSafeMath {\\n    int256 constant private _INT256_MIN = -2**255;\\n\\n    /**\\n     * @dev Returns the multiplication of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(int256 a, int256 b) internal pure returns (int256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        require(!(a == -1 && b == _INT256_MIN), \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        int256 c = a * b;\\n        require(c / a == b, \\\"SignedSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two signed integers. Reverts on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(int256 a, int256 b) internal pure returns (int256) {\\n        require(b != 0, \\\"SignedSafeMath: division by zero\\\");\\n        require(!(b == -1 && a == _INT256_MIN), \\\"SignedSafeMath: division overflow\\\");\\n\\n        int256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a - b;\\n        require((b >= 0 && c <= a) || (b < 0 && c > a), \\\"SignedSafeMath: subtraction overflow\\\");\\n\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two signed integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(int256 a, int256 b) internal pure returns (int256) {\\n        int256 c = a + b;\\n        require((b >= 0 && c >= a) || (b < 0 && c < a), \\\"SignedSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n}\\n\",\"keccak256\":\"0xd17ac7e1d8f83d20d80e652adfed83da122f3a3c7b69fefa2985d85aebf0a3e9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC20} interface.\\n *\\n * This implementation is agnostic to the way tokens are created. This means\\n * that a supply mechanism has to be added in a derived contract using {_mint}.\\n * For a generic mechanism see {ERC20PresetMinterPauser}.\\n *\\n * TIP: For a detailed writeup see our guide\\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\\n * to implement supply mechanisms].\\n *\\n * We have followed general OpenZeppelin guidelines: functions revert instead\\n * of returning `false` on failure. This behavior is nonetheless conventional\\n * and does not conflict with the expectations of ERC20 applications.\\n *\\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\\n * This allows applications to reconstruct the allowance for all accounts just\\n * by listening to said events. Other implementations of the EIP may not emit\\n * these events, as it isn't required by the specification.\\n *\\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\\n * functions have been added to mitigate the well-known issues around setting\\n * allowances. See {IERC20-approve}.\\n */\\ncontract ERC20 is Context, IERC20 {\\n    using SafeMath for uint256;\\n\\n    mapping (address => uint256) private _balances;\\n\\n    mapping (address => mapping (address => uint256)) private _allowances;\\n\\n    uint256 private _totalSupply;\\n\\n    string private _name;\\n    string private _symbol;\\n    uint8 private _decimals;\\n\\n    /**\\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\\n     * a default value of 18.\\n     *\\n     * To select a different value for {decimals}, use {_setupDecimals}.\\n     *\\n     * All three of these values are immutable: they can only be set once during\\n     * construction.\\n     */\\n    constructor (string memory name_, string memory symbol_) public {\\n        _name = name_;\\n        _symbol = symbol_;\\n        _decimals = 18;\\n    }\\n\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() public view virtual returns (string memory) {\\n        return _name;\\n    }\\n\\n    /**\\n     * @dev Returns the symbol of the token, usually a shorter version of the\\n     * name.\\n     */\\n    function symbol() public view virtual returns (string memory) {\\n        return _symbol;\\n    }\\n\\n    /**\\n     * @dev Returns the number of decimals used to get its user representation.\\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\\n     *\\n     * Tokens usually opt for a value of 18, imitating the relationship between\\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\\n     * called.\\n     *\\n     * NOTE: This information is only used for _display_ purposes: it in\\n     * no way affects any of the arithmetic of the contract, including\\n     * {IERC20-balanceOf} and {IERC20-transfer}.\\n     */\\n    function decimals() public view virtual returns (uint8) {\\n        return _decimals;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-totalSupply}.\\n     */\\n    function totalSupply() public view virtual override returns (uint256) {\\n        return _totalSupply;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-balanceOf}.\\n     */\\n    function balanceOf(address account) public view virtual override returns (uint256) {\\n        return _balances[account];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transfer}.\\n     *\\n     * Requirements:\\n     *\\n     * - `recipient` cannot be the zero address.\\n     * - the caller must have a balance of at least `amount`.\\n     */\\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(_msgSender(), recipient, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-allowance}.\\n     */\\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\\n        return _allowances[owner][spender];\\n    }\\n\\n    /**\\n     * @dev See {IERC20-approve}.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\\n        _approve(_msgSender(), spender, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * @dev See {IERC20-transferFrom}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance. This is not\\n     * required by the EIP. See the note at the beginning of {ERC20}.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` and `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     * - the caller must have allowance for ``sender``'s tokens of at least\\n     * `amount`.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\\n        _transfer(sender, recipient, amount);\\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \\\"ERC20: transfer amount exceeds allowance\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     */\\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\\n     *\\n     * This is an alternative to {approve} that can be used as a mitigation for\\n     * problems described in {IERC20-approve}.\\n     *\\n     * Emits an {Approval} event indicating the updated allowance.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `spender` must have allowance for the caller of at least\\n     * `subtractedValue`.\\n     */\\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \\\"ERC20: decreased allowance below zero\\\"));\\n        return true;\\n    }\\n\\n    /**\\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\\n     *\\n     * This is internal function is equivalent to {transfer}, and can be used to\\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\\n     *\\n     * Emits a {Transfer} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `sender` cannot be the zero address.\\n     * - `recipient` cannot be the zero address.\\n     * - `sender` must have a balance of at least `amount`.\\n     */\\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\\n        require(sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        _beforeTokenTransfer(sender, recipient, amount);\\n\\n        _balances[sender] = _balances[sender].sub(amount, \\\"ERC20: transfer amount exceeds balance\\\");\\n        _balances[recipient] = _balances[recipient].add(amount);\\n        emit Transfer(sender, recipient, amount);\\n    }\\n\\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\\n     * the total supply.\\n     *\\n     * Emits a {Transfer} event with `from` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `to` cannot be the zero address.\\n     */\\n    function _mint(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        _beforeTokenTransfer(address(0), account, amount);\\n\\n        _totalSupply = _totalSupply.add(amount);\\n        _balances[account] = _balances[account].add(amount);\\n        emit Transfer(address(0), account, amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, reducing the\\n     * total supply.\\n     *\\n     * Emits a {Transfer} event with `to` set to the zero address.\\n     *\\n     * Requirements:\\n     *\\n     * - `account` cannot be the zero address.\\n     * - `account` must have at least `amount` tokens.\\n     */\\n    function _burn(address account, uint256 amount) internal virtual {\\n        require(account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        _beforeTokenTransfer(account, address(0), amount);\\n\\n        _balances[account] = _balances[account].sub(amount, \\\"ERC20: burn amount exceeds balance\\\");\\n        _totalSupply = _totalSupply.sub(amount);\\n        emit Transfer(account, address(0), amount);\\n    }\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\\n     *\\n     * This internal function is equivalent to `approve`, and can be used to\\n     * e.g. set automatic allowances for certain subsystems, etc.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `owner` cannot be the zero address.\\n     * - `spender` cannot be the zero address.\\n     */\\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\\n        require(owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        _allowances[owner][spender] = amount;\\n        emit Approval(owner, spender, amount);\\n    }\\n\\n    /**\\n     * @dev Sets {decimals} to a value other than the default one of 18.\\n     *\\n     * WARNING: This function should only be called from the constructor. Most\\n     * applications that interact with token contracts will not expect\\n     * {decimals} to ever change, and may work incorrectly if it does.\\n     */\\n    function _setupDecimals(uint8 decimals_) internal virtual {\\n        _decimals = decimals_;\\n    }\\n\\n    /**\\n     * @dev Hook that is called before any transfer of tokens. This includes\\n     * minting and burning.\\n     *\\n     * Calling conditions:\\n     *\\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\\n     * will be to transferred to `to`.\\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\\n     * - `from` and `to` are never both zero.\\n     *\\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\\n     */\\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\\n}\\n\",\"keccak256\":\"0xca0c2396dbeb3503b51abf4248ebf77a1461edad513c01529df51850a012bee3\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"../../utils/Context.sol\\\";\\nimport \\\"./ERC20.sol\\\";\\n\\n/**\\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\\n * tokens and those that they have an allowance for, in a way that can be\\n * recognized off-chain (via event analysis).\\n */\\nabstract contract ERC20Burnable is Context, ERC20 {\\n    using SafeMath for uint256;\\n\\n    /**\\n     * @dev Destroys `amount` tokens from the caller.\\n     *\\n     * See {ERC20-_burn}.\\n     */\\n    function burn(uint256 amount) public virtual {\\n        _burn(_msgSender(), amount);\\n    }\\n\\n    /**\\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\\n     * allowance.\\n     *\\n     * See {ERC20-_burn} and {ERC20-allowance}.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have allowance for ``accounts``'s tokens of at least\\n     * `amount`.\\n     */\\n    function burnFrom(address account, uint256 amount) public virtual {\\n        uint256 decreasedAllowance = allowance(account, _msgSender()).sub(amount, \\\"ERC20: burn amount exceeds allowance\\\");\\n\\n        _approve(account, _msgSender(), decreasedAllowance);\\n        _burn(account, amount);\\n    }\\n}\\n\",\"keccak256\":\"0x9c0eb3b0e11d2480d49991dc384f1e5f9c9b9967cc81944d50916a9b9c6c4984\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x5f02220344881ce43204ae4a6281145a67bc52c2bb1290a791857df3d19d78f5\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"../../math/SafeMath.sol\\\";\\nimport \\\"../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using SafeMath for uint256;\\n    using Address for address;\\n\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        // solhint-disable-next-line max-line-length\\n        require((value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).add(value);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 newAllowance = token.allowance(address(this), spender).sub(value, \\\"SafeERC20: decreased allowance below zero\\\");\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        if (returndata.length > 0) { // Return data is optional\\n            // solhint-disable-next-line max-line-length\\n            require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xf12dfbe97e6276980b83d2830bb0eb75e0cf4f3e626c2471137f82158ae6a0fc\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.2 <0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { size := extcodesize(account) }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\\n        (bool success, ) = recipient.call{ value: amount }(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain`call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n      return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value, string memory errorMessage) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.call{ value: value }(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data, string memory errorMessage) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\\n        require(isContract(target), \\\"Address: delegate call to non-contract\\\");\\n\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return _verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    function _verifyCallResult(bool success, bytes memory returndata, string memory errorMessage) private pure returns(bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                // solhint-disable-next-line no-inline-assembly\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x28911e614500ae7c607a432a709d35da25f3bc5ddc8bd12b278b66358070c0ea\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Context.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/*\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with GSN meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract Context {\\n    function _msgSender() internal view virtual returns (address payable) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes memory) {\\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\\n        return msg.data;\\n    }\\n}\\n\",\"keccak256\":\"0x8d3cb350f04ff49cfb10aef08d87f19dcbaecc8027b0bed12f3275cd12f38cf0\",\"license\":\"MIT\"},\"contracts/persistent/dispatcher/IDispatcher.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IDispatcher Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IDispatcher {\\n    function cancelMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function claimOwnership() external;\\n\\n    function deployVaultProxy(\\n        address _vaultLib,\\n        address _owner,\\n        address _vaultAccessor,\\n        string calldata _fundName\\n    ) external returns (address vaultProxy_);\\n\\n    function executeMigration(address _vaultProxy, bool _bypassFailure) external;\\n\\n    function getCurrentFundDeployer() external view returns (address currentFundDeployer_);\\n\\n    function getFundDeployerForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (address fundDeployer_);\\n\\n    function getMigrationRequestDetailsForVaultProxy(address _vaultProxy)\\n        external\\n        view\\n        returns (\\n            address nextFundDeployer_,\\n            address nextVaultAccessor_,\\n            address nextVaultLib_,\\n            uint256 executableTimestamp_\\n        );\\n\\n    function getMigrationTimelock() external view returns (uint256 migrationTimelock_);\\n\\n    function getNominatedOwner() external view returns (address nominatedOwner_);\\n\\n    function getOwner() external view returns (address owner_);\\n\\n    function getSharesTokenSymbol() external view returns (string memory sharesTokenSymbol_);\\n\\n    function getTimelockRemainingForMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (uint256 secondsRemaining_);\\n\\n    function hasExecutableMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasExecutableRequest_);\\n\\n    function hasMigrationRequest(address _vaultProxy)\\n        external\\n        view\\n        returns (bool hasMigrationRequest_);\\n\\n    function removeNominatedOwner() external;\\n\\n    function setCurrentFundDeployer(address _nextFundDeployer) external;\\n\\n    function setMigrationTimelock(uint256 _nextTimelock) external;\\n\\n    function setNominatedOwner(address _nextNominatedOwner) external;\\n\\n    function setSharesTokenSymbol(string calldata _nextSymbol) external;\\n\\n    function signalMigration(\\n        address _vaultProxy,\\n        address _nextVaultAccessor,\\n        address _nextVaultLib,\\n        bool _bypassFailure\\n    ) external;\\n}\\n\",\"keccak256\":\"0x0e6b0e6cf325d4f6332b8eb2b3c446b2ef3ca8456bdf0d12318d0fd9e90aeb30\",\"license\":\"GPL-3.0\"},\"contracts/persistent/external-positions/IExternalPosition.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n    (c) Enzyme Council <council@enzyme.finance>\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPosition Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IExternalPosition {\\n    function getDebtAssets() external returns (address[] memory, uint256[] memory);\\n\\n    function getManagedAssets() external returns (address[] memory, uint256[] memory);\\n\\n    function init(bytes memory) external;\\n\\n    function receiveCallFromVault(bytes memory) external;\\n}\\n\",\"keccak256\":\"0x00e6ea9721e5fd1e72215e4c744306097d7f8b1a834cced5d65a17a924f750ad\",\"license\":\"GPL-3.0\"},\"contracts/persistent/protocol-fee-reserve/interfaces/IProtocolFeeReserve1.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IProtocolFeeReserve1 Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev Each interface should inherit the previous interface,\\n/// e.g., `IProtocolFeeReserve2 is IProtocolFeeReserve1`\\ninterface IProtocolFeeReserve1 {\\n    function buyBackSharesViaTrustedVaultProxy(\\n        uint256 _sharesAmount,\\n        uint256 _mlnValue,\\n        uint256 _gav\\n    ) external returns (uint256 mlnAmountToBurn_);\\n}\\n\",\"keccak256\":\"0x2728878c423db523bc95189137e8c58d2d7db9f56bbd5c6b1f988c08b551fbab\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/VaultLibBase1.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./VaultLibBaseCore.sol\\\";\\n\\n/// @title VaultLibBase1 Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The first implementation of VaultLibBaseCore, with additional events and storage\\n/// @dev All subsequent implementations should inherit the previous implementation,\\n/// e.g., `VaultLibBase2 is VaultLibBase1`\\n/// DO NOT EDIT CONTRACT.\\nabstract contract VaultLibBase1 is VaultLibBaseCore {\\n    event AssetWithdrawn(address indexed asset, address indexed target, uint256 amount);\\n\\n    event TrackedAssetAdded(address asset);\\n\\n    event TrackedAssetRemoved(address asset);\\n\\n    address[] internal trackedAssets;\\n    mapping(address => bool) internal assetToIsTracked;\\n}\\n\",\"keccak256\":\"0xa4dac1e4cdb311a2ab187135355357d8790c505ef36dd912c057fe53743d30b5\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/VaultLibBase2.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./VaultLibBase1.sol\\\";\\n\\n/// @title VaultLibBase2 Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The first implementation of VaultLibBase1, with additional events and storage\\n/// @dev All subsequent implementations should inherit the previous implementation,\\n/// e.g., `VaultLibBase2 is VaultLibBase1`\\n/// DO NOT EDIT CONTRACT.\\nabstract contract VaultLibBase2 is VaultLibBase1 {\\n    event AssetManagerAdded(address manager);\\n\\n    event AssetManagerRemoved(address manager);\\n\\n    event EthReceived(address indexed sender, uint256 amount);\\n\\n    event ExternalPositionAdded(address indexed externalPosition);\\n\\n    event ExternalPositionRemoved(address indexed externalPosition);\\n\\n    event FreelyTransferableSharesSet();\\n\\n    event NominatedOwnerRemoved(address indexed nominatedOwner);\\n\\n    event NominatedOwnerSet(address indexed nominatedOwner);\\n\\n    event ProtocolFeePaidInShares(uint256 sharesAmount);\\n\\n    event ProtocolFeeSharesBoughtBack(uint256 sharesAmount, uint256 mlnValue, uint256 mlnBurned);\\n\\n    event OwnershipTransferred(address indexed prevOwner, address indexed nextOwner);\\n\\n    // In order to make transferability guarantees to liquidity pools and other smart contracts\\n    // that hold/treat shares as generic ERC20 tokens, a permanent guarantee on transferability\\n    // is required. Once set as `true`, freelyTransferableShares should never be unset.\\n    bool internal freelyTransferableShares;\\n    address internal nominatedOwner;\\n    address[] internal activeExternalPositions;\\n    mapping(address => bool) internal accountToIsAssetManager;\\n    mapping(address => bool) internal externalPositionToIsActive;\\n}\\n\",\"keccak256\":\"0x5938e7fe7b3aff17cc6d1e3f62300b15ad3f43ada0efc950cc488e9f3dfa324d\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/VaultLibBaseCore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./interfaces/IMigratableVault.sol\\\";\\nimport \\\"./utils/ProxiableVaultLib.sol\\\";\\nimport \\\"./utils/SharesTokenBase.sol\\\";\\n\\n/// @title VaultLibBaseCore Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A persistent contract containing all required storage variables and\\n/// required functions for a VaultLib implementation\\n/// @dev DO NOT EDIT CONTRACT. If new events or storage are necessary, they should be added to\\n/// a numbered VaultLibBaseXXX that inherits the previous base. See VaultLibBase1.\\nabstract contract VaultLibBaseCore is IMigratableVault, ProxiableVaultLib, SharesTokenBase {\\n    event AccessorSet(address prevAccessor, address nextAccessor);\\n\\n    event MigratorSet(address prevMigrator, address nextMigrator);\\n\\n    event OwnerSet(address prevOwner, address nextOwner);\\n\\n    event VaultLibSet(address prevVaultLib, address nextVaultLib);\\n\\n    address internal accessor;\\n    address internal creator;\\n    address internal migrator;\\n    address internal owner;\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Initializes the VaultProxy with core configuration\\n    /// @param _owner The address to set as the fund owner\\n    /// @param _accessor The address to set as the permissioned accessor of the VaultLib\\n    /// @param _fundName The name of the fund\\n    /// @dev Serves as a per-proxy pseudo-constructor\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external override {\\n        require(creator == address(0), \\\"init: Proxy already initialized\\\");\\n        creator = msg.sender;\\n        sharesName = _fundName;\\n\\n        __setAccessor(_accessor);\\n        __setOwner(_owner);\\n\\n        emit VaultLibSet(address(0), getVaultLib());\\n    }\\n\\n    /// @notice Sets the permissioned accessor of the VaultLib\\n    /// @param _nextAccessor The address to set as the permissioned accessor of the VaultLib\\n    function setAccessor(address _nextAccessor) external override {\\n        require(msg.sender == creator, \\\"setAccessor: Only callable by the contract creator\\\");\\n\\n        __setAccessor(_nextAccessor);\\n    }\\n\\n    /// @notice Sets the VaultLib target for the VaultProxy\\n    /// @param _nextVaultLib The address to set as the VaultLib\\n    /// @dev This function is absolutely critical. __updateCodeAddress() validates that the\\n    /// target is a valid Proxiable contract instance.\\n    /// Does not block _nextVaultLib from being the same as the current VaultLib\\n    function setVaultLib(address _nextVaultLib) external override {\\n        require(msg.sender == creator, \\\"setVaultLib: Only callable by the contract creator\\\");\\n\\n        address prevVaultLib = getVaultLib();\\n\\n        __updateCodeAddress(_nextVaultLib);\\n\\n        emit VaultLibSet(prevVaultLib, _nextVaultLib);\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Checks whether an account is allowed to migrate the VaultProxy\\n    /// @param _who The account to check\\n    /// @return canMigrate_ True if the account is allowed to migrate the VaultProxy\\n    function canMigrate(address _who) public view virtual override returns (bool canMigrate_) {\\n        return _who == owner || _who == migrator;\\n    }\\n\\n    /// @notice Gets the VaultLib target for the VaultProxy\\n    /// @return vaultLib_ The address of the VaultLib target\\n    function getVaultLib() public view returns (address vaultLib_) {\\n        assembly {\\n            // solium-disable-line\\n            vaultLib_ := sload(0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc)\\n        }\\n        return vaultLib_;\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    /// @dev Helper to set the permissioned accessor of the VaultProxy.\\n    /// Does not prevent the prevAccessor from being the _nextAccessor.\\n    function __setAccessor(address _nextAccessor) internal {\\n        require(_nextAccessor != address(0), \\\"__setAccessor: _nextAccessor cannot be empty\\\");\\n        address prevAccessor = accessor;\\n\\n        accessor = _nextAccessor;\\n\\n        emit AccessorSet(prevAccessor, _nextAccessor);\\n    }\\n\\n    /// @dev Helper to set the owner of the VaultProxy\\n    function __setOwner(address _nextOwner) internal {\\n        require(_nextOwner != address(0), \\\"__setOwner: _nextOwner cannot be empty\\\");\\n        address prevOwner = owner;\\n        require(_nextOwner != prevOwner, \\\"__setOwner: _nextOwner is the current owner\\\");\\n\\n        owner = _nextOwner;\\n\\n        emit OwnerSet(prevOwner, _nextOwner);\\n    }\\n}\\n\",\"keccak256\":\"0xc518a9735a8145f064817fa21c1cc57eba7d3396a06320b7abde187b87613074\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/interfaces/IExternalPositionVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionVault interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// Provides an interface to get the externalPositionLib for a given type from the Vault\\ninterface IExternalPositionVault {\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\",\"keccak256\":\"0x3c047551a9bab8cb84299c4cf17d0435f1d4d0791ecc1d03e0d55cb3450baad6\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFreelyTransferableSharesVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Provides the interface for determining whether a vault's shares\\n/// are guaranteed to be freely transferable.\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IFreelyTransferableSharesVault {\\n    function sharesAreFreelyTransferable()\\n        external\\n        view\\n        returns (bool sharesAreFreelyTransferable_);\\n}\\n\",\"keccak256\":\"0xe31f063493e6e3a4434eaa5629c0a706b8fa0569aff3f4ef9d62e27a1928cfa0\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/interfaces/IMigratableVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IMigratableVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @dev DO NOT EDIT CONTRACT\\ninterface IMigratableVault {\\n    function canMigrate(address _who) external view returns (bool canMigrate_);\\n\\n    function init(\\n        address _owner,\\n        address _accessor,\\n        string calldata _fundName\\n    ) external;\\n\\n    function setAccessor(address _nextAccessor) external;\\n\\n    function setVaultLib(address _nextVaultLib) external;\\n}\\n\",\"keccak256\":\"0x8e1355a7efa8ec2172f5c9b532071def392b86ab1e5534d2fc73417a6e9f7238\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/utils/ProxiableVaultLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title ProxiableVaultLib Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A contract that defines the upgrade behavior for VaultLib instances\\n/// @dev The recommended implementation of the target of a proxy according to EIP-1822 and EIP-1967\\n/// Code position in storage is `bytes32(uint256(keccak256('eip1967.proxy.implementation')) - 1)`,\\n/// which is \\\"0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc\\\".\\nabstract contract ProxiableVaultLib {\\n    /// @dev Updates the target of the proxy to be the contract at _nextVaultLib\\n    function __updateCodeAddress(address _nextVaultLib) internal {\\n        require(\\n            bytes32(0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5) ==\\n                ProxiableVaultLib(_nextVaultLib).proxiableUUID(),\\n            \\\"__updateCodeAddress: _nextVaultLib not compatible\\\"\\n        );\\n        assembly {\\n            // solium-disable-line\\n            sstore(\\n                0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc,\\n                _nextVaultLib\\n            )\\n        }\\n    }\\n\\n    /// @notice Returns a unique bytes32 hash for VaultLib instances\\n    /// @return uuid_ The bytes32 hash representing the UUID\\n    /// @dev The UUID is `bytes32(keccak256('mln.proxiable.vaultlib'))`\\n    function proxiableUUID() public pure returns (bytes32 uuid_) {\\n        return 0x027b9570e9fedc1a80b937ae9a06861e5faef3992491af30b684a64b3fbec7a5;\\n    }\\n}\\n\",\"keccak256\":\"0x47123e1fd95e335b312d378e651a627a674f32df372bcfe36c1128ab91122f76\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/utils/SharesTokenBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./VaultLibSafeMath.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title StandardERC20 Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Contains the storage, events, and default logic of an ERC20-compliant contract.\\n/// @dev The logic can be overridden by VaultLib implementations.\\n/// Adapted from OpenZeppelin 3.2.0.\\n/// DO NOT EDIT THIS CONTRACT.\\nabstract contract SharesTokenBase {\\n    using VaultLibSafeMath for uint256;\\n\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n    /**\\n     * @dev Emitted after aTokens are burned\\n     * @param from The owner of the aTokens, getting them burned\\n     * @param target The address that will receive the underlying\\n     * @param value The amount being burned\\n     **/\\n    event Burn(address indexed from, address indexed target, uint256 value);\\n\\n    string internal sharesName;\\n    string internal sharesSymbol;\\n    uint256 internal sharesTotalSupply;\\n    mapping(address => uint256) internal sharesBalances;\\n    mapping(address => mapping(address => uint256)) internal sharesAllowances;\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @dev Standard implementation of ERC20's approve(). Can be overridden.\\n    function approve(address _spender, uint256 _amount) public virtual returns (bool) {\\n        __approve(msg.sender, _spender, _amount);\\n        return true;\\n    }\\n\\n    /// @dev Standard implementation of ERC20's transfer(). Can be overridden.\\n    function transfer(address _recipient, uint256 _amount) public virtual returns (bool) {\\n        __transfer(msg.sender, _recipient, _amount);\\n        return true;\\n    }\\n\\n    /// @dev Standard implementation of ERC20's transferFrom(). Can be overridden.\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) public virtual returns (bool) {\\n        __transfer(_sender, _recipient, _amount);\\n        __approve(\\n            _sender,\\n            msg.sender,\\n            sharesAllowances[_sender][msg.sender].sub(\\n                _amount,\\n                \\\"ERC20: transfer amount exceeds allowance\\\"\\n            )\\n        );\\n        return true;\\n    }\\n\\n    // EXTERNAL FUNCTIONS - VIEW\\n\\n    /// @dev Standard implementation of ERC20's allowance(). Can be overridden.\\n    function allowance(address _owner, address _spender) public view virtual returns (uint256) {\\n        return sharesAllowances[_owner][_spender];\\n    }\\n\\n    /// @dev Standard implementation of ERC20's balanceOf(). Can be overridden.\\n    function balanceOf(address _account) public view virtual returns (uint256) {\\n        return sharesBalances[_account];\\n    }\\n\\n    /// @dev Standard implementation of ERC20's decimals(). Can not be overridden.\\n    function decimals() public pure returns (uint8) {\\n        return 18;\\n    }\\n\\n    /// @dev Standard implementation of ERC20's name(). Can be overridden.\\n    function name() public view virtual returns (string memory) {\\n        return sharesName;\\n    }\\n\\n    /// @dev Standard implementation of ERC20's symbol(). Can be overridden.\\n    function symbol() public view virtual returns (string memory) {\\n        return sharesSymbol;\\n    }\\n\\n    /// @dev Standard implementation of ERC20's totalSupply(). Can be overridden.\\n    function totalSupply() public view virtual returns (uint256) {\\n        return sharesTotalSupply;\\n    }\\n\\n    // INTERNAL FUNCTIONS\\n\\n    /// @dev Helper for approve(). Can be overridden.\\n    function __approve(\\n        address _owner,\\n        address _spender,\\n        uint256 _amount\\n    ) internal virtual {\\n        require(_owner != address(0), \\\"ERC20: approve from the zero address\\\");\\n        require(_spender != address(0), \\\"ERC20: approve to the zero address\\\");\\n\\n        sharesAllowances[_owner][_spender] = _amount;\\n        emit Approval(_owner, _spender, _amount);\\n    }\\n\\n    /// @dev Helper to burn tokens from an account. Can be overridden.\\n    function __burn(address _account, uint256 _amount) internal virtual {\\n        console.log(\\\"SharesTokeBase:Burning account:%s\\\", _account);\\n        console.log(\\\"SharesTokeBase:Burning amount:%s\\\", _amount);\\n        console.log(\\\"SharesTokeBase:Burning current:%s\\\", sharesBalances[_account]);\\n\\n        require(_account != address(0), \\\"ERC20: burn from the zero address\\\");\\n\\n        sharesBalances[_account] = sharesBalances[_account].sub(\\n            _amount,\\n            \\\"ERC20: burn amount exceeds balance\\\"\\n        );\\n        sharesTotalSupply = sharesTotalSupply.sub(_amount);\\n        emit Transfer(_account, address(0), _amount);\\n    }\\n\\n    /// @dev Helper to mint tokens to an account. Can be overridden.\\n    function __mint(address _account, uint256 _amount) internal virtual {\\n        require(_account != address(0), \\\"ERC20: mint to the zero address\\\");\\n\\n        sharesTotalSupply = sharesTotalSupply.add(_amount);\\n        sharesBalances[_account] = sharesBalances[_account].add(_amount);\\n        emit Transfer(address(0), _account, _amount);\\n    }\\n\\n    /// @dev Helper to transfer tokens between accounts. Can be overridden.\\n    function __transfer(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) internal virtual {\\n        require(_sender != address(0), \\\"ERC20: transfer from the zero address\\\");\\n        require(_recipient != address(0), \\\"ERC20: transfer to the zero address\\\");\\n\\n        sharesBalances[_sender] = sharesBalances[_sender].sub(\\n            _amount,\\n            \\\"ERC20: transfer amount exceeds balance\\\"\\n        );\\n        sharesBalances[_recipient] = sharesBalances[_recipient].add(_amount);\\n        emit Transfer(_sender, _recipient, _amount);\\n    }\\n}\\n\",\"keccak256\":\"0xd0bb4b4652a21fc9b9a7b0eae962085fabb18935e1f66592507673f65710d99e\",\"license\":\"GPL-3.0\"},\"contracts/persistent/vault/utils/VaultLibSafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title VaultLibSafeMath library\\n/// @notice A narrowed, verbatim implementation of OpenZeppelin 3.2.0 SafeMath\\n/// for use with VaultLib\\n/// @dev Preferred to importing from npm to guarantee consistent logic and revert reasons\\n/// between VaultLib implementations\\n/// DO NOT EDIT THIS CONTRACT\\nlibrary VaultLibSafeMath {\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"VaultLibSafeMath: addition overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return sub(a, b, \\\"VaultLibSafeMath: subtraction overflow\\\");\\n    }\\n\\n    function sub(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        uint256 c = a - b;\\n\\n        return c;\\n    }\\n\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) {\\n            return 0;\\n        }\\n\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"VaultLibSafeMath: multiplication overflow\\\");\\n\\n        return c;\\n    }\\n\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return div(a, b, \\\"VaultLibSafeMath: division by zero\\\");\\n    }\\n\\n    function div(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        uint256 c = a / b;\\n\\n        return c;\\n    }\\n\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        return mod(a, b, \\\"VaultLibSafeMath: modulo by zero\\\");\\n    }\\n\\n    function mod(\\n        uint256 a,\\n        uint256 b,\\n        string memory errorMessage\\n    ) internal pure returns (uint256) {\\n        require(b != 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xc056fcbf5f498fea6a12ae7f470bb4246297355c3117b1bd01d0edf207da947d\",\"license\":\"GPL-3.0\"},\"contracts/release/core/fund-deployer/IFundDeployer.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IFundDeployer Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IFundDeployer {\\n    function getOwner() external view returns (address);\\n\\n    function hasReconfigurationRequest(address) external view returns (bool);\\n\\n    function isAllowedBuySharesOnBehalfCaller(address) external view returns (bool);\\n\\n    function isAllowedVaultCall(\\n        address,\\n        bytes4,\\n        bytes32\\n    ) external view returns (bool);\\n\\n    function createNewFund(\\n        address _fundOwner,\\n        string calldata _fundName,\\n        address _denominationAsset,\\n        uint256 _sharesActionTimelock,\\n        bytes calldata _feeManagerConfigData,\\n        bytes calldata _policyManagerConfigData\\n    ) external returns (address, address);\\n\\n    function getVaultLib() external view returns (address);\\n\\n    function getComptrollerLib() external view returns (address comptrollerLib_);\\n}\\n\",\"keccak256\":\"0x9b5ca131a671abc04c69936268889177db0952004849df65947d1beddd6c9daf\",\"license\":\"GPL-3.0\"},\"contracts/release/core/fund/comptroller/ComptrollerLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../../../persistent/dispatcher/IDispatcher.sol\\\";\\nimport \\\"../../../../persistent/external-positions/IExternalPosition.sol\\\";\\nimport \\\"../../../extensions/IExtension.sol\\\";\\nimport \\\"../../../extensions/fee-manager/IFeeManager.sol\\\";\\nimport \\\"../../../extensions/policy-manager/IPolicyManager.sol\\\";\\nimport \\\"../../../infrastructure/asset-finality/IAssetFinalityResolver.sol\\\";\\nimport \\\"../../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\\\";\\nimport \\\"../../../infrastructure/gas-relayer/IGasRelayPaymaster.sol\\\";\\nimport \\\"../../../infrastructure/gas-relayer/IGasRelayPaymasterDepositor.sol\\\";\\nimport \\\"../../../infrastructure/value-interpreter/IValueInterpreter.sol\\\";\\nimport \\\"../../../utils/beacon-proxy/IBeaconProxyFactory.sol\\\";\\nimport \\\"../../../utils/AddressArrayLib.sol\\\";\\nimport \\\"../../fund-deployer/IFundDeployer.sol\\\";\\nimport \\\"../vault/IVault.sol\\\";\\nimport \\\"./IComptroller.sol\\\";\\n\\n/// @title ComptrollerLib Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The core logic library shared by all funds\\ncontract ComptrollerLib is IComptroller, IGasRelayPaymasterDepositor, GasRelayRecipientMixin {\\n    using AddressArrayLib for address[];\\n    using SafeMath for uint256;\\n    using SafeERC20 for ERC20;\\n\\n    event AutoProtocolFeeSharesBuybackSet(bool autoProtocolFeeSharesBuyback);\\n\\n    event BuyBackMaxProtocolFeeSharesFailed(\\n        bytes indexed failureReturnData,\\n        uint256 sharesAmount,\\n        uint256 buybackValueInMln,\\n        uint256 gav\\n    );\\n    event DeactivateFeeManagerFailed();\\n\\n    event GasRelayPaymasterSet(address gasRelayPaymaster);\\n\\n    event MigratedSharesDuePaid(uint256 sharesDue);\\n\\n    event PayProtocolFeeDuringDestructFailed();\\n\\n    event PreRedeemSharesHookFailed(\\n        bytes indexed failureReturnData,\\n        address indexed redeemer,\\n        uint256 sharesAmount\\n    );\\n\\n    event RedeemSharesInKindCalcGavFailed();\\n\\n    event SharesBought(\\n        address indexed buyer,\\n        uint256 investmentAmount,\\n        uint256 sharesIssued,\\n        uint256 sharesReceived\\n    );\\n\\n    event SharesRedeemed(\\n        address indexed redeemer,\\n        address indexed recipient,\\n        uint256 sharesAmount,\\n        address[] receivedAssets,\\n        uint256[] receivedAssetAmounts\\n    );\\n\\n    event VaultProxySet(address vaultProxy);\\n\\n    // Constants and immutables - shared by all proxies\\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\\n    uint256 private constant SHARES_UNIT = 10**18;\\n    address\\n        private constant SPECIFIC_ASSET_REDEMPTION_DUMMY_FORFEIT_ADDRESS = 0x000000000000000000000000000000000000aaaa;\\n    address private immutable ASSET_FINALITY_RESOLVER;\\n    address private immutable DISPATCHER;\\n    address private immutable EXTERNAL_POSITION_MANAGER;\\n    address private immutable FUND_DEPLOYER;\\n    address private immutable FEE_MANAGER;\\n    address private immutable INTEGRATION_MANAGER;\\n    address private immutable MLN_TOKEN;\\n    address private immutable POLICY_MANAGER;\\n    address private immutable PROTOCOL_FEE_RESERVE;\\n    address private immutable VALUE_INTERPRETER;\\n    address private immutable WETH_TOKEN;\\n\\n    // Pseudo-constants (can only be set once)\\n\\n    address internal denominationAsset;\\n    address internal vaultProxy;\\n    // True only for the one non-proxy\\n    bool internal isLib;\\n\\n    // Storage\\n\\n    // Attempts to buy back protocol fee shares immediately after collection\\n    bool internal autoProtocolFeeSharesBuyback;\\n    // A reverse-mutex, granting atomic permission for particular contracts to make vault calls\\n    bool internal permissionedVaultActionAllowed;\\n    // A mutex to protect against reentrancy\\n    bool internal reentranceLocked;\\n    // A timelock after the last time shares were bought for an account\\n    // that must expire before that account transfers or redeems their shares\\n    uint256 internal sharesActionTimelock;\\n    mapping(address => uint256) internal acctToLastSharesBoughtTimestamp;\\n    // The contract which manages paying gas relayers\\n    address private gasRelayPaymaster;\\n\\n    ///////////////\\n    // MODIFIERS //\\n    ///////////////\\n\\n    modifier allowsPermissionedVaultAction {\\n        __assertPermissionedVaultActionNotAllowed();\\n        permissionedVaultActionAllowed = true;\\n        _;\\n        permissionedVaultActionAllowed = false;\\n    }\\n\\n    modifier locksReentrance() {\\n        __assertNotReentranceLocked();\\n        reentranceLocked = true;\\n        _;\\n        reentranceLocked = false;\\n    }\\n\\n    modifier onlyFundDeployer() {\\n        __assertIsFundDeployer();\\n        _;\\n    }\\n    modifier onlyGasRelayPaymaster() {\\n        __assertIsGasRelayPaymaster();\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        __assertIsOwner(__msgSender());\\n        _;\\n    }\\n\\n    modifier onlyOwnerNotRelayable() {\\n        __assertIsOwner(msg.sender);\\n        _;\\n    }\\n\\n    // ASSERTION HELPERS\\n\\n    // Modifiers are inefficient in terms of contract size,\\n    // so we use helper functions to prevent repetitive inlining of expensive string values.\\n\\n    function __assertIsFundDeployer() private view {\\n        require(msg.sender == getFundDeployer(), \\\"Only FundDeployer callable\\\");\\n    }\\n\\n    function __assertIsGasRelayPaymaster() private view {\\n        require(msg.sender == getGasRelayPaymaster(), \\\"Only Gas Relay Paymaster callable\\\");\\n    }\\n\\n    function __assertIsOwner(address _who) private view {\\n        require(_who == IVault(getVaultProxy()).getOwner(), \\\"Only fund owner callable\\\");\\n    }\\n\\n    function __assertNotReentranceLocked() private view {\\n        require(!reentranceLocked, \\\"Re-entrance\\\");\\n    }\\n\\n    function __assertPermissionedVaultActionNotAllowed() private view {\\n        require(!permissionedVaultActionAllowed, \\\"Vault action re-entrance\\\");\\n    }\\n\\n    function __assertSharesActionNotTimelocked(address _vaultProxy, address _account)\\n        private\\n        view\\n    {\\n        uint256 lastSharesBoughtTimestamp = getLastSharesBoughtTimestampForAccount(_account);\\n\\n        require(\\n            lastSharesBoughtTimestamp == 0 ||\\n                block.timestamp.sub(lastSharesBoughtTimestamp) >= getSharesActionTimelock() ||\\n                __hasPendingMigrationOrReconfiguration(_vaultProxy),\\n            \\\"Shares action timelocked\\\"\\n        );\\n    }\\n\\n    constructor(\\n        address _dispatcher,\\n        address _protocolFeeReserve,\\n        address _fundDeployer,\\n        address _valueInterpreter,\\n        address _externalPositionManager,\\n        address _feeManager,\\n        address _integrationManager,\\n        address _policyManager,\\n        address _assetFinalityResolver,\\n        address _gasRelayPaymasterFactory,\\n        address _mlnToken,\\n        address _wethToken\\n    ) public GasRelayRecipientMixin(_gasRelayPaymasterFactory) {\\n        ASSET_FINALITY_RESOLVER = _assetFinalityResolver;\\n        DISPATCHER = _dispatcher;\\n        EXTERNAL_POSITION_MANAGER = _externalPositionManager;\\n        FEE_MANAGER = _feeManager;\\n        FUND_DEPLOYER = _fundDeployer;\\n        INTEGRATION_MANAGER = _integrationManager;\\n        MLN_TOKEN = _mlnToken;\\n        POLICY_MANAGER = _policyManager;\\n        PROTOCOL_FEE_RESERVE = _protocolFeeReserve;\\n        VALUE_INTERPRETER = _valueInterpreter;\\n        WETH_TOKEN = _wethToken;\\n        isLib = true;\\n    }\\n\\n    /////////////\\n    // GENERAL //\\n    /////////////\\n\\n    /// @notice Calls a specified action on an Extension\\n    /// @param _extension The Extension contract to call (e.g., FeeManager)\\n    /// @param _actionId An ID representing the action to take on the extension (see extension)\\n    /// @param _callArgs The encoded data for the call\\n    /// @dev Used to route arbitrary calls, so that msg.sender is the ComptrollerProxy\\n    /// (for access control). Uses a mutex of sorts that allows \\\"permissioned vault actions\\\"\\n    /// during calls originating from this function.\\n    function callOnExtension(\\n        address _extension,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external override locksReentrance allowsPermissionedVaultAction {\\n        require(\\n            _extension == getFeeManager() ||\\n                _extension == getIntegrationManager() ||\\n                _extension == getExternalPositionManager(),\\n            \\\"callOnExtension: _extension invalid\\\"\\n        );\\n\\n        IExtension(_extension).receiveCallFromComptroller(__msgSender(), _actionId, _callArgs);\\n    }\\n\\n    /// @notice Makes an arbitrary call with the VaultProxy contract as the sender\\n    /// @param _contract The contract to call\\n    /// @param _selector The selector to call\\n    /// @param _encodedArgs The encoded arguments for the call\\n    /// @return returnData_ The data returned by the call\\n    function vaultCallOnContract(\\n        address _contract,\\n        bytes4 _selector,\\n        bytes calldata _encodedArgs\\n    ) external onlyOwner returns (bytes memory returnData_) {\\n        require(\\n            IFundDeployer(getFundDeployer()).isAllowedVaultCall(\\n                _contract,\\n                _selector,\\n                keccak256(_encodedArgs)\\n            ),\\n            \\\"vaultCallOnContract: Not allowed\\\"\\n        );\\n\\n        return\\n            IVault(getVaultProxy()).callOnContract(\\n                _contract,\\n                abi.encodePacked(_selector, _encodedArgs)\\n            );\\n    }\\n\\n    /// @dev Helper to check if a VaultProxy has a pending migration or reconfiguration request\\n    function __hasPendingMigrationOrReconfiguration(address _vaultProxy)\\n        private\\n        view\\n        returns (bool hasPendingMigrationOrReconfiguration)\\n    {\\n        return\\n            IDispatcher(getDispatcher()).hasMigrationRequest(_vaultProxy) ||\\n            IFundDeployer(getFundDeployer()).hasReconfigurationRequest(_vaultProxy);\\n    }\\n\\n    //////////////////\\n    // PROTOCOL FEE //\\n    //////////////////\\n\\n    /// @notice Buys back shares collected as protocol fee at a discounted shares price, using MLN\\n    /// @param _sharesAmount The amount of shares to buy back\\n    function buyBackProtocolFeeShares(uint256 _sharesAmount) external {\\n        address vaultProxyCopy = vaultProxy;\\n        require(\\n            IVault(vaultProxyCopy).canManageAssets(__msgSender()),\\n            \\\"buyBackProtocolFeeShares: Unauthorized\\\"\\n        );\\n\\n        uint256 gav = calcGav(true);\\n\\n        IVault(vaultProxyCopy).buyBackProtocolFeeShares(\\n            _sharesAmount,\\n            __getBuybackValueInMln(vaultProxyCopy, _sharesAmount, gav),\\n            gav\\n        );\\n    }\\n\\n    /// @notice Sets whether to attempt to buyback protocol fee shares immediately when collected\\n    /// @param _nextAutoProtocolFeeSharesBuyback True if protocol fee shares should be attempted\\n    /// to be bought back immediately when collected\\n    function setAutoProtocolFeeSharesBuyback(bool _nextAutoProtocolFeeSharesBuyback)\\n        external\\n        onlyOwner\\n    {\\n        autoProtocolFeeSharesBuyback = _nextAutoProtocolFeeSharesBuyback;\\n\\n        emit AutoProtocolFeeSharesBuybackSet(_nextAutoProtocolFeeSharesBuyback);\\n    }\\n\\n    /// @dev Helper to buyback the max available protocol fee shares, during an auto-buyback\\n    function __buyBackMaxProtocolFeeShares(address _vaultProxy, uint256 _gav) private {\\n        uint256 sharesAmount = ERC20(_vaultProxy).balanceOf(getProtocolFeeReserve());\\n        uint256 buybackValueInMln = __getBuybackValueInMln(_vaultProxy, sharesAmount, _gav);\\n\\n        try\\n            IVault(_vaultProxy).buyBackProtocolFeeShares(sharesAmount, buybackValueInMln, _gav)\\n         {} catch (bytes memory reason) {\\n            emit BuyBackMaxProtocolFeeSharesFailed(reason, sharesAmount, buybackValueInMln, _gav);\\n        }\\n    }\\n\\n    /// @dev Helper to buyback the max available protocol fee shares\\n    function __getBuybackValueInMln(\\n        address _vaultProxy,\\n        uint256 _sharesAmount,\\n        uint256 _gav\\n    ) private returns (uint256 buybackValueInMln_) {\\n        address denominationAssetCopy = getDenominationAsset();\\n\\n        uint256 grossShareValue = __calcGrossShareValue(\\n            _gav,\\n            ERC20(_vaultProxy).totalSupply(),\\n            10**uint256(ERC20(denominationAssetCopy).decimals())\\n        );\\n\\n        uint256 buybackValueInDenominationAsset = grossShareValue.mul(_sharesAmount).div(\\n            SHARES_UNIT\\n        );\\n\\n        return\\n            IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\\n                denominationAssetCopy,\\n                buybackValueInDenominationAsset,\\n                getMlnToken()\\n            );\\n    }\\n\\n    ////////////////////////////////\\n    // PERMISSIONED VAULT ACTIONS //\\n    ////////////////////////////////\\n\\n    /// @notice Makes a permissioned, state-changing call on the VaultProxy contract\\n    /// @param _action The enum representing the VaultAction to perform on the VaultProxy\\n    /// @param _actionData The call data for the action to perform\\n    function permissionedVaultAction(IVault.VaultAction _action, bytes calldata _actionData)\\n        external\\n        override\\n    {\\n        __assertPermissionedVaultAction(msg.sender, _action);\\n\\n        // Validate action as needed\\n        if (_action == IVault.VaultAction.RemoveTrackedAsset) {\\n            require(\\n                abi.decode(_actionData, (address)) != getDenominationAsset(),\\n                \\\"permissionedVaultAction: Cannot untrack denomination asset\\\"\\n            );\\n        }\\n\\n        IVault(getVaultProxy()).receiveValidatedVaultAction(_action, _actionData);\\n    }\\n\\n    /// @dev Helper to assert that a caller is allowed to perform a particular VaultAction.\\n    /// Uses this pattern rather than multiple `require` statements to save on contract size.\\n    function __assertPermissionedVaultAction(address _caller, IVault.VaultAction _action)\\n        private\\n        view\\n    {\\n        bool validAction;\\n        if (permissionedVaultActionAllowed) {\\n            // Calls are roughly ordered by likely frequency\\n            if (_caller == getIntegrationManager()) {\\n                if (\\n                    _action == IVault.VaultAction.AddTrackedAsset ||\\n                    _action == IVault.VaultAction.RemoveTrackedAsset ||\\n                    _action == IVault.VaultAction.WithdrawAssetTo ||\\n                    _action == IVault.VaultAction.ApproveAssetSpender\\n                ) {\\n                    validAction = true;\\n                }\\n            } else if (_caller == getFeeManager()) {\\n                if (\\n                    _action == IVault.VaultAction.MintShares ||\\n                    _action == IVault.VaultAction.BurnShares ||\\n                    _action == IVault.VaultAction.TransferShares\\n                ) {\\n                    validAction = true;\\n                }\\n            } else if (_caller == getExternalPositionManager()) {\\n                if (\\n                    _action == IVault.VaultAction.CallOnExternalPosition ||\\n                    _action == IVault.VaultAction.AddExternalPosition ||\\n                    _action == IVault.VaultAction.RemoveExternalPosition\\n                ) {\\n                    validAction = true;\\n                }\\n            }\\n        }\\n\\n        require(validAction, \\\"__assertPermissionedVaultAction: Action not allowed\\\");\\n    }\\n\\n    ///////////////\\n    // LIFECYCLE //\\n    ///////////////\\n\\n    // Ordered by execution in the lifecycle\\n\\n    /// @notice Initializes a fund with its core config\\n    /// @param _denominationAsset The asset in which the fund's value should be denominated\\n    /// @param _sharesActionTimelock The minimum number of seconds between any two \\\"shares actions\\\"\\n    /// (buying or selling shares) by the same user\\n    /// @dev Pseudo-constructor per proxy.\\n    /// No need to assert access because this is called atomically on deployment,\\n    /// and once it's called, it cannot be called again.\\n    function init(address _denominationAsset, uint256 _sharesActionTimelock) external override {\\n        require(getDenominationAsset() == address(0), \\\"init: Already initialized\\\");\\n        require(\\n            IValueInterpreter(getValueInterpreter()).isSupportedPrimitiveAsset(_denominationAsset),\\n            \\\"init: Bad denomination asset\\\"\\n        );\\n\\n        denominationAsset = _denominationAsset;\\n        sharesActionTimelock = _sharesActionTimelock;\\n    }\\n\\n    /// @notice Sets the VaultProxy\\n    /// @param _vaultProxy The VaultProxy contract\\n    /// @dev No need to assert anything beyond FundDeployer access.\\n    /// Called atomically with init(), but after ComptrollerProxy has been deployed.\\n    function setVaultProxy(address _vaultProxy) external override onlyFundDeployer {\\n        vaultProxy = _vaultProxy;\\n\\n        emit VaultProxySet(_vaultProxy);\\n    }\\n\\n    /// @notice Runs atomic logic after a ComptrollerProxy has become its vaultProxy's `accessor`\\n    /// @param _isMigration True if a migrated fund is being activated\\n    /// @dev No need to assert anything beyond FundDeployer access.\\n    function activate(bool _isMigration) external override onlyFundDeployer {\\n        address vaultProxyCopy = getVaultProxy();\\n\\n        if (_isMigration) {\\n            // Distribute any shares in the VaultProxy to the fund owner.\\n            // This is a mechanism to ensure that even in the edge case of a fund being unable\\n            // to payout fee shares owed during migration, these shares are not lost.\\n            uint256 sharesDue = ERC20(vaultProxyCopy).balanceOf(vaultProxyCopy);\\n            if (sharesDue > 0) {\\n                IVault(vaultProxyCopy).transferShares(\\n                    vaultProxyCopy,\\n                    IVault(vaultProxyCopy).getOwner(),\\n                    sharesDue\\n                );\\n\\n                emit MigratedSharesDuePaid(sharesDue);\\n            }\\n        }\\n\\n        IVault(vaultProxyCopy).addTrackedAsset(getDenominationAsset());\\n\\n        // Activate extensions\\n        IExtension(getFeeManager()).activateForFund(_isMigration);\\n        IExtension(getPolicyManager()).activateForFund(_isMigration);\\n    }\\n\\n    /// @notice Wind down and destroy a ComptrollerProxy that is active\\n    /// @param _deactivateFeeManagerGasLimit The amount of gas to forward to deactivate the FeeManager\\n    /// @param _payProtocolFeeGasLimit The amount of gas to forward to pay the protocol fee\\n    /// @dev No need to assert anything beyond FundDeployer access.\\n    /// Uses the try/catch pattern throughout out of an abundance of caution for the function's success.\\n    /// All external calls must use limited forwarded gas to ensure that a migration to another release\\n    /// does not get bricked by logic that consumes too much gas for the block limit.\\n    function destructActivated(\\n        uint256 _deactivateFeeManagerGasLimit,\\n        uint256 _payProtocolFeeGasLimit\\n    ) external override onlyFundDeployer allowsPermissionedVaultAction {\\n        // Forwarding limited gas here also protects fee recipients by guaranteeing that fee payout logic\\n        // will run in the next function call\\n        try IVault(getVaultProxy()).payProtocolFee{gas: _payProtocolFeeGasLimit}()  {} catch {\\n            emit PayProtocolFeeDuringDestructFailed();\\n        }\\n\\n        // Do not attempt to auto-buyback protocol fee shares in this case,\\n        // as the call is gav-dependent and can consume too much gas\\n\\n        // Deactivate extensions only as-necessary\\n\\n        // Pays out shares outstanding for fees\\n        try\\n            IExtension(getFeeManager()).deactivateForFund{gas: _deactivateFeeManagerGasLimit}()\\n         {} catch {\\n            emit DeactivateFeeManagerFailed();\\n        }\\n\\n        __selfDestruct();\\n    }\\n\\n    /// @notice Destroy a ComptrollerProxy that has not been activated\\n    function destructUnactivated() external override onlyFundDeployer {\\n        __selfDestruct();\\n    }\\n\\n    /// @dev Helper to self-destruct the contract.\\n    /// There should never be ETH in the ComptrollerLib,\\n    /// so no need to waste gas to get the fund owner\\n    function __selfDestruct() private {\\n        // Not necessary, but failsafe to protect the lib against selfdestruct\\n        require(!isLib, \\\"__selfDestruct: Only delegate callable\\\");\\n\\n        selfdestruct(payable(address(this)));\\n    }\\n\\n    ////////////////\\n    // ACCOUNTING //\\n    ////////////////\\n\\n    /// @notice Calculates the gross asset value (GAV) of the fund\\n    /// @param _finalizeAssets True if all assets must have exact final balances settled\\n    /// @return gav_ The fund GAV\\n    function calcGav(bool _finalizeAssets) public override returns (uint256 gav_) {\\n        address vaultProxyAddress = getVaultProxy();\\n        address[] memory assets = IVault(vaultProxyAddress).getTrackedAssets();\\n        address[] memory externalPositions = IVault(vaultProxyAddress)\\n            .getActiveExternalPositions();\\n\\n        if (assets.length == 0 && externalPositions.length == 0) {\\n            return 0;\\n        }\\n\\n        // It is not necessary to finalize assets in external positions, as synths will have\\n        // already been settled prior to transferring to the external position contract\\n        if (_finalizeAssets) {\\n            IAssetFinalityResolver(getAssetFinalityResolver()).finalizeAssets(\\n                vaultProxyAddress,\\n                assets\\n            );\\n        }\\n\\n        uint256[] memory balances = new uint256[](assets.length);\\n        for (uint256 i; i < assets.length; i++) {\\n            balances[i] = ERC20(assets[i]).balanceOf(vaultProxyAddress);\\n            IVault(vaultProxyAddress).debugGav(assets[i], balances[i], vaultProxyAddress);\\n        }\\n\\n        gav_ = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetsTotalValue(\\n            assets,\\n            balances,\\n            getDenominationAsset()\\n        );\\n\\n        if (externalPositions.length > 0) {\\n            for (uint256 i; i < externalPositions.length; i++) {\\n                uint256 externalPositionValue = __calcExternalPositionValue(externalPositions[i]);\\n\\n                gav_ = gav_.add(externalPositionValue);\\n            }\\n        }\\n\\n        return gav_;\\n    }\\n\\n    /// @notice Calculates the gross value of 1 unit of shares in the fund's denomination asset\\n    /// @param _requireFinality True if all assets must have exact final balances settled\\n    /// @return grossShareValue_ The amount of the denomination asset per share\\n    /// @dev Does not account for any fees outstanding.\\n    function calcGrossShareValue(bool _requireFinality)\\n        external\\n        override\\n        returns (uint256 grossShareValue_)\\n    {\\n        uint256 gav = calcGav(_requireFinality);\\n\\n        grossShareValue_ = __calcGrossShareValue(\\n            gav,\\n            ERC20(getVaultProxy()).totalSupply(),\\n            10**uint256(ERC20(getDenominationAsset()).decimals())\\n        );\\n\\n        return grossShareValue_;\\n    }\\n\\n    // @dev Helper for calculating a external position value. Prevents from stack too deep\\n    function __calcExternalPositionValue(address _externalPosition)\\n        private\\n        returns (uint256 value_)\\n    {\\n        (address[] memory managedAssets, uint256[] memory managedAmounts) = IExternalPosition(\\n            _externalPosition\\n        )\\n            .getManagedAssets();\\n\\n        uint256 managedValue = IValueInterpreter(getValueInterpreter())\\n            .calcCanonicalAssetsTotalValue(managedAssets, managedAmounts, getDenominationAsset());\\n\\n        (address[] memory debtAssets, uint256[] memory debtAmounts) = IExternalPosition(\\n            _externalPosition\\n        )\\n            .getDebtAssets();\\n\\n        uint256 debtValue = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetsTotalValue(\\n            debtAssets,\\n            debtAmounts,\\n            getDenominationAsset()\\n        );\\n\\n        if (managedValue > debtValue) {\\n            value_ = managedValue.sub(debtValue);\\n        }\\n\\n        return value_;\\n    }\\n\\n    /// @dev Helper for calculating the gross share value\\n    function __calcGrossShareValue(\\n        uint256 _gav,\\n        uint256 _sharesSupply,\\n        uint256 _denominationAssetUnit\\n    ) private pure returns (uint256 grossShareValue_) {\\n        if (_sharesSupply == 0) {\\n            return _denominationAssetUnit;\\n        }\\n\\n        return _gav.mul(SHARES_UNIT).div(_sharesSupply);\\n    }\\n\\n    ///////////////////\\n    // PARTICIPATION //\\n    ///////////////////\\n\\n    // BUY SHARES\\n\\n    /// @notice Buys shares on behalf of another user\\n    /// @param _buyer The account on behalf of whom to buy shares\\n    /// @param _investmentAmount The amount of the fund's denomination asset with which to buy shares\\n    /// @param _minSharesQuantity The minimum quantity of shares to buy\\n    /// @return sharesReceived_ The actual amount of shares received\\n    /// @dev This function is freely callable if there is no sharesActionTimelock set, but it is\\n    /// limited to a list of trusted callers otherwise, in order to prevent a griefing attack\\n    /// where the caller buys shares for a _buyer, thereby resetting their lastSharesBought value.\\n    function buySharesOnBehalf(\\n        address _buyer,\\n        uint256 _investmentAmount,\\n        uint256 _minSharesQuantity\\n    ) external returns (uint256 sharesReceived_) {\\n        bool hasSharesActionTimelock = getSharesActionTimelock() > 0;\\n        address canonicalSender = __msgSender();\\n\\n        require(\\n            !hasSharesActionTimelock ||\\n                IFundDeployer(getFundDeployer()).isAllowedBuySharesOnBehalfCaller(canonicalSender),\\n            \\\"buySharesOnBehalf: Unauthorized\\\"\\n        );\\n\\n        return\\n            __buyShares(\\n                _buyer,\\n                _investmentAmount,\\n                _minSharesQuantity,\\n                hasSharesActionTimelock,\\n                canonicalSender\\n            );\\n    }\\n\\n    /// @notice Buys shares\\n    /// @param _investmentAmount The amount of the fund's denomination asset\\n    /// with which to buy shares\\n    /// @param _minSharesQuantity The minimum quantity of shares to buy\\n    /// @return sharesReceived_ The actual amount of shares received\\n    function buyShares(uint256 _investmentAmount, uint256 _minSharesQuantity)\\n        external\\n        returns (uint256 sharesReceived_)\\n    {\\n        bool hasSharesActionTimelock = getSharesActionTimelock() > 0;\\n        address canonicalSender = __msgSender();\\n\\n        return\\n            __buyShares(\\n                canonicalSender,\\n                _investmentAmount,\\n                _minSharesQuantity,\\n                hasSharesActionTimelock,\\n                canonicalSender\\n            );\\n    }\\n\\n    /// @dev Helper for buy shares logic\\n    function __buyShares(\\n        address _buyer,\\n        uint256 _investmentAmount,\\n        uint256 _minSharesQuantity,\\n        bool _hasSharesActionTimelock,\\n        address _canonicalSender\\n    ) private locksReentrance allowsPermissionedVaultAction returns (uint256 sharesReceived_) {\\n        // Enforcing a _minSharesQuantity also validates `_investmentAmount > 0`\\n        // and guarantees the function cannot succeed while minting 0 shares\\n        require(_minSharesQuantity > 0, \\\"__buyShares: _minSharesQuantity must be >0\\\");\\n\\n        address vaultProxyCopy = getVaultProxy();\\n        require(\\n            !_hasSharesActionTimelock || !__hasPendingMigrationOrReconfiguration(vaultProxyCopy),\\n            \\\"__buyShares: Pending migration or reconfiguration\\\"\\n        );\\n\\n        uint256 gav = calcGav(true);\\n\\n        // Gives Extensions a chance to run logic prior to the minting of bought shares.\\n        // Fees implementing this hook should be aware that\\n        // it might be the case that _investmentAmount != actualInvestmentAmount,\\n        // if the denomination asset charges a transfer fee, for example.\\n        __preBuySharesHook(_buyer, _investmentAmount, gav);\\n\\n        // Pay the protocol fee after running other fees, but before minting new shares\\n        IVault(vaultProxyCopy).payProtocolFee();\\n        if (doesAutoProtocolFeeSharesBuyback()) {\\n            __buyBackMaxProtocolFeeShares(vaultProxyCopy, gav);\\n        }\\n\\n        // Transfer the investment asset to the fund.\\n        // Does not follow the checks-effects-interactions pattern, but it is necessary to\\n        // do this delta balance calculation before calculating shares to mint.\\n        uint256 receivedInvestmentAmount = __transferFromWithReceivedAmount(\\n            getDenominationAsset(),\\n            _canonicalSender,\\n            vaultProxyCopy,\\n            _investmentAmount\\n        );\\n\\n        // Calculate the amount of shares to issue with the investment amount\\n        uint256 sharePrice = __calcGrossShareValue(\\n            gav,\\n            ERC20(vaultProxyCopy).totalSupply(),\\n            10**uint256(ERC20(getDenominationAsset()).decimals())\\n        );\\n        uint256 sharesIssued = receivedInvestmentAmount.mul(SHARES_UNIT).div(sharePrice);\\n\\n        // Mint shares to the buyer\\n        uint256 prevBuyerShares = ERC20(vaultProxyCopy).balanceOf(_buyer);\\n        IVault(vaultProxyCopy).mintShares(_buyer, sharesIssued);\\n\\n        // Gives Extensions a chance to run logic after shares are issued\\n        __postBuySharesHook(_buyer, receivedInvestmentAmount, sharesIssued, gav);\\n\\n        // The number of actual shares received may differ from shares issued due to\\n        // how the PostBuyShares hooks are invoked by Extensions (i.e., fees)\\n        sharesReceived_ = ERC20(vaultProxyCopy).balanceOf(_buyer).sub(prevBuyerShares);\\n        require(\\n            sharesReceived_ >= _minSharesQuantity,\\n            \\\"__buyShares: Shares received < _minSharesQuantity\\\"\\n        );\\n\\n        if (_hasSharesActionTimelock) {\\n            acctToLastSharesBoughtTimestamp[_buyer] = block.timestamp;\\n        }\\n\\n        emit SharesBought(_buyer, receivedInvestmentAmount, sharesIssued, sharesReceived_);\\n\\n        return sharesReceived_;\\n    }\\n\\n    /// @dev Helper for Extension actions immediately prior to issuing shares\\n    function __preBuySharesHook(\\n        address _buyer,\\n        uint256 _investmentAmount,\\n        uint256 _gav\\n    ) private {\\n        IFeeManager(getFeeManager()).invokeHook(\\n            IFeeManager.FeeHook.PreBuyShares,\\n            abi.encode(_buyer, _investmentAmount),\\n            _gav\\n        );\\n    }\\n\\n    /// @dev Helper for Extension actions immediately after issuing shares.\\n    /// This could be cleaned up so both Extensions take the same encoded args and handle GAV\\n    /// in the same way, but there is not the obvious need for gas savings of recycling\\n    /// the GAV value for the current policies as there is for the fees.\\n    function __postBuySharesHook(\\n        address _buyer,\\n        uint256 _investmentAmount,\\n        uint256 _sharesIssued,\\n        uint256 _preBuySharesGav\\n    ) private {\\n        uint256 gav = _preBuySharesGav.add(_investmentAmount);\\n        IFeeManager(getFeeManager()).invokeHook(\\n            IFeeManager.FeeHook.PostBuyShares,\\n            abi.encode(_buyer, _investmentAmount, _sharesIssued),\\n            gav\\n        );\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            address(this),\\n            IPolicyManager.PolicyHook.PostBuyShares,\\n            abi.encode(_buyer, _investmentAmount, _sharesIssued, gav)\\n        );\\n    }\\n\\n    /// @dev Helper to execute ERC20.transferFrom() while calculating the actual amount received\\n    function __transferFromWithReceivedAmount(\\n        address _asset,\\n        address _sender,\\n        address _recipient,\\n        uint256 _transferAmount\\n    ) private returns (uint256 receivedAmount_) {\\n        uint256 preTransferRecipientBalance = ERC20(_asset).balanceOf(_recipient);\\n\\n        ERC20(_asset).safeTransferFrom(_sender, _recipient, _transferAmount);\\n\\n        return ERC20(_asset).balanceOf(_recipient).sub(preTransferRecipientBalance);\\n    }\\n\\n    // REDEEM SHARES\\n\\n    /// @notice Redeems a specified amount of the sender's shares for specified asset proportions\\n    /// @param _recipient The account that will receive the specified assets\\n    /// @param _sharesQuantity The quantity of shares to redeem\\n    /// @param _payoutAssets The assets to payout\\n    /// @param _payoutAssetPercentages The percentage of the owed amount to pay out in each asset\\n    /// @return payoutAmounts_ The amount of each asset paid out to the _recipient\\n    /// @dev Redeem all shares of the sender by setting _sharesQuantity to the max uint value.\\n    /// _payoutAssetPercentages must total exactly 100%. In order to specify less and forgo the\\n    /// remaining gav owed on the redeemed shares, pass in address(0) with the percentage to forego.\\n    /// Unlike redeemSharesInKind(), this function allows policies to run and prevent redemption.\\n    function redeemSharesForSpecificAssets(\\n        address _recipient,\\n        uint256 _sharesQuantity,\\n        address[] calldata _payoutAssets,\\n        uint256[] calldata _payoutAssetPercentages\\n    ) external locksReentrance returns (uint256[] memory payoutAmounts_) {\\n        address canonicalSender = __msgSender();\\n        require(\\n            _payoutAssets.length == _payoutAssetPercentages.length,\\n            \\\"redeemSharesForSpecificAssets: Unequal arrays\\\"\\n        );\\n        require(\\n            _payoutAssets.isUniqueSet(),\\n            \\\"redeemSharesForSpecificAssets: Duplicate payout asset\\\"\\n        );\\n\\n        uint256 gav = calcGav(true);\\n\\n        IVault vaultProxyContract = IVault(getVaultProxy());\\n        (uint256 sharesToRedeem, uint256 sharesSupply) = __redeemSharesSetup(\\n            vaultProxyContract,\\n            canonicalSender,\\n            _sharesQuantity,\\n            true,\\n            gav\\n        );\\n\\n        payoutAmounts_ = __payoutSpecifiedAssetPercentages(\\n            vaultProxyContract,\\n            _recipient,\\n            _payoutAssets,\\n            _payoutAssetPercentages,\\n            gav.mul(sharesToRedeem).div(sharesSupply)\\n        );\\n\\n        // Run post-redemption in order to have access to the payoutAmounts\\n        __postRedeemSharesForSpecificAssetsHook(\\n            canonicalSender,\\n            _recipient,\\n            sharesToRedeem,\\n            _payoutAssets,\\n            payoutAmounts_,\\n            gav\\n        );\\n\\n        emit SharesRedeemed(\\n            canonicalSender,\\n            _recipient,\\n            sharesToRedeem,\\n            _payoutAssets,\\n            payoutAmounts_\\n        );\\n\\n        return payoutAmounts_;\\n    }\\n\\n    /// @notice Redeems a specified amount of the sender's shares\\n    /// for a proportionate slice of the vault's assets\\n    /// @param _recipient The account that will receive the proportionate slice of assets\\n    /// @param _sharesQuantity The quantity of shares to redeem\\n    /// @param _additionalAssets Additional (non-tracked) assets to claim\\n    /// @param _assetsToSkip Tracked assets to forfeit\\n    /// @return payoutAssets_ The assets paid out to the _recipient\\n    /// @return payoutAmounts_ The amount of each asset paid out to the _recipient\\n    /// @dev Redeem all shares of the sender by setting _sharesQuantity to the max uint value.\\n    /// Any claim to passed _assetsToSkip will be forfeited entirely. This should generally\\n    /// only be exercised if a bad asset is causing redemption to fail.\\n    /// This function should never fail without a way to bypass the failure, which is assured\\n    /// through two mechanisms:\\n    /// 1. The FeeManager is called with the try/catch pattern to assure that calls to it\\n    /// can never block redemption.\\n    /// 2. If a token fails upon transfer(), that token can be skipped (and its balance forfeited)\\n    /// by explicitly specifying _assetsToSkip.\\n    /// Because of these assurances, shares should always be redeemable, with the exception\\n    /// of the timelock period on shares actions that must be respected.\\n    function redeemSharesInKind(\\n        address _recipient,\\n        uint256 _sharesQuantity,\\n        address[] calldata _additionalAssets,\\n        address[] calldata _assetsToSkip\\n    )\\n        external\\n        locksReentrance\\n        returns (address[] memory payoutAssets_, uint256[] memory payoutAmounts_)\\n    {\\n        address canonicalSender = __msgSender();\\n        require(\\n            _additionalAssets.isUniqueSet(),\\n            \\\"redeemSharesInKind: _additionalAssets contains duplicates\\\"\\n        );\\n        require(\\n            _assetsToSkip.isUniqueSet(),\\n            \\\"redeemSharesInKind: _assetsToSkip contains duplicates\\\"\\n        );\\n\\n        // Parse the payout assets given optional params to add or skip assets.\\n        // Note that there is no validation that the _additionalAssets are known assets to\\n        // the protocol. This means that the redeemer could specify a malicious asset,\\n        // but since all state-changing, user-callable functions on this contract share the\\n        // non-reentrant modifier, there is nowhere to perform a reentrancy attack.\\n        payoutAssets_ = __parseRedemptionPayoutAssets(\\n            IVault(vaultProxy).getTrackedAssets(),\\n            _additionalAssets,\\n            _assetsToSkip\\n        );\\n\\n        // Resolve finality of all assets as needed.\\n        // Run this prior to calculating GAV.\\n        IAssetFinalityResolver(getAssetFinalityResolver()).finalizeAssets(\\n            vaultProxy,\\n            payoutAssets_\\n        );\\n\\n        // If protocol fee shares will be auto-bought back, attempt to calculate GAV to pass into fees,\\n        // as we will require GAV later during the buyback.\\n        uint256 gavOrZero;\\n        if (doesAutoProtocolFeeSharesBuyback()) {\\n            // Since GAV calculation can fail with a revering price or a no-longer-supported asset,\\n            // we must try/catch GAV calculation to ensure that in-kind redemption can still succeed\\n            try this.calcGav(false) returns (uint256 gav) {\\n                gavOrZero = gav;\\n            } catch {\\n                emit RedeemSharesInKindCalcGavFailed();\\n            }\\n        }\\n\\n        (uint256 sharesToRedeem, uint256 sharesSupply) = __redeemSharesSetup(\\n            IVault(vaultProxy),\\n            canonicalSender,\\n            _sharesQuantity,\\n            false,\\n            gavOrZero\\n        );\\n\\n        // Calculate and transfer payout asset amounts due to _recipient\\n        payoutAmounts_ = new uint256[](payoutAssets_.length);\\n        for (uint256 i; i < payoutAssets_.length; i++) {\\n            payoutAmounts_[i] = ERC20(payoutAssets_[i])\\n                .balanceOf(vaultProxy)\\n                .mul(sharesToRedeem)\\n                .div(sharesSupply);\\n\\n            // Transfer payout asset to _recipient\\n            if (payoutAmounts_[i] > 0) {\\n                IVault(vaultProxy).withdrawAssetTo(\\n                    payoutAssets_[i],\\n                    _recipient,\\n                    payoutAmounts_[i]\\n                );\\n            }\\n        }\\n\\n        emit SharesRedeemed(\\n            canonicalSender,\\n            _recipient,\\n            sharesToRedeem,\\n            payoutAssets_,\\n            payoutAmounts_\\n        );\\n\\n        return (payoutAssets_, payoutAmounts_);\\n    }\\n\\n    /// @dev Helper to parse an array of payout assets during redemption, taking into account\\n    /// additional assets and assets to skip. _assetsToSkip ignores _additionalAssets.\\n    /// All input arrays are assumed to be unique.\\n    function __parseRedemptionPayoutAssets(\\n        address[] memory _trackedAssets,\\n        address[] memory _additionalAssets,\\n        address[] memory _assetsToSkip\\n    ) private pure returns (address[] memory payoutAssets_) {\\n        address[] memory trackedAssetsToPayout = _trackedAssets.removeItems(_assetsToSkip);\\n        if (_additionalAssets.length == 0) {\\n            return trackedAssetsToPayout;\\n        }\\n\\n        // Add additional assets. Duplicates of trackedAssets are ignored.\\n        bool[] memory indexesToAdd = new bool[](_additionalAssets.length);\\n        uint256 additionalItemsCount;\\n        for (uint256 i; i < _additionalAssets.length; i++) {\\n            if (!trackedAssetsToPayout.contains(_additionalAssets[i])) {\\n                indexesToAdd[i] = true;\\n                additionalItemsCount++;\\n            }\\n        }\\n        if (additionalItemsCount == 0) {\\n            return trackedAssetsToPayout;\\n        }\\n\\n        payoutAssets_ = new address[](trackedAssetsToPayout.length.add(additionalItemsCount));\\n        for (uint256 i; i < trackedAssetsToPayout.length; i++) {\\n            payoutAssets_[i] = trackedAssetsToPayout[i];\\n        }\\n        uint256 payoutAssetsIndex = trackedAssetsToPayout.length;\\n        for (uint256 i; i < _additionalAssets.length; i++) {\\n            if (indexesToAdd[i]) {\\n                payoutAssets_[payoutAssetsIndex] = _additionalAssets[i];\\n                payoutAssetsIndex++;\\n            }\\n        }\\n\\n        return payoutAssets_;\\n    }\\n\\n    /// @dev Helper to payout specified asset percentages during redeemSharesForSpecificAssets()\\n    function __payoutSpecifiedAssetPercentages(\\n        IVault vaultProxyContract,\\n        address _recipient,\\n        address[] calldata _payoutAssets,\\n        uint256[] calldata _payoutAssetPercentages,\\n        uint256 _owedGav\\n    ) private returns (uint256[] memory payoutAmounts_) {\\n        address denominationAssetCopy = getDenominationAsset();\\n        uint256 percentagesTotal;\\n        payoutAmounts_ = new uint256[](_payoutAssets.length);\\n        for (uint256 i; i < _payoutAssets.length; i++) {\\n            percentagesTotal = percentagesTotal.add(_payoutAssetPercentages[i]);\\n\\n            // Used to explicitly specify less than 100% in total _payoutAssetPercentages\\n            if (_payoutAssets[i] == SPECIFIC_ASSET_REDEMPTION_DUMMY_FORFEIT_ADDRESS) {\\n                continue;\\n            }\\n\\n            payoutAmounts_[i] = IValueInterpreter(getValueInterpreter()).calcCanonicalAssetValue(\\n                denominationAssetCopy,\\n                _owedGav.mul(_payoutAssetPercentages[i]).div(ONE_HUNDRED_PERCENT),\\n                _payoutAssets[i]\\n            );\\n            // Guards against corner case of primitive-to-derivative asset conversion that floors to 0,\\n            // or redeeming a very low shares amount and/or percentage where asset value owed is 0\\n            require(\\n                payoutAmounts_[i] > 0,\\n                \\\"__payoutSpecifiedAssetPercentages: Zero amount for asset\\\"\\n            );\\n\\n            vaultProxyContract.withdrawAssetTo(_payoutAssets[i], _recipient, payoutAmounts_[i]);\\n        }\\n\\n        require(\\n            percentagesTotal == ONE_HUNDRED_PERCENT,\\n            \\\"__payoutSpecifiedAssetPercentages: Percents must total 100%\\\"\\n        );\\n\\n        return payoutAmounts_;\\n    }\\n\\n    /// @dev Helper for system actions immediately prior to redeeming shares.\\n    /// Policy validation is not currently allowed on redemption, to ensure continuous redeemability.\\n    function __preRedeemSharesHook(\\n        address _redeemer,\\n        uint256 _sharesToRedeem,\\n        bool _forSpecifiedAssets,\\n        uint256 _gavIfCalculated\\n    ) private allowsPermissionedVaultAction {\\n        try\\n            IFeeManager(getFeeManager()).invokeHook(\\n                IFeeManager.FeeHook.PreRedeemShares,\\n                abi.encode(_redeemer, _sharesToRedeem, _forSpecifiedAssets),\\n                _gavIfCalculated\\n            )\\n         {} catch (bytes memory reason) {\\n            emit PreRedeemSharesHookFailed(reason, _redeemer, _sharesToRedeem);\\n        }\\n    }\\n\\n    /// @dev Helper to run policy validation after other logic for redeeming shares for specific assets.\\n    /// Avoids stack-too-deep error.\\n    function __postRedeemSharesForSpecificAssetsHook(\\n        address _redeemer,\\n        address _recipient,\\n        uint256 _sharesToRedeemPostFees,\\n        address[] memory _assets,\\n        uint256[] memory _assetAmounts,\\n        uint256 _gavPreRedeem\\n    ) private {\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            address(this),\\n            IPolicyManager.PolicyHook.RedeemSharesForSpecificAssets,\\n            abi.encode(\\n                _redeemer,\\n                _recipient,\\n                _sharesToRedeemPostFees,\\n                _assets,\\n                _assetAmounts,\\n                _gavPreRedeem\\n            )\\n        );\\n    }\\n\\n    /// @dev Helper to execute common pre-shares redemption logic\\n    function __redeemSharesSetup(\\n        IVault vaultProxyContract,\\n        address _redeemer,\\n        uint256 _sharesQuantityInput,\\n        bool _forSpecifiedAssets,\\n        uint256 _gavIfCalculated\\n    ) private returns (uint256 sharesToRedeem_, uint256 sharesSupply_) {\\n        __assertSharesActionNotTimelocked(address(vaultProxyContract), _redeemer);\\n\\n        ERC20 sharesContract = ERC20(address(vaultProxyContract));\\n\\n        uint256 preFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);\\n\\n        if (_sharesQuantityInput == type(uint256).max) {\\n            sharesToRedeem_ = preFeesRedeemerSharesBalance;\\n        } else {\\n            sharesToRedeem_ = _sharesQuantityInput;\\n        }\\n        require(sharesToRedeem_ > 0, \\\"__redeemSharesSetup: No shares to redeem\\\");\\n\\n        __preRedeemSharesHook(_redeemer, sharesToRedeem_, _forSpecifiedAssets, _gavIfCalculated);\\n\\n        // Update the redemption amount if fees were charged (or accrued) to the redeemer\\n        uint256 postFeesRedeemerSharesBalance = sharesContract.balanceOf(_redeemer);\\n        if (_sharesQuantityInput == type(uint256).max) {\\n            sharesToRedeem_ = postFeesRedeemerSharesBalance;\\n        } else if (postFeesRedeemerSharesBalance < preFeesRedeemerSharesBalance) {\\n            sharesToRedeem_ = sharesToRedeem_.sub(\\n                preFeesRedeemerSharesBalance.sub(postFeesRedeemerSharesBalance)\\n            );\\n        }\\n\\n        // Pay the protocol fee after running other fees, but before burning shares\\n        vaultProxyContract.payProtocolFee();\\n\\n        if (_gavIfCalculated > 0 && doesAutoProtocolFeeSharesBuyback()) {\\n            __buyBackMaxProtocolFeeShares(address(vaultProxyContract), _gavIfCalculated);\\n        }\\n\\n        // Destroy the shares after getting the shares supply\\n        sharesSupply_ = sharesContract.totalSupply();\\n        vaultProxyContract.burnShares(_redeemer, sharesToRedeem_);\\n\\n        return (sharesToRedeem_, sharesSupply_);\\n    }\\n\\n    // TRANSFER SHARES\\n\\n    /// @notice Runs logic prior to transferring shares that are not freely transferable\\n    /// @param _sender The sender of the shares\\n    /// @param _recipient The recipient of the shares\\n    /// @param _amount The amount of shares\\n    function preTransferSharesHook(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) external override {\\n        address vaultProxyCopy = getVaultProxy();\\n        require(msg.sender == vaultProxyCopy, \\\"preTransferSharesHook: Only VaultProxy callable\\\");\\n        __assertSharesActionNotTimelocked(vaultProxyCopy, _sender);\\n\\n        IPolicyManager(getPolicyManager()).validatePolicies(\\n            address(this),\\n            IPolicyManager.PolicyHook.PreTransferShares,\\n            abi.encode(_sender, _recipient, _amount)\\n        );\\n    }\\n\\n    /// @notice Runs logic prior to transferring shares that are freely transferable\\n    /// @param _sender The sender of the shares\\n    /// @dev No need to validate caller, as policies are not run\\n    function preTransferSharesHookFreelyTransferable(address _sender) external view override {\\n        __assertSharesActionNotTimelocked(getVaultProxy(), _sender);\\n    }\\n\\n    /////////////////\\n    // GAS RELAYER //\\n    /////////////////\\n\\n    /// @notice Deploys a paymaster contract and deposits WETH, enabling gas relaying\\n    function deployGasRelayPaymaster() external onlyOwnerNotRelayable {\\n        require(\\n            getGasRelayPaymaster() == address(0),\\n            \\\"deployGasRelayPaymaster: Paymaster already deployed\\\"\\n        );\\n\\n        bytes memory constructData = abi.encodeWithSignature(\\\"init(address)\\\", getVaultProxy());\\n        address paymaster = IBeaconProxyFactory(getGasRelayPaymasterFactory()).deployProxy(\\n            constructData\\n        );\\n\\n        __setGasRelayPaymaster(paymaster);\\n\\n        __depositToGasRelayPaymaster(paymaster);\\n    }\\n\\n    /// @notice Tops up the gas relay paymaster deposit\\n    function depositToGasRelayPaymaster() external onlyOwner {\\n        __depositToGasRelayPaymaster(getGasRelayPaymaster());\\n    }\\n\\n    /// @notice Pull WETH from vault to gas relay paymaster\\n    /// @param _amount Amount of the WETH to pull from the vault\\n    function pullWethForGasRelayer(uint256 _amount) external override onlyGasRelayPaymaster {\\n        IVault(getVaultProxy()).withdrawAssetTo(getWethToken(), getGasRelayPaymaster(), _amount);\\n    }\\n\\n    /// @notice Sets the gasRelayPaymaster variable value\\n    /// @param _nextGasRelayPaymaster The next gasRelayPaymaster value\\n    function setGasRelayPaymaster(address _nextGasRelayPaymaster)\\n        external\\n        override\\n        onlyFundDeployer\\n    {\\n        __setGasRelayPaymaster(_nextGasRelayPaymaster);\\n    }\\n\\n    /// @notice Removes the gas relay paymaster, withdrawing the remaining WETH balance\\n    /// and disabling gas relaying\\n    function shutdownGasRelayPaymaster() external onlyOwnerNotRelayable {\\n        IGasRelayPaymaster(gasRelayPaymaster).withdrawBalance();\\n\\n        IVault(vaultProxy).addTrackedAsset(getWethToken());\\n\\n        delete gasRelayPaymaster;\\n\\n        emit GasRelayPaymasterSet(address(0));\\n    }\\n\\n    /// @dev Helper to deposit to the gas relay paymaster\\n    function __depositToGasRelayPaymaster(address _paymaster) private {\\n        IGasRelayPaymaster(_paymaster).deposit();\\n    }\\n\\n    /// @dev Helper to set the next `gasRelayPaymaster` variable\\n    function __setGasRelayPaymaster(address _nextGasRelayPaymaster) private {\\n        gasRelayPaymaster = _nextGasRelayPaymaster;\\n\\n        emit GasRelayPaymasterSet(_nextGasRelayPaymaster);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    // LIB IMMUTABLES\\n\\n    /// @notice Gets the `ASSET_FINALITY_RESOLVER` variable\\n    /// @return assetFinalityResolver_ The `ASSET_FINALITY_RESOLVER` variable value\\n    function getAssetFinalityResolver() public view returns (address assetFinalityResolver_) {\\n        return ASSET_FINALITY_RESOLVER;\\n    }\\n\\n    /// @notice Gets the `DISPATCHER` variable\\n    /// @return dispatcher_ The `DISPATCHER` variable value\\n    function getDispatcher() public view returns (address dispatcher_) {\\n        return DISPATCHER;\\n    }\\n\\n    /// @notice Gets the `EXTERNAL_POSITION_MANAGER` variable\\n    /// @return externalPositionManager_ The `EXTERNAL_POSITION_MANAGER` variable value\\n    function getExternalPositionManager()\\n        public\\n        view\\n        override\\n        returns (address externalPositionManager_)\\n    {\\n        return EXTERNAL_POSITION_MANAGER;\\n    }\\n\\n    /// @notice Gets the `FEE_MANAGER` variable\\n    /// @return feeManager_ The `FEE_MANAGER` variable value\\n    function getFeeManager() public view override returns (address feeManager_) {\\n        return FEE_MANAGER;\\n    }\\n\\n    /// @notice Gets the `FUND_DEPLOYER` variable\\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\\n    function getFundDeployer() public view override returns (address fundDeployer_) {\\n        return FUND_DEPLOYER;\\n    }\\n\\n    /// @notice Gets the `INTEGRATION_MANAGER` variable\\n    /// @return integrationManager_ The `INTEGRATION_MANAGER` variable value\\n    function getIntegrationManager() public view override returns (address integrationManager_) {\\n        return INTEGRATION_MANAGER;\\n    }\\n\\n    /// @notice Gets the `MLN_TOKEN` variable\\n    /// @return mlnToken_ The `MLN_TOKEN` variable value\\n    function getMlnToken() public view returns (address mlnToken_) {\\n        return MLN_TOKEN;\\n    }\\n\\n    /// @notice Gets the `POLICY_MANAGER` variable\\n    /// @return policyManager_ The `POLICY_MANAGER` variable value\\n    function getPolicyManager() public view override returns (address policyManager_) {\\n        return POLICY_MANAGER;\\n    }\\n\\n    /// @notice Gets the `PROTOCOL_FEE_RESERVE` variable\\n    /// @return protocolFeeReserve_ The `PROTOCOL_FEE_RESERVE` variable value\\n    function getProtocolFeeReserve() public view returns (address protocolFeeReserve_) {\\n        return PROTOCOL_FEE_RESERVE;\\n    }\\n\\n    /// @notice Gets the `VALUE_INTERPRETER` variable\\n    /// @return valueInterpreter_ The `VALUE_INTERPRETER` variable value\\n    function getValueInterpreter() public view returns (address valueInterpreter_) {\\n        return VALUE_INTERPRETER;\\n    }\\n\\n    /// @notice Gets the `WETH_TOKEN` variable\\n    /// @return wethToken_ The `WETH_TOKEN` variable value\\n    function getWethToken() public view returns (address wethToken_) {\\n        return WETH_TOKEN;\\n    }\\n\\n    // PROXY STORAGE\\n\\n    /// @notice Checks if collected protocol fee shares are automatically bought back\\n    /// while buying or redeeming shares\\n    /// @return doesAutoBuyback_ True if shares are automatically bought back\\n    function doesAutoProtocolFeeSharesBuyback() public view returns (bool doesAutoBuyback_) {\\n        return autoProtocolFeeSharesBuyback;\\n    }\\n\\n    /// @notice Gets the `denominationAsset` variable\\n    /// @return denominationAsset_ The `denominationAsset` variable value\\n    function getDenominationAsset() public view override returns (address denominationAsset_) {\\n        return denominationAsset;\\n    }\\n\\n    /// @notice Gets the `gasRelayPaymaster` variable\\n    /// @return gasRelayPaymaster_ The `gasRelayPaymaster` variable value\\n    function getGasRelayPaymaster() public view override returns (address gasRelayPaymaster_) {\\n        return gasRelayPaymaster;\\n    }\\n\\n    /// @notice Gets the timestamp of the last time shares were bought for a given account\\n    /// @param _who The account for which to get the timestamp\\n    /// @return lastSharesBoughtTimestamp_ The timestamp of the last shares bought\\n    function getLastSharesBoughtTimestampForAccount(address _who)\\n        public\\n        view\\n        returns (uint256 lastSharesBoughtTimestamp_)\\n    {\\n        return acctToLastSharesBoughtTimestamp[_who];\\n    }\\n\\n    /// @notice Gets the `sharesActionTimelock` variable\\n    /// @return sharesActionTimelock_ The `sharesActionTimelock` variable value\\n    function getSharesActionTimelock() public view returns (uint256 sharesActionTimelock_) {\\n        return sharesActionTimelock;\\n    }\\n\\n    /// @notice Gets the `vaultProxy` variable\\n    /// @return vaultProxy_ The `vaultProxy` variable value\\n    function getVaultProxy() public view override returns (address vaultProxy_) {\\n        return vaultProxy;\\n    }\\n}\\n\",\"keccak256\":\"0xd0ec93463a58713bf08b0bf6f4084bcca5ab1a3977e2cf357e4064589b296921\",\"license\":\"GPL-3.0\"},\"contracts/release/core/fund/comptroller/IComptroller.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../vault/IVault.sol\\\";\\n\\n/// @title IComptroller Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IComptroller {\\n    function activate(bool) external;\\n\\n    function calcGav(bool) external returns (uint256);\\n\\n    function calcGrossShareValue(bool) external returns (uint256);\\n\\n    function callOnExtension(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external;\\n\\n    function destructActivated(uint256, uint256) external;\\n\\n    function destructUnactivated() external;\\n\\n    function getDenominationAsset() external view returns (address);\\n\\n    function getExternalPositionManager() external view returns (address);\\n\\n    function getFeeManager() external view returns (address);\\n\\n    function getFundDeployer() external view returns (address);\\n\\n    function getGasRelayPaymaster() external view returns (address);\\n\\n    function getIntegrationManager() external view returns (address);\\n\\n    function getPolicyManager() external view returns (address);\\n\\n    function getVaultProxy() external view returns (address);\\n\\n    function init(address, uint256) external;\\n\\n    function permissionedVaultAction(IVault.VaultAction, bytes calldata) external;\\n\\n    function preTransferSharesHook(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function preTransferSharesHookFreelyTransferable(address) external view;\\n\\n    function setGasRelayPaymaster(address) external;\\n\\n    function setVaultProxy(address) external;\\n}\\n\",\"keccak256\":\"0xe59c52ad44c1c4643d0f000deb6ebc45bf72393d42d87de5721a79544a0dae37\",\"license\":\"GPL-3.0\"},\"contracts/release/core/fund/vault/IVault.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../persistent/vault/interfaces/IExternalPositionVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IFreelyTransferableSharesVault.sol\\\";\\nimport \\\"../../../../persistent/vault/interfaces/IMigratableVault.sol\\\";\\n\\n/// @title IVault Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IVault is IMigratableVault, IFreelyTransferableSharesVault, IExternalPositionVault {\\n    enum VaultAction {\\n        None,\\n        // Shares management\\n        BurnShares,\\n        MintShares,\\n        TransferShares,\\n        // Asset management\\n        AddTrackedAsset,\\n        ApproveAssetSpender,\\n        RemoveTrackedAsset,\\n        WithdrawAssetTo,\\n        // External position management\\n        AddExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition\\n    }\\n\\n    function addTrackedAsset(address) external;\\n\\n    function burnShares(address, uint256) external;\\n\\n    function buyBackProtocolFeeShares(\\n        uint256,\\n        uint256,\\n        uint256\\n    ) external;\\n\\n    function callOnContract(address, bytes calldata) external returns (bytes memory);\\n\\n    function canManageAssets(address) external view returns (bool);\\n\\n    function canRelayCalls(address) external view returns (bool);\\n\\n    function getAccessor() external view returns (address);\\n\\n    function getOwner() external view returns (address);\\n\\n    function getActiveExternalPositions() external view returns (address[] memory);\\n\\n    function getTrackedAssets() external view returns (address[] memory);\\n\\n    function isActiveExternalPosition(address) external view returns (bool);\\n\\n    function isTrackedAsset(address) external view returns (bool);\\n\\n    function mintShares(address, uint256) external;\\n\\n    function payProtocolFee() external;\\n\\n    function receiveValidatedVaultAction(VaultAction, bytes calldata) external;\\n\\n    function setAccessorForFundReconfiguration(address) external;\\n\\n    function transferShares(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetTo(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function withdrawAssetToVault(\\n        address,\\n        address,\\n        uint256\\n    ) external;\\n\\n    function transferUnderlyingTo(\\n        address asset,\\n        address target,\\n        uint256 amount\\n    ) external returns (uint256);\\n\\n    function debugGav(\\n        address,\\n        uint256,\\n        address\\n    ) external view;\\n\\n    function handleRepayment(address, uint256) external;\\n}\\n\",\"keccak256\":\"0x7ed35e01fb75d8ee6038008d851bf3d3d482ec826a29f0f791ae8ebafaafc995\",\"license\":\"GPL-3.0\"},\"contracts/release/core/fund/vault/VaultLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20Burnable.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/SafeERC20.sol\\\";\\nimport \\\"../../../../persistent/dispatcher/IDispatcher.sol\\\";\\nimport \\\"../../../../persistent/external-positions/IExternalPosition.sol\\\";\\nimport \\\"../../../../persistent/protocol-fee-reserve/interfaces/IProtocolFeeReserve1.sol\\\";\\nimport \\\"../../../../persistent/vault/VaultLibBase2.sol\\\";\\nimport \\\"../../../infrastructure/gas-relayer/GasRelayRecipientMixin.sol\\\";\\nimport \\\"../../../infrastructure/protocol-fees/IProtocolFeeTracker.sol\\\";\\nimport \\\"../../../extensions/external-position-manager/IExternalPositionManager.sol\\\";\\nimport \\\"../../../interfaces/IWETH.sol\\\";\\nimport \\\"../../../utils/AddressArrayLib.sol\\\";\\nimport \\\"../comptroller/IComptroller.sol\\\";\\nimport \\\"./IVault.sol\\\";\\nimport {IERC20} from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title VaultLib Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice The per-release proxiable library contract for VaultProxy\\n/// @dev The difference in terminology between \\\"asset\\\" and \\\"trackedAsset\\\" is intentional.\\n/// A fund might actually have asset balances of un-tracked assets,\\n/// but only tracked assets are used in gav calculations.\\n/// Note that this contract inherits VaultLibSafeMath (a verbatim Open Zeppelin SafeMath copy)\\n/// from SharesTokenBase via VaultLibBase2\\ncontract VaultLib is VaultLibBase2, IVault, GasRelayRecipientMixin {\\n    using AddressArrayLib for address[];\\n    using SafeERC20 for ERC20;\\n\\n    // \\\"Positions\\\" are \\\"tracked assets\\\" + active \\\"external positions\\\"\\n    // Before updating POSITIONS_LIMIT in the future, it is important to consider:\\n    // 1. The highest positions limit ever allowed in the protocol\\n    // 2. That the next value will need to be respected by all future releases\\n    uint256 private constant POSITIONS_LIMIT = 20;\\n\\n    address private immutable EXTERNAL_POSITION_MANAGER;\\n    address private immutable MLN_TOKEN;\\n    address private immutable PROTOCOL_FEE_RESERVE;\\n    address private immutable PROTOCOL_FEE_TRACKER;\\n    address private immutable WETH_TOKEN;\\n\\n    modifier notShares(address _asset) {\\n        require(_asset != address(this), \\\"Cannot act on shares\\\");\\n        _;\\n    }\\n\\n    modifier onlyAccessor() {\\n        require(msg.sender == accessor, \\\"Only the designated accessor can make this call\\\");\\n        _;\\n    }\\n\\n    modifier onlyOwner() {\\n        require(__msgSender() == owner, \\\"Only the owner can call this function\\\");\\n        _;\\n    }\\n\\n    constructor(\\n        address _externalPositionManager,\\n        address _gasRelayPaymasterFactory,\\n        address _protocolFeeReserve,\\n        address _protocolFeeTracker,\\n        address _mlnToken,\\n        address _wethToken\\n    ) public GasRelayRecipientMixin(_gasRelayPaymasterFactory) {\\n        EXTERNAL_POSITION_MANAGER = _externalPositionManager;\\n        MLN_TOKEN = _mlnToken;\\n        PROTOCOL_FEE_RESERVE = _protocolFeeReserve;\\n        PROTOCOL_FEE_TRACKER = _protocolFeeTracker;\\n        WETH_TOKEN = _wethToken;\\n    }\\n\\n    /// @dev If a VaultProxy receives ETH, immediately wrap into WETH.\\n    /// Will not be able to receive ETH via .transfer() or .send() due to limited gas forwarding.\\n    receive() external payable {\\n        uint256 ethAmount = payable(address(this)).balance;\\n        IWETH(payable(getWethToken())).deposit{value: ethAmount}();\\n\\n        emit EthReceived(msg.sender, ethAmount);\\n    }\\n\\n    /**\\n     * @dev Transfers the underlying asset to `target`. Used by the LendingPool to transfer\\n     * assets in borrow(), withdraw() and flashLoan()\\n     * @param target The recipient of the aTokens\\n     * @param amount The amount getting transferred\\n     * @return The amount transferred\\n     **/\\n    function transferUnderlyingTo(\\n        address asset,\\n        address target,\\n        uint256 amount\\n    ) public override returns (uint256) {\\n        IERC20(asset).transfer(target, amount);\\n        return amount;\\n    }\\n\\n    /////////////\\n    // GENERAL //\\n    /////////////\\n\\n    /// @notice Gets the external position library contract for a given type\\n    /// @param _typeId The type for which to get the external position library\\n    /// @return externalPositionLib_ The external position library\\n    function getExternalPositionLibForType(uint256 _typeId)\\n        external\\n        view\\n        override\\n        returns (address externalPositionLib_)\\n    {\\n        return\\n            IExternalPositionManager(getExternalPositionManager()).getExternalPositionLibForType(\\n                _typeId\\n            );\\n    }\\n\\n    /// @notice Sets shares as (permanently) freely transferable\\n    /// @dev Once set, this can never be allowed to be unset, as it provides a critical\\n    /// transferability guarantee to liquidity pools and other smart contract holders\\n    /// that rely on transfers to function properly. Enabling this option will skip all\\n    /// policies run upon transferring shares, but will still respect the shares action timelock.\\n    function setFreelyTransferableShares() external onlyOwner {\\n        require(!sharesAreFreelyTransferable(), \\\"setFreelyTransferableShares: Already set\\\");\\n\\n        freelyTransferableShares = true;\\n\\n        emit FreelyTransferableSharesSet();\\n    }\\n\\n    ////////////////////////\\n    // PERMISSIONED ROLES //\\n    ////////////////////////\\n\\n    /// @notice Registers accounts that can manage vault holdings within the protocol\\n    /// @param _managers The accounts to add as asset managers\\n    function addAssetManagers(address[] calldata _managers) external onlyOwner {\\n        for (uint256 i; i < _managers.length; i++) {\\n            require(!isAssetManager(_managers[i]), \\\"addAssetManagers: Manager already registered\\\");\\n\\n            accountToIsAssetManager[_managers[i]] = true;\\n\\n            emit AssetManagerAdded(_managers[i]);\\n        }\\n    }\\n\\n    /// @notice Claim ownership of the contract\\n    function claimOwnership() external {\\n        address nextOwner = nominatedOwner;\\n        require(\\n            msg.sender == nextOwner,\\n            \\\"claimOwnership: Only the nominatedOwner can call this function\\\"\\n        );\\n\\n        delete nominatedOwner;\\n\\n        address prevOwner = owner;\\n        owner = nextOwner;\\n\\n        emit OwnershipTransferred(prevOwner, nextOwner);\\n    }\\n\\n    /// @notice Deregisters accounts that can manage vault holdings within the protocol\\n    /// @param _managers The accounts to remove as asset managers\\n    function removeAssetManagers(address[] calldata _managers) external onlyOwner {\\n        for (uint256 i; i < _managers.length; i++) {\\n            require(isAssetManager(_managers[i]), \\\"removeAssetManagers: Manager not registered\\\");\\n\\n            accountToIsAssetManager[_managers[i]] = false;\\n\\n            emit AssetManagerRemoved(_managers[i]);\\n        }\\n    }\\n\\n    /// @notice Revoke the nomination of a new contract owner\\n    function removeNominatedOwner() external onlyOwner {\\n        address removedNominatedOwner = nominatedOwner;\\n        require(\\n            removedNominatedOwner != address(0),\\n            \\\"removeNominatedOwner: There is no nominated owner\\\"\\n        );\\n\\n        delete nominatedOwner;\\n\\n        emit NominatedOwnerRemoved(removedNominatedOwner);\\n    }\\n\\n    /// @notice Sets the account that is allowed to migrate a fund to new releases\\n    /// @param _nextMigrator The account to set as the allowed migrator\\n    /// @dev Set to address(0) to remove the migrator.\\n    function setMigrator(address _nextMigrator) external onlyOwner {\\n        address prevMigrator = migrator;\\n        require(_nextMigrator != prevMigrator, \\\"setMigrator: Value already set\\\");\\n\\n        migrator = _nextMigrator;\\n\\n        emit MigratorSet(prevMigrator, _nextMigrator);\\n    }\\n\\n    /// @notice Nominate a new contract owner\\n    /// @param _nextNominatedOwner The account to nominate\\n    /// @dev Does not prohibit overwriting the current nominatedOwner\\n    function setNominatedOwner(address _nextNominatedOwner) external onlyOwner {\\n        require(\\n            _nextNominatedOwner != address(0),\\n            \\\"setNominatedOwner: _nextNominatedOwner cannot be empty\\\"\\n        );\\n        require(\\n            _nextNominatedOwner != owner,\\n            \\\"setNominatedOwner: _nextNominatedOwner is already the owner\\\"\\n        );\\n        require(\\n            _nextNominatedOwner != nominatedOwner,\\n            \\\"setNominatedOwner: _nextNominatedOwner is already nominated\\\"\\n        );\\n\\n        nominatedOwner = _nextNominatedOwner;\\n\\n        emit NominatedOwnerSet(_nextNominatedOwner);\\n    }\\n\\n    ////////////////////////\\n    // FUND DEPLOYER ONLY //\\n    ////////////////////////\\n\\n    /// @notice Updates the accessor during a config change within this release\\n    /// @param _nextAccessor The next accessor\\n    function setAccessorForFundReconfiguration(address _nextAccessor) external override {\\n        require(msg.sender == getFundDeployer(), \\\"Only the FundDeployer can make this call\\\");\\n\\n        __setAccessor(_nextAccessor);\\n    }\\n\\n    ///////////////////////////////////////\\n    // ACCESSOR (COMPTROLLER PROXY) ONLY //\\n    ///////////////////////////////////////\\n\\n    //Removed onlyAccessor condition for now\\n    /// @notice Adds a tracked asset\\n    /// @param _asset The asset to add as a tracked asset\\n    function addTrackedAsset(address _asset) external override {\\n        __addTrackedAsset(_asset);\\n    }\\n\\n    /// @notice Burns fund shares from a particular account\\n    /// @param _target The account for which to burn shares\\n    /// @param _amount The amount of shares to burn\\n    function burnShares(address _target, uint256 _amount) external override onlyAccessor {\\n        __burn(_target, _amount);\\n    }\\n\\n    /// @notice Buys back shares collected as protocol fee at a discounted shares price, using MLN\\n    /// @param _sharesAmount The amount of shares to buy back\\n    /// @param _mlnValue The MLN-denominated market value of _sharesAmount\\n    /// @param _gav The total fund GAV\\n    /// @dev Since the vault controls both the MLN to burn and the admin function to burn any user's\\n    /// fund shares, there is no need to transfer assets back-and-forth with the ProtocolFeeReserve.\\n    /// We only need to know the correct discounted amount of MLN to burn.\\n    function buyBackProtocolFeeShares(\\n        uint256 _sharesAmount,\\n        uint256 _mlnValue,\\n        uint256 _gav\\n    ) external override onlyAccessor {\\n        uint256 mlnAmountToBurn = IProtocolFeeReserve1(getProtocolFeeReserve())\\n            .buyBackSharesViaTrustedVaultProxy(_sharesAmount, _mlnValue, _gav);\\n\\n        if (mlnAmountToBurn == 0) {\\n            return;\\n        }\\n\\n        // Burn shares and MLN amounts\\n        // If shares or MLN balance is insufficient, will revert\\n        __burn(getProtocolFeeReserve(), _sharesAmount);\\n        ERC20Burnable(getMlnToken()).burn(mlnAmountToBurn);\\n\\n        emit ProtocolFeeSharesBoughtBack(_sharesAmount, _mlnValue, mlnAmountToBurn);\\n    }\\n\\n    /// @notice Makes an arbitrary call with this contract as the sender\\n    /// @param _contract The contract to call\\n    /// @param _callData The call data for the call\\n    /// @return returnData_ The data returned by the call\\n    function callOnContract(address _contract, bytes calldata _callData)\\n        external\\n        override\\n        onlyAccessor\\n        returns (bytes memory returnData_)\\n    {\\n        bool success;\\n        (success, returnData_) = _contract.call(_callData);\\n        require(success, string(returnData_));\\n\\n        return returnData_;\\n    }\\n\\n    /// @notice Mints fund shares to a particular account\\n    /// @param _target The account for which to burn shares\\n    /// @param _amount The amount of shares to mint\\n    function mintShares(address _target, uint256 _amount) external override onlyAccessor {\\n        __mint(_target, _amount);\\n    }\\n\\n    /// @notice Pays the due protocol fee by minting shares to the ProtocolFeeReserve\\n    function payProtocolFee() external override onlyAccessor {\\n        uint256 sharesDue = IProtocolFeeTracker(getProtocolFeeTracker()).payFee();\\n\\n        if (sharesDue == 0) {\\n            return;\\n        }\\n\\n        __mint(getProtocolFeeReserve(), sharesDue);\\n\\n        emit ProtocolFeePaidInShares(sharesDue);\\n    }\\n\\n    /// @notice Transfers fund shares from one account to another\\n    /// @param _from The account from which to transfer shares\\n    /// @param _to The account to which to transfer shares\\n    /// @param _amount The amount of shares to transfer\\n    /// @dev For protocol use only, all other transfers should operate\\n    /// via standard ERC20 functions\\n    function transferShares(\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) external override onlyAccessor {\\n        __transfer(_from, _to, _amount);\\n    }\\n\\n    /// @notice Withdraws an asset from the VaultProxy to a given account\\n    /// @param _asset The asset to withdraw\\n    /// @param _target The account to which to withdraw the asset\\n    /// @param _amount The amount of asset to withdraw\\n    function withdrawAssetTo(\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) external override {\\n        __withdrawAssetTo(_asset, _target, _amount);\\n    }\\n\\n    /// @notice Withdraws an asset from the VaultProxy to a given account\\n    /// @param _asset The asset to withdraw\\n    /// @param _target The account to which to withdraw the asset\\n    /// @param _amount The amount of asset to withdraw\\n    function withdrawAssetToVault(\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) external override {\\n        __withdrawAssetTo(_asset, _target, _amount);\\n    }\\n\\n    ///////////////////////////\\n    // VAULT ACTION DISPATCH //\\n    ///////////////////////////\\n\\n    /// @notice Dispatches a call initiated from an Extension, validated by the ComptrollerProxy\\n    /// @param _action The VaultAction to perform\\n    /// @param _actionData The call data for the action to perform\\n    function receiveValidatedVaultAction(VaultAction _action, bytes calldata _actionData)\\n        external\\n        override\\n        onlyAccessor\\n    {\\n        if (_action == VaultAction.AddExternalPosition) {\\n            __executeVaultActionAddExternalPosition(_actionData);\\n        } else if (_action == VaultAction.AddTrackedAsset) {\\n            __executeVaultActionAddTrackedAsset(_actionData);\\n        } else if (_action == VaultAction.ApproveAssetSpender) {\\n            __executeVaultActionApproveAssetSpender(_actionData);\\n        } else if (_action == VaultAction.BurnShares) {\\n            __executeVaultActionBurnShares(_actionData);\\n        } else if (_action == VaultAction.CallOnExternalPosition) {\\n            __executeVaultActionCallOnExternalPosition(_actionData);\\n        } else if (_action == VaultAction.MintShares) {\\n            __executeVaultActionMintShares(_actionData);\\n        } else if (_action == VaultAction.RemoveExternalPosition) {\\n            __executeVaultActionRemoveExternalPosition(_actionData);\\n        } else if (_action == VaultAction.RemoveTrackedAsset) {\\n            __executeVaultActionRemoveTrackedAsset(_actionData);\\n        } else if (_action == VaultAction.TransferShares) {\\n            __executeVaultActionTransferShares(_actionData);\\n        } else if (_action == VaultAction.WithdrawAssetTo) {\\n            __executeVaultActionWithdrawAssetTo(_actionData);\\n        }\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.AddExternalPosition\\n    function __executeVaultActionAddExternalPosition(bytes memory _actionData) private {\\n        __addExternalPosition(abi.decode(_actionData, (address)));\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.AddTrackedAsset\\n    function __executeVaultActionAddTrackedAsset(bytes memory _actionData) private {\\n        __addTrackedAsset(abi.decode(_actionData, (address)));\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.ApproveAssetSpender\\n    function __executeVaultActionApproveAssetSpender(bytes memory _actionData) private {\\n        (address asset, address target, uint256 amount) = abi.decode(\\n            _actionData,\\n            (address, address, uint256)\\n        );\\n\\n        __approveAssetSpender(asset, target, amount);\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.BurnShares\\n    function __executeVaultActionBurnShares(bytes memory _actionData) private {\\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\\n\\n        __burn(target, amount);\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.CallOnExternalPosition\\n    function __executeVaultActionCallOnExternalPosition(bytes memory _actionData) private {\\n        (\\n            address externalPosition,\\n            bytes memory callOnExternalPositionActionData,\\n            address[] memory assetsToTransfer,\\n            uint256[] memory amountsToTransfer,\\n            address[] memory assetsToReceive\\n        ) = abi.decode(_actionData, (address, bytes, address[], uint256[], address[]));\\n\\n        __callOnExternalPosition(\\n            externalPosition,\\n            callOnExternalPositionActionData,\\n            assetsToTransfer,\\n            amountsToTransfer,\\n            assetsToReceive\\n        );\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.MintShares\\n    function __executeVaultActionMintShares(bytes memory _actionData) private {\\n        (address target, uint256 amount) = abi.decode(_actionData, (address, uint256));\\n\\n        __mint(target, amount);\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.RemoveExternalPosition\\n    function __executeVaultActionRemoveExternalPosition(bytes memory _actionData) private {\\n        __removeExternalPosition(abi.decode(_actionData, (address)));\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.RemoveTrackedAsset\\n    function __executeVaultActionRemoveTrackedAsset(bytes memory _actionData) private {\\n        __removeTrackedAsset(abi.decode(_actionData, (address)));\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.TransferShares\\n    function __executeVaultActionTransferShares(bytes memory _actionData) private {\\n        (address from, address to, uint256 amount) = abi.decode(\\n            _actionData,\\n            (address, address, uint256)\\n        );\\n\\n        __transfer(from, to, amount);\\n    }\\n\\n    /// @dev Helper to decode actionData and execute VaultAction.WithdrawAssetTo\\n    function __executeVaultActionWithdrawAssetTo(bytes memory _actionData) private {\\n        (address asset, address target, uint256 amount) = abi.decode(\\n            _actionData,\\n            (address, address, uint256)\\n        );\\n\\n        __withdrawAssetTo(asset, target, amount);\\n    }\\n\\n    ///////////////////\\n    // VAULT ACTIONS //\\n    ///////////////////\\n\\n    /// @dev Helper to track a new active external position\\n    function __addExternalPosition(address _externalPosition) private {\\n        if (!isActiveExternalPosition(_externalPosition)) {\\n            __validatePositionsLimit();\\n\\n            externalPositionToIsActive[_externalPosition] = true;\\n            activeExternalPositions.push(_externalPosition);\\n\\n            emit ExternalPositionAdded(_externalPosition);\\n        }\\n    }\\n\\n    /// @dev Helper to add a tracked asset\\n    function __addTrackedAsset(address _asset) private notShares(_asset) {\\n        if (!isTrackedAsset(_asset)) {\\n            __validatePositionsLimit();\\n\\n            assetToIsTracked[_asset] = true;\\n            trackedAssets.push(_asset);\\n\\n            emit TrackedAssetAdded(_asset);\\n        }\\n    }\\n\\n    /// @dev Helper to grant an allowance to a spender to use a vault asset\\n    function __approveAssetSpender(\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) private notShares(_asset) {\\n        ERC20 assetContract = ERC20(_asset);\\n        if (assetContract.allowance(address(this), _target) > 0) {\\n            assetContract.safeApprove(_target, 0);\\n        }\\n        assetContract.safeApprove(_target, _amount);\\n    }\\n\\n    /// @dev Helper to make a call on a external position contract\\n    /// @param _externalPosition The external position to call\\n    /// @param _actionData The action data for the call\\n    /// @param _assetsToTransfer The assets to transfer to the external position\\n    /// @param _amountsToTransfer The amount of assets to be transferred to the external position\\n    /// @param _assetsToReceive The assets that will be received from the call\\n    function __callOnExternalPosition(\\n        address _externalPosition,\\n        bytes memory _actionData,\\n        address[] memory _assetsToTransfer,\\n        uint256[] memory _amountsToTransfer,\\n        address[] memory _assetsToReceive\\n    ) private {\\n        require(\\n            isActiveExternalPosition(_externalPosition),\\n            \\\"__callOnExternalPosition: Not an active external position\\\"\\n        );\\n\\n        for (uint256 i; i < _assetsToTransfer.length; i++) {\\n            __withdrawAssetTo(_assetsToTransfer[i], _externalPosition, _amountsToTransfer[i]);\\n        }\\n\\n        IExternalPosition(_externalPosition).receiveCallFromVault(_actionData);\\n\\n        for (uint256 i; i < _assetsToReceive.length; i++) {\\n            __addTrackedAsset(_assetsToReceive[i]);\\n        }\\n    }\\n\\n    /// @dev Helper to the get the Vault's balance of a given asset\\n    function __getAssetBalance(address _asset) private view returns (uint256 balance_) {\\n        return ERC20(_asset).balanceOf(address(this));\\n    }\\n\\n    /// @dev Helper to remove a external position from the vault\\n    function __removeExternalPosition(address _externalPosition) private {\\n        if (isActiveExternalPosition(_externalPosition)) {\\n            externalPositionToIsActive[_externalPosition] = false;\\n\\n            activeExternalPositions.removeStorageItem(_externalPosition);\\n\\n            emit ExternalPositionRemoved(_externalPosition);\\n        }\\n    }\\n\\n    /// @dev Helper to remove a tracked asset\\n    function __removeTrackedAsset(address _asset) private {\\n        if (isTrackedAsset(_asset)) {\\n            assetToIsTracked[_asset] = false;\\n\\n            trackedAssets.removeStorageItem(_asset);\\n\\n            emit TrackedAssetRemoved(_asset);\\n        }\\n    }\\n\\n    /// @dev Helper to validate that the positions limit has not been reached\\n    function __validatePositionsLimit() private view {\\n        require(\\n            trackedAssets.length + activeExternalPositions.length < POSITIONS_LIMIT,\\n            \\\"__validatePositionsLimit: Limit exceeded\\\"\\n        );\\n    }\\n\\n    /// @dev Helper to withdraw an asset from the vault to a specified recipient\\n    function __withdrawAssetTo(\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) private notShares(_asset) {\\n        ERC20(_asset).transfer(_target, _amount);\\n\\n        emit AssetWithdrawn(_asset, _target, _amount);\\n    }\\n\\n    ////////////////////////////\\n    // SHARES ERC20 OVERRIDES //\\n    ////////////////////////////\\n\\n    /// @notice Gets the `symbol` value of the shares token\\n    /// @return symbol_ The `symbol` value\\n    /// @dev Defers the shares symbol value to the Dispatcher contract\\n    function symbol() public view override returns (string memory symbol_) {\\n        return IDispatcher(creator).getSharesTokenSymbol();\\n    }\\n\\n    /// @dev Standard implementation of ERC20's transfer().\\n    /// Overridden to allow arbitrary logic in ComptrollerProxy prior to transfer.\\n    function transfer(address _recipient, uint256 _amount)\\n        public\\n        override\\n        returns (bool success_)\\n    {\\n        __invokePreTransferSharesHook(msg.sender, _recipient, _amount);\\n\\n        return super.transfer(_recipient, _amount);\\n    }\\n\\n    /// @dev Standard implementation of ERC20's transferFrom().\\n    /// Overridden to allow arbitrary logic in ComptrollerProxy prior to transfer.\\n    function transferFrom(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) public override returns (bool success_) {\\n        __invokePreTransferSharesHook(_sender, _recipient, _amount);\\n\\n        return super.transferFrom(_sender, _recipient, _amount);\\n    }\\n\\n    /// @dev Helper to call the relevant preTransferShares hook\\n    function __invokePreTransferSharesHook(\\n        address _sender,\\n        address _recipient,\\n        uint256 _amount\\n    ) private {\\n        if (sharesAreFreelyTransferable()) {\\n            IComptroller(accessor).preTransferSharesHookFreelyTransferable(_sender);\\n        } else {\\n            IComptroller(accessor).preTransferSharesHook(_sender, _recipient, _amount);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Checks whether an account can manage assets\\n    /// @param _who The account to check\\n    /// @return canManageAssets_ True if the account can manage assets\\n    function canManageAssets(address _who) external view override returns (bool canManageAssets_) {\\n        return _who == getOwner() || isAssetManager(_who);\\n    }\\n\\n    /// @notice Checks whether an account can use gas relaying\\n    /// @param _who The account to check\\n    /// @return canRelayCalls_ True if the account can use gas relaying on this fund\\n    function canRelayCalls(address _who) external view override returns (bool canRelayCalls_) {\\n        return _who == getOwner() || isAssetManager(_who) || _who == getMigrator();\\n    }\\n\\n    /// @notice Gets the `accessor` variable\\n    /// @return accessor_ The `accessor` variable value\\n    function getAccessor() public view override returns (address accessor_) {\\n        return accessor;\\n    }\\n\\n    /// @notice Gets the `creator` variable\\n    /// @return creator_ The `creator` variable value\\n    function getCreator() external view returns (address creator_) {\\n        return creator;\\n    }\\n\\n    /// @notice Gets the `migrator` variable\\n    /// @return migrator_ The `migrator` variable value\\n    function getMigrator() public view returns (address migrator_) {\\n        return migrator;\\n    }\\n\\n    /// @notice Gets the account that is nominated to be the next owner of this contract\\n    /// @return nominatedOwner_ The account that is nominated to be the owner\\n    function getNominatedOwner() external view returns (address nominatedOwner_) {\\n        return nominatedOwner;\\n    }\\n\\n    /// @notice Gets the `activeExternalPositions` variable\\n    /// @return activeExternalPositions_ The `activeExternalPositions` variable value\\n    function getActiveExternalPositions()\\n        external\\n        view\\n        override\\n        returns (address[] memory activeExternalPositions_)\\n    {\\n        return activeExternalPositions;\\n    }\\n\\n    /// @notice Gets the `trackedAssets` variable\\n    /// @return trackedAssets_ The `trackedAssets` variable value\\n    function getTrackedAssets() external view override returns (address[] memory trackedAssets_) {\\n        return trackedAssets;\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Gets the `EXTERNAL_POSITION_MANAGER` variable\\n    /// @return externalPositionManager_ The `EXTERNAL_POSITION_MANAGER` variable value\\n    function getExternalPositionManager() public view returns (address externalPositionManager_) {\\n        return EXTERNAL_POSITION_MANAGER;\\n    }\\n\\n    /// @notice Gets the vaults fund deployer\\n    /// @return fundDeployer_ The fund deployer contract associated with this vault\\n    function getFundDeployer() public view returns (address fundDeployer_) {\\n        return IDispatcher(creator).getFundDeployerForVaultProxy(address(this));\\n    }\\n\\n    /// @notice Gets the `MLN_TOKEN` variable\\n    /// @return mlnToken_ The `MLN_TOKEN` variable value\\n    function getMlnToken() public view returns (address mlnToken_) {\\n        return MLN_TOKEN;\\n    }\\n\\n    /// @notice Gets the `owner` variable\\n    /// @return owner_ The `owner` variable value\\n    function getOwner() public view override returns (address owner_) {\\n        return owner;\\n    }\\n\\n    /// @notice Gets the `PROTOCOL_FEE_RESERVE` variable\\n    /// @return protocolFeeReserve_ The `PROTOCOL_FEE_RESERVE` variable value\\n    function getProtocolFeeReserve() public view returns (address protocolFeeReserve_) {\\n        return PROTOCOL_FEE_RESERVE;\\n    }\\n\\n    /// @notice Gets the `PROTOCOL_FEE_TRACKER` variable\\n    /// @return protocolFeeTracker_ The `PROTOCOL_FEE_TRACKER` variable value\\n    function getProtocolFeeTracker() public view returns (address protocolFeeTracker_) {\\n        return PROTOCOL_FEE_TRACKER;\\n    }\\n\\n    /// @notice Check whether an external position is active on the vault\\n    /// @param _externalPosition The externalPosition to check\\n    /// @return isActiveExternalPosition_ True if the address is an active external position on the vault\\n    function isActiveExternalPosition(address _externalPosition)\\n        public\\n        view\\n        override\\n        returns (bool isActiveExternalPosition_)\\n    {\\n        return externalPositionToIsActive[_externalPosition];\\n    }\\n\\n    /// @notice Checks whether an account is an allowed asset manager\\n    /// @param _who The account to check\\n    /// @return isAssetManager_ True if the account is an allowed asset manager\\n    function isAssetManager(address _who) public view returns (bool isAssetManager_) {\\n        return accountToIsAssetManager[_who];\\n    }\\n\\n    /// @notice Checks whether an address is a tracked asset of the vault\\n    /// @param _asset The address to check\\n    /// @return isTrackedAsset_ True if the address is a tracked asset\\n    function isTrackedAsset(address _asset) public view override returns (bool isTrackedAsset_) {\\n        return assetToIsTracked[_asset];\\n    }\\n\\n    /// @notice Checks whether shares are (permanently) freely transferable\\n    /// @return sharesAreFreelyTransferable_ True if shares are (permanently) freely transferable\\n    function sharesAreFreelyTransferable()\\n        public\\n        view\\n        override\\n        returns (bool sharesAreFreelyTransferable_)\\n    {\\n        return freelyTransferableShares;\\n    }\\n\\n    /// @notice Gets the `WETH_TOKEN` variable\\n    /// @return wethToken_ The `WETH_TOKEN` variable value\\n    function getWethToken() public view returns (address wethToken_) {\\n        return WETH_TOKEN;\\n    }\\n\\n    function debugGav(\\n        address asset,\\n        uint256 balance,\\n        address vault\\n    ) external view override {\\n        console.log(\\\"calcGav:For asset :%s\\\", asset);\\n        console.log(\\\"calcGav:Balance asset :%d\\\", balance);\\n        console.log(\\\"calcGav:proxy vault :%s\\\", vault);\\n    }\\n\\n    function handleRepayment(address user, uint256 amount) external override {}\\n}\\n\",\"keccak256\":\"0x641871aa23e6a5b84a6067d34045f621645877052ec898e05c4a0703208c3bf0\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/IExtension.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExtension Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all extensions\\ninterface IExtension {\\n    function activateForFund(bool _isMigration) external;\\n\\n    function deactivateForFund() external;\\n\\n    function receiveCallFromComptroller(\\n        address _caller,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external;\\n\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external;\\n}\\n\",\"keccak256\":\"0x59aaa2ddd32c24271bd4a57e9e1f3426570a78cd56d6d11e63786f36c916e94b\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/external-position-manager/IExternalPositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IExternalPositionManager interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the ExternalPositionManager\\ninterface IExternalPositionManager {\\n    struct ExternalPositionTypeInfo {\\n        address parser;\\n        address lib;\\n    }\\n    enum ExternalPositionManagerActions {\\n        CreateExternalPosition,\\n        CallOnExternalPosition,\\n        RemoveExternalPosition,\\n        ReactivateExternalPosition\\n    }\\n\\n    function getExternalPositionLibForType(uint256) external view returns (address);\\n}\\n\",\"keccak256\":\"0x3af3f634e1f99fb97091b7825c0d2e2baaafc124d4e87d56cb0c17ff8554f6c6\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/FeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"../../core/fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\nimport \\\"../../utils/AddressArrayLib.sol\\\";\\nimport \\\"../utils/ExtensionBase.sol\\\";\\nimport \\\"../utils/PermissionedVaultActionMixin.sol\\\";\\nimport \\\"./IFee.sol\\\";\\nimport \\\"./IFeeManager.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title FeeManager Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Manages fees for funds\\n/// @dev Any arbitrary fee is allowed by default, so all participants must be aware of\\n/// their fund's configuration, especially whether they use official fees only.\\n/// Fees can only be added upon fund setup, migration, or reconfiguration.\\ncontract FeeManager is IFeeManager, ExtensionBase, PermissionedVaultActionMixin {\\n    using AddressArrayLib for address[];\\n    using SafeMath for uint256;\\n\\n    event FeeEnabledForFund(\\n        address indexed comptrollerProxy,\\n        address indexed fee,\\n        bytes settingsData\\n    );\\n\\n    event FeeSettledForFund(\\n        address indexed comptrollerProxy,\\n        address indexed fee,\\n        SettlementType indexed settlementType,\\n        address payer,\\n        address payee,\\n        uint256 sharesDue\\n    );\\n\\n    event SharesOutstandingPaidForFund(\\n        address indexed comptrollerProxy,\\n        address indexed fee,\\n        address indexed payee,\\n        uint256 sharesDue\\n    );\\n\\n    mapping(address => address[]) private comptrollerProxyToFees;\\n    mapping(address => mapping(address => uint256))\\n        private comptrollerProxyToFeeToSharesOutstanding;\\n\\n    constructor(address _fundDeployer) public ExtensionBase(_fundDeployer) {}\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Activate already-configured fees for use in the calling fund\\n    function activateForFund(bool) external override {\\n        address comptrollerProxy = msg.sender;\\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\\n\\n        address[] memory enabledFees = getEnabledFeesForFund(comptrollerProxy);\\n        for (uint256 i; i < enabledFees.length; i++) {\\n            IFee(enabledFees[i]).activateForFund(comptrollerProxy, vaultProxy);\\n        }\\n    }\\n\\n    /// @notice Deactivate fees for a fund\\n    /// @dev There will be no fees if the caller is not a valid ComptrollerProxy\\n    function deactivateForFund() external override {\\n        address comptrollerProxy = msg.sender;\\n        address vaultProxy = getVaultProxyForFund(comptrollerProxy);\\n\\n        // Force payout of remaining shares outstanding\\n        address[] memory fees = getEnabledFeesForFund(comptrollerProxy);\\n        for (uint256 i; i < fees.length; i++) {\\n            __payoutSharesOutstanding(comptrollerProxy, vaultProxy, fees[i]);\\n        }\\n    }\\n\\n    /// @notice Allows all fees for a particular FeeHook to implement settle() and update() logic\\n    /// @param _hook The FeeHook to invoke\\n    /// @param _settlementData The encoded settlement parameters specific to the FeeHook\\n    /// @param _gav The GAV for a fund if known in the invocating code, otherwise 0\\n    function invokeHook(\\n        FeeHook _hook,\\n        bytes calldata _settlementData,\\n        uint256 _gav\\n    ) external override {\\n        __invokeHook(msg.sender, _hook, _settlementData, _gav, true);\\n    }\\n\\n    /// @notice Receives a dispatched `callOnExtension` from a fund's ComptrollerProxy\\n    /// @param _actionId An ID representing the desired action\\n    /// @param _callArgs Encoded arguments specific to the _actionId\\n    /// @dev This is the only way to call a function on this contract that updates VaultProxy state.\\n    /// For both of these actions, any caller is allowed, so we don't use the caller param.\\n    function receiveCallFromComptroller(\\n        address,\\n        uint256 _actionId,\\n        bytes calldata _callArgs\\n    ) external override {\\n        if (_actionId == 0) {\\n            // Settle and update all continuous fees\\n            __invokeHook(msg.sender, IFeeManager.FeeHook.Continuous, \\\"\\\", 0, true);\\n        } else if (_actionId == 1) {\\n            __payoutSharesOutstandingForFees(msg.sender, _callArgs);\\n        } else {\\n            revert(\\\"receiveCallFromComptroller: Invalid _actionId\\\");\\n        }\\n    }\\n\\n    /// @notice Enable and configure fees for use in the calling fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _vaultProxy The VaultProxy of the fund\\n    /// @param _configData Encoded config data\\n    /// @dev The order of `fees` determines the order in which fees of the same FeeHook will be applied.\\n    /// It is recommended to run ManagementFee before PerformanceFee in order to achieve precise\\n    /// PerformanceFee calcs.\\n    function setConfigForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        bytes calldata _configData\\n    ) external override onlyFundDeployer {\\n        console.log(\\\"FeeManager:setConfigForFund:sender  %s\\\", msg.sender);\\n\\n        __setValidatedVaultProxy(_comptrollerProxy, _vaultProxy);\\n\\n        console.log(\\\"FeeManager:setConfigForFund:__setValidatedVaultProxy\\\");\\n        console.logBytes(_configData);\\n\\n        (address[3] memory fees, bytes[3] memory settingsData) = abi.decode(\\n            _configData,\\n            (address[3], bytes[3])\\n        );\\n        console.log(\\\"FeeManager:abi decode\\\");\\n\\n        for (uint256 i; i < fees.length; i++) {\\n            console.log(\\\"FeeManager:setConfigForFund:fees: %s\\\", fees[i]);\\n            console.logBytes(settingsData[i]);\\n        }\\n\\n        console.log(\\\"FeeManager:setConfigForFund:settingsData\\\");\\n        // Sanity checks\\n        require(\\n            fees.length == settingsData.length,\\n            \\\"setConfigForFund: fees and settingsData array lengths unequal\\\"\\n        );\\n        console.log(\\\"FeeManager:setConfigForFund:first require\\\");\\n\\n        //require(fees.isUniqueSet(), \\\"setConfigForFund: fees cannot include duplicates\\\");\\n\\n        console.log(\\\"FeeManager:setConfigForFund:second require\\\");\\n        // Enable each fee with settings\\n        for (uint256 i; i < fees.length; i++) {\\n            console.log(\\\"FeeManager:setConfigForFund:loop: %d\\\", i);\\n            // Set fund config on fee\\n            IFee(fees[i]).addFundSettings(_comptrollerProxy, settingsData[i]);\\n            console.log(\\\"FeeManager:setConfigForFund:addFundSettings\\\");\\n            // Enable fee for fund\\n            comptrollerProxyToFees[_comptrollerProxy].push(fees[i]);\\n            console.log(\\\"FeeManager:setConfigForFund:comptrollerProxyToFees\\\");\\n            emit FeeEnabledForFund(_comptrollerProxy, fees[i], settingsData[i]);\\n        }\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Helper to get the canonical value of GAV if not yet set and required by fee\\n    function __getGavAsNecessary(address _comptrollerProxy, uint256 _gavOrZero)\\n        private\\n        returns (uint256 gav_)\\n    {\\n        if (_gavOrZero == 0) {\\n            // Do not finalize synths, as this can lead to lost fees when redeeming shares\\n            return IComptroller(_comptrollerProxy).calcGav(false);\\n        } else {\\n            return _gavOrZero;\\n        }\\n    }\\n\\n    /// @dev Helper to run settle() on all enabled fees for a fund that implement a given hook, and then to\\n    /// optionally run update() on the same fees. This order allows fees an opportunity to update\\n    /// their local state after all VaultProxy state transitions (i.e., minting, burning,\\n    /// transferring shares) have finished. To optimize for the expensive operation of calculating\\n    /// GAV, once one fee requires GAV, we recycle that `gav` value for subsequent fees.\\n    /// Assumes that _gav is either 0 or has already been validated.\\n    function __invokeHook(\\n        address _comptrollerProxy,\\n        FeeHook _hook,\\n        bytes memory _settlementData,\\n        uint256 _gavOrZero,\\n        bool _updateFees\\n    ) private {\\n        address[] memory fees = getEnabledFeesForFund(_comptrollerProxy);\\n        if (fees.length == 0) {\\n            return;\\n        }\\n\\n        address vaultProxy = getVaultProxyForFund(_comptrollerProxy);\\n\\n        // This check isn't strictly necessary, but its cost is insignificant,\\n        // and helps to preserve data integrity.\\n        require(vaultProxy != address(0), \\\"__invokeHook: Fund is not active\\\");\\n\\n        // First, allow all fees to implement settle()\\n        uint256 gav = __settleFees(\\n            _comptrollerProxy,\\n            vaultProxy,\\n            fees,\\n            _hook,\\n            _settlementData,\\n            _gavOrZero\\n        );\\n\\n        // Second, allow fees to implement update()\\n        // This function does not allow any further altering of VaultProxy state\\n        // (i.e., burning, minting, or transferring shares)\\n        if (_updateFees) {\\n            __updateFees(_comptrollerProxy, vaultProxy, fees, _hook, _settlementData, gav);\\n        }\\n    }\\n\\n    /// @dev Helper to get the end recipient for a given fee and fund\\n    function __parseFeeRecipientForFund(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address _fee\\n    ) private view returns (address recipient_) {\\n        recipient_ = IFee(_fee).getRecipientForFund(_comptrollerProxy);\\n        if (recipient_ == address(0)) {\\n            recipient_ = IVault(_vaultProxy).getOwner();\\n        }\\n\\n        return recipient_;\\n    }\\n\\n    /// @dev Helper to payout the shares outstanding for the specified fees.\\n    /// Does not call settle() on fees.\\n    /// Only callable via ComptrollerProxy.callOnExtension().\\n    function __payoutSharesOutstandingForFees(address _comptrollerProxy, bytes memory _callArgs)\\n        private\\n    {\\n        address[] memory fees = abi.decode(_callArgs, (address[]));\\n        address vaultProxy = getVaultProxyForFund(msg.sender);\\n\\n        for (uint256 i; i < fees.length; i++) {\\n            if (IFee(fees[i]).payout(_comptrollerProxy, vaultProxy)) {\\n                __payoutSharesOutstanding(_comptrollerProxy, vaultProxy, fees[i]);\\n            }\\n        }\\n    }\\n\\n    /// @dev Helper to payout shares outstanding for a given fee.\\n    /// Assumes the fee is payout-able.\\n    function __payoutSharesOutstanding(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address _fee\\n    ) private {\\n        uint256 sharesOutstanding = getFeeSharesOutstandingForFund(_comptrollerProxy, _fee);\\n        if (sharesOutstanding == 0) {\\n            return;\\n        }\\n\\n        delete comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\\n\\n        address payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\\n\\n        __transferShares(_comptrollerProxy, _vaultProxy, payee, sharesOutstanding);\\n\\n        emit SharesOutstandingPaidForFund(_comptrollerProxy, _fee, payee, sharesOutstanding);\\n    }\\n\\n    /// @dev Helper to settle a fee\\n    function __settleFee(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address _fee,\\n        FeeHook _hook,\\n        bytes memory _settlementData,\\n        uint256 _gav\\n    ) private {\\n        (SettlementType settlementType, address payer, uint256 sharesDue) = IFee(_fee).settle(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            _hook,\\n            _settlementData,\\n            _gav\\n        );\\n        if (settlementType == SettlementType.None) {\\n            return;\\n        }\\n\\n        address payee;\\n        if (settlementType == SettlementType.Direct) {\\n            payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\\n            __transferShares(_comptrollerProxy, payer, payee, sharesDue);\\n        } else if (settlementType == SettlementType.Mint) {\\n            payee = __parseFeeRecipientForFund(_comptrollerProxy, _vaultProxy, _fee);\\n            __mintShares(_comptrollerProxy, payee, sharesDue);\\n        } else if (settlementType == SettlementType.Burn) {\\n            __burnShares(_comptrollerProxy, payer, sharesDue);\\n        } else if (settlementType == SettlementType.MintSharesOutstanding) {\\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\\n                .add(sharesDue);\\n\\n            payee = _vaultProxy;\\n            __mintShares(_comptrollerProxy, payee, sharesDue);\\n        } else if (settlementType == SettlementType.BurnSharesOutstanding) {\\n            comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee] = comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee]\\n                .sub(sharesDue);\\n\\n            payer = _vaultProxy;\\n            __burnShares(_comptrollerProxy, payer, sharesDue);\\n        } else {\\n            revert(\\\"__settleFee: Invalid SettlementType\\\");\\n        }\\n\\n        emit FeeSettledForFund(_comptrollerProxy, _fee, settlementType, payer, payee, sharesDue);\\n    }\\n\\n    /// @dev Helper to settle fees that implement a given fee hook\\n    function __settleFees(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address[] memory _fees,\\n        FeeHook _hook,\\n        bytes memory _settlementData,\\n        uint256 _gavOrZero\\n    ) private returns (uint256 gav_) {\\n        gav_ = _gavOrZero;\\n\\n        for (uint256 i; i < _fees.length; i++) {\\n            (bool settles, bool usesGav) = IFee(_fees[i]).settlesOnHook(_hook);\\n            if (!settles) {\\n                continue;\\n            }\\n\\n            if (usesGav) {\\n                gav_ = __getGavAsNecessary(_comptrollerProxy, gav_);\\n            }\\n\\n            __settleFee(_comptrollerProxy, _vaultProxy, _fees[i], _hook, _settlementData, gav_);\\n        }\\n\\n        return gav_;\\n    }\\n\\n    /// @dev Helper to update fees that implement a given fee hook\\n    function __updateFees(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        address[] memory _fees,\\n        FeeHook _hook,\\n        bytes memory _settlementData,\\n        uint256 _gavOrZero\\n    ) private {\\n        uint256 gav = _gavOrZero;\\n\\n        for (uint256 i; i < _fees.length; i++) {\\n            (bool updates, bool usesGav) = IFee(_fees[i]).updatesOnHook(_hook);\\n            if (!updates) {\\n                continue;\\n            }\\n\\n            if (usesGav) {\\n                gav = __getGavAsNecessary(_comptrollerProxy, gav);\\n            }\\n\\n            IFee(_fees[i]).update(_comptrollerProxy, _vaultProxy, _hook, _settlementData, gav);\\n        }\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Get a list of enabled fees for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return enabledFees_ An array of enabled fee addresses\\n    function getEnabledFeesForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address[] memory enabledFees_)\\n    {\\n        return comptrollerProxyToFees[_comptrollerProxy];\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Get the amount of shares outstanding for a particular fee for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _fee The fee address\\n    /// @return sharesOutstanding_ The amount of shares outstanding\\n    function getFeeSharesOutstandingForFund(address _comptrollerProxy, address _fee)\\n        public\\n        view\\n        returns (uint256 sharesOutstanding_)\\n    {\\n        return comptrollerProxyToFeeToSharesOutstanding[_comptrollerProxy][_fee];\\n    }\\n}\\n\",\"keccak256\":\"0x3956e1f4c012de57b4d24bebaf4f3433c23ab9aa83ee2edb48887714059aaa4d\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/IFee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"./IFeeManager.sol\\\";\\n\\n/// @title Fee Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for all fees\\ninterface IFee {\\n    function activateForFund(address _comptrollerProxy, address _vaultProxy) external;\\n\\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData) external;\\n\\n    function payout(address _comptrollerProxy, address _vaultProxy)\\n        external\\n        returns (bool isPayable_);\\n\\n    function getRecipientForFund(address _comptrollerProxy)\\n        external\\n        view\\n        returns (address recipient_);\\n\\n    function settle(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IFeeManager.FeeHook _hook,\\n        bytes calldata _settlementData,\\n        uint256 _gav\\n    )\\n        external\\n        returns (\\n            IFeeManager.SettlementType settlementType_,\\n            address payer_,\\n            uint256 sharesDue_\\n        );\\n\\n    function settlesOnHook(IFeeManager.FeeHook _hook)\\n        external\\n        view\\n        returns (bool settles_, bool usesGav_);\\n\\n    function update(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IFeeManager.FeeHook _hook,\\n        bytes calldata _settlementData,\\n        uint256 _gav\\n    ) external;\\n\\n    function updatesOnHook(IFeeManager.FeeHook _hook)\\n        external\\n        view\\n        returns (bool updates_, bool usesGav_);\\n}\\n\",\"keccak256\":\"0x38e3f324c67f3205e38197165586ea82ca226069902f34214bcde76cf905fcff\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/IFeeManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/// @title FeeManager Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the FeeManager\\ninterface IFeeManager {\\n    // No fees for the current release are implemented post-redeemShares\\n    enum FeeHook {Continuous, PreBuyShares, PostBuyShares, PreRedeemShares}\\n    enum SettlementType {None, Direct, Mint, Burn, MintSharesOutstanding, BurnSharesOutstanding}\\n\\n    function invokeHook(\\n        FeeHook,\\n        bytes calldata,\\n        uint256\\n    ) external;\\n}\\n\",\"keccak256\":\"0xa0cfee013a2a0f8891ee558dec4568dd6e76e3f033a214cbe5e74e93e8f68fd2\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/fees/PerformanceFee.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/math/SignedSafeMath.sol\\\";\\nimport \\\"@openzeppelin/contracts/token/ERC20/ERC20.sol\\\";\\nimport \\\"../../../core/fund/comptroller/ComptrollerLib.sol\\\";\\nimport \\\"../FeeManager.sol\\\";\\nimport \\\"./utils/FeeBase.sol\\\";\\nimport \\\"./utils/UpdatableFeeRecipientBase.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title PerformanceFee Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A performance-based fee with configurable rate and crystallization period, using\\n/// a high watermark\\n/// @dev This contract assumes that all shares in the VaultProxy are shares outstanding,\\n/// which is fine for this release. Even if they are not, they are still shares that\\n/// are only claimable by the fund owner.\\ncontract PerformanceFee is FeeBase, UpdatableFeeRecipientBase {\\n    using SafeMath for uint256;\\n    using SignedSafeMath for int256;\\n\\n    event ActivatedForFund(address indexed comptrollerProxy, uint256 highWaterMark);\\n\\n    event FundSettingsAdded(address indexed comptrollerProxy, uint256 rate, uint256 period);\\n\\n    event LastSharePriceUpdated(\\n        address indexed comptrollerProxy,\\n        uint256 prevSharePrice,\\n        uint256 nextSharePrice\\n    );\\n\\n    event PaidOut(\\n        address indexed comptrollerProxy,\\n        uint256 prevHighWaterMark,\\n        uint256 nextHighWaterMark,\\n        uint256 aggregateValueDue\\n    );\\n\\n    event PerformanceUpdated(\\n        address indexed comptrollerProxy,\\n        uint256 prevAggregateValueDue,\\n        uint256 nextAggregateValueDue,\\n        int256 sharesOutstandingDiff\\n    );\\n\\n    struct FeeInfo {\\n        uint16 rate;\\n        uint64 period;\\n        uint64 activated;\\n        uint64 lastPaid;\\n        uint256 highWaterMark;\\n        uint256 lastSharePrice;\\n        uint256 aggregateValueDue;\\n    }\\n\\n    uint256 private constant ONE_HUNDRED_PERCENT = 10000;\\n    uint256 private constant SHARE_UNIT = 10**18;\\n\\n    mapping(address => FeeInfo) private comptrollerProxyToFeeInfo;\\n\\n    constructor(address _feeManager) public FeeBase(_feeManager) {}\\n\\n    // EXTERNAL FUNCTIONS\\n\\n    /// @notice Activates the fee for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    function activateForFund(address _comptrollerProxy, address) external override onlyFeeManager {\\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\\n\\n        // We must not force asset finality, otherwise funds that have Synths as tracked assets\\n        // would be susceptible to a DoS attack when attempting to migrate to a release that uses\\n        // this fee: an attacker trades a negligible amount of a tracked Synth with the VaultProxy\\n        // as the recipient, thus causing `calcGrossShareValue(true)` to fail.\\n        uint256 grossSharePrice = ComptrollerLib(_comptrollerProxy).calcGrossShareValue(false);\\n\\n        feeInfo.highWaterMark = grossSharePrice;\\n        feeInfo.lastSharePrice = grossSharePrice;\\n        feeInfo.activated = uint64(block.timestamp);\\n\\n        emit ActivatedForFund(_comptrollerProxy, grossSharePrice);\\n    }\\n\\n    /// @notice Add the initial fee settings for a fund\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _settingsData Encoded settings to apply to the fee for a fund\\n    /// @dev `highWaterMark`, `lastSharePrice`, and `activated` are set during activation\\n    function addFundSettings(address _comptrollerProxy, bytes calldata _settingsData)\\n        external\\n        override\\n        onlyFeeManager\\n    {\\n        console.log(\\\"PerformaceFee:addFundSettings:begin\\\");\\n        console.logBytes(_settingsData);\\n        (uint16 feeRate, uint64 feePeriod, address recipient) = abi.decode(\\n            _settingsData,\\n            (uint16, uint64, address)\\n        );\\n        console.log(\\\"PerformaceFee:addFundSettings:feeRate:%d\\\", feeRate);\\n        console.log(\\\"PerformaceFee:addFundSettings:feePeriod:%d\\\", feePeriod);\\n        console.log(\\\"PerformaceFee:addFundSettings:recipient:%s\\\", recipient);\\n\\n        require(feeRate > 0, \\\"addFundSettings: feeRate must be greater than 0\\\");\\n        // Unlike most other fees, there could be a case for using a rate of exactly 100%,\\n        // i.e., pay out all profits to a specified recipient\\n        require(feeRate <= ONE_HUNDRED_PERCENT, \\\"addFundSettings: feeRate max exceeded\\\");\\n        require(feePeriod > 0, \\\"addFundSettings: feePeriod must be greater than 0\\\");\\n        console.log(\\\"PerformaceFee:addFundSettings afre requires\\\");\\n\\n        comptrollerProxyToFeeInfo[_comptrollerProxy] = FeeInfo({\\n            rate: feeRate,\\n            period: feePeriod,\\n            activated: 0,\\n            lastPaid: 0,\\n            highWaterMark: 0,\\n            lastSharePrice: 0,\\n            aggregateValueDue: 0\\n        });\\n        console.log(\\\"PerformaceFee:addFundSettings after comptrollerProxyToFeeInfo\\\");\\n\\n        emit FundSettingsAdded(_comptrollerProxy, feeRate, feePeriod);\\n        console.log(\\\"PerformaceFee:addFundSettings after FundSettingsAdded\\\");\\n\\n        if (recipient != address(0)) {\\n            __setRecipientForFund(_comptrollerProxy, recipient);\\n        }\\n    }\\n\\n    /// @notice Checks whether the shares outstanding for the fee can be paid out, and updates\\n    /// the info for the fee's last payout\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return isPayable_ True if shares outstanding can be paid out\\n    function payout(address _comptrollerProxy, address)\\n        external\\n        override\\n        onlyFeeManager\\n        returns (bool isPayable_)\\n    {\\n        if (!payoutAllowed(_comptrollerProxy)) {\\n            return false;\\n        }\\n\\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\\n        feeInfo.lastPaid = uint64(block.timestamp);\\n\\n        uint256 prevHighWaterMark = feeInfo.highWaterMark;\\n        uint256 nextHighWaterMark = __calcUint256Max(feeInfo.lastSharePrice, prevHighWaterMark);\\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\\n\\n        // Update state as necessary\\n        if (prevAggregateValueDue > 0) {\\n            feeInfo.aggregateValueDue = 0;\\n        }\\n        if (nextHighWaterMark > prevHighWaterMark) {\\n            feeInfo.highWaterMark = nextHighWaterMark;\\n        }\\n\\n        emit PaidOut(\\n            _comptrollerProxy,\\n            prevHighWaterMark,\\n            nextHighWaterMark,\\n            prevAggregateValueDue\\n        );\\n\\n        return true;\\n    }\\n\\n    /// @notice Settles the fee and calculates shares due\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _vaultProxy The VaultProxy of the fund\\n    /// @param _gav The GAV of the fund\\n    /// @return settlementType_ The type of settlement\\n    /// @return (unused) The payer of shares due\\n    /// @return sharesDue_ The amount of shares due\\n    function settle(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IFeeManager.FeeHook,\\n        bytes calldata,\\n        uint256 _gav\\n    )\\n        external\\n        override\\n        onlyFeeManager\\n        returns (\\n            IFeeManager.SettlementType settlementType_,\\n            address,\\n            uint256 sharesDue_\\n        )\\n    {\\n        if (_gav == 0) {\\n            return (IFeeManager.SettlementType.None, address(0), 0);\\n        }\\n\\n        int256 settlementSharesDue = __settleAndUpdatePerformance(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            _gav\\n        );\\n        if (settlementSharesDue == 0) {\\n            return (IFeeManager.SettlementType.None, address(0), 0);\\n        } else if (settlementSharesDue > 0) {\\n            // Settle by minting shares outstanding for custody\\n            return (\\n                IFeeManager.SettlementType.MintSharesOutstanding,\\n                address(0),\\n                uint256(settlementSharesDue)\\n            );\\n        } else {\\n            // Settle by burning from shares outstanding\\n            return (\\n                IFeeManager.SettlementType.BurnSharesOutstanding,\\n                address(0),\\n                uint256(-settlementSharesDue)\\n            );\\n        }\\n    }\\n\\n    /// @notice Gets whether the fee settles and requires GAV on a particular hook\\n    /// @param _hook The FeeHook\\n    /// @return settles_ True if the fee settles on the _hook\\n    /// @return usesGav_ True if the fee uses GAV during settle() for the _hook\\n    function settlesOnHook(IFeeManager.FeeHook _hook)\\n        external\\n        view\\n        override\\n        returns (bool settles_, bool usesGav_)\\n    {\\n        if (\\n            _hook == IFeeManager.FeeHook.PreBuyShares ||\\n            _hook == IFeeManager.FeeHook.PreRedeemShares ||\\n            _hook == IFeeManager.FeeHook.Continuous\\n        ) {\\n            return (true, true);\\n        }\\n\\n        return (false, false);\\n    }\\n\\n    /// @notice Updates the fee state after all fees have finished settle()\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _vaultProxy The VaultProxy of the fund\\n    /// @param _hook The FeeHook being executed\\n    /// @param _settlementData Encoded args to use in calculating the settlement\\n    /// @param _gav The GAV of the fund\\n    function update(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IFeeManager.FeeHook _hook,\\n        bytes calldata _settlementData,\\n        uint256 _gav\\n    ) external override onlyFeeManager {\\n        uint256 prevSharePrice = comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice;\\n        uint256 nextSharePrice = __calcNextSharePrice(\\n            _comptrollerProxy,\\n            _vaultProxy,\\n            _hook,\\n            _settlementData,\\n            _gav\\n        );\\n\\n        if (nextSharePrice == prevSharePrice) {\\n            return;\\n        }\\n\\n        comptrollerProxyToFeeInfo[_comptrollerProxy].lastSharePrice = nextSharePrice;\\n\\n        emit LastSharePriceUpdated(_comptrollerProxy, prevSharePrice, nextSharePrice);\\n    }\\n\\n    /// @notice Gets whether the fee updates and requires GAV on a particular hook\\n    /// @param _hook The FeeHook\\n    /// @return updates_ True if the fee updates on the _hook\\n    /// @return usesGav_ True if the fee uses GAV during update() for the _hook\\n    function updatesOnHook(IFeeManager.FeeHook _hook)\\n        external\\n        view\\n        override\\n        returns (bool updates_, bool usesGav_)\\n    {\\n        if (\\n            _hook == IFeeManager.FeeHook.PostBuyShares ||\\n            _hook == IFeeManager.FeeHook.PreRedeemShares ||\\n            _hook == IFeeManager.FeeHook.Continuous\\n        ) {\\n            return (true, true);\\n        }\\n\\n        return (false, false);\\n    }\\n\\n    // PUBLIC FUNCTIONS\\n\\n    /// @notice Gets the recipient of the fee for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\\n    /// @return recipient_ The recipient\\n    function getRecipientForFund(address _comptrollerProxy)\\n        public\\n        view\\n        override(FeeBase, SettableFeeRecipientBase)\\n        returns (address recipient_)\\n    {\\n        return SettableFeeRecipientBase.getRecipientForFund(_comptrollerProxy);\\n    }\\n\\n    /// @notice Checks whether the shares outstanding can be paid out\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return payoutAllowed_ True if the fee payment is due\\n    /// @dev Payout is allowed if fees have not yet been settled in a crystallization period,\\n    /// and at least 1 crystallization period has passed since activation\\n    function payoutAllowed(address _comptrollerProxy) public view returns (bool payoutAllowed_) {\\n        FeeInfo memory feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\\n        uint256 period = feeInfo.period;\\n\\n        uint256 timeSinceActivated = block.timestamp.sub(feeInfo.activated);\\n\\n        // Check if at least 1 crystallization period has passed since activation\\n        if (timeSinceActivated < period) {\\n            return false;\\n        }\\n\\n        // Check that a full crystallization period has passed since the last payout\\n        uint256 timeSincePeriodStart = timeSinceActivated % period;\\n        uint256 periodStart = block.timestamp.sub(timeSincePeriodStart);\\n        return feeInfo.lastPaid < periodStart;\\n    }\\n\\n    // PRIVATE FUNCTIONS\\n\\n    /// @dev Helper to calculate the aggregated value accumulated to a fund since the last\\n    /// settlement (happening at investment/redemption)\\n    /// Validated:\\n    /// _netSharesSupply > 0\\n    /// _sharePriceWithoutPerformance != _prevSharePrice\\n    function __calcAggregateValueDue(\\n        uint256 _netSharesSupply,\\n        uint256 _sharePriceWithoutPerformance,\\n        uint256 _prevSharePrice,\\n        uint256 _prevAggregateValueDue,\\n        uint256 _feeRate,\\n        uint256 _highWaterMark\\n    ) private pure returns (uint256) {\\n        int256 superHWMValueSinceLastSettled = (\\n            int256(__calcUint256Max(_highWaterMark, _sharePriceWithoutPerformance)).sub(\\n                int256(__calcUint256Max(_highWaterMark, _prevSharePrice))\\n            )\\n        )\\n            .mul(int256(_netSharesSupply))\\n            .div(int256(SHARE_UNIT));\\n\\n        int256 valueDueSinceLastSettled = superHWMValueSinceLastSettled.mul(int256(_feeRate)).div(\\n            int256(ONE_HUNDRED_PERCENT)\\n        );\\n\\n        return\\n            uint256(\\n                __calcInt256Max(0, int256(_prevAggregateValueDue).add(valueDueSinceLastSettled))\\n            );\\n    }\\n\\n    /// @dev Helper to calculate the max of two int values\\n    function __calcInt256Max(int256 _a, int256 _b) private pure returns (int256) {\\n        if (_a >= _b) {\\n            return _a;\\n        }\\n\\n        return _b;\\n    }\\n\\n    /// @dev Helper to calculate the next `lastSharePrice` value\\n    function __calcNextSharePrice(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        IFeeManager.FeeHook _hook,\\n        bytes memory _settlementData,\\n        uint256 _gav\\n    ) private view returns (uint256 nextSharePrice_) {\\n        uint256 denominationAssetUnit = 10 **\\n            uint256(ERC20(ComptrollerLib(_comptrollerProxy).getDenominationAsset()).decimals());\\n        if (_gav == 0) {\\n            return denominationAssetUnit;\\n        }\\n\\n        // Get shares outstanding via VaultProxy balance and calc shares supply to get net shares supply\\n        ERC20 vaultProxyContract = ERC20(_vaultProxy);\\n        uint256 totalSharesSupply = vaultProxyContract.totalSupply();\\n        uint256 nextNetSharesSupply = totalSharesSupply.sub(\\n            vaultProxyContract.balanceOf(_vaultProxy)\\n        );\\n        if (nextNetSharesSupply == 0) {\\n            return denominationAssetUnit;\\n        }\\n\\n        uint256 nextGav = _gav;\\n\\n        // For both Continuous and BuySharesCompleted hooks, _gav and shares supply will not change,\\n        // we only need additional calculations for PreRedeemShares\\n        if (_hook == IFeeManager.FeeHook.PreRedeemShares) {\\n            (, uint256 sharesDecrease, ) = __decodePreRedeemSharesSettlementData(_settlementData);\\n\\n            // Shares have not yet been burned\\n            nextNetSharesSupply = nextNetSharesSupply.sub(sharesDecrease);\\n            if (nextNetSharesSupply == 0) {\\n                return denominationAssetUnit;\\n            }\\n\\n            // Assets have not yet been withdrawn\\n            uint256 gavDecrease = _gav.mul(sharesDecrease).div(totalSharesSupply);\\n\\n            nextGav = nextGav.sub(gavDecrease);\\n            if (nextGav == 0) {\\n                return denominationAssetUnit;\\n            }\\n        }\\n\\n        return nextGav.mul(SHARE_UNIT).div(nextNetSharesSupply);\\n    }\\n\\n    /// @dev Helper to calculate the performance metrics for a fund.\\n    /// Validated:\\n    /// _totalSharesSupply > 0\\n    /// _gav > 0\\n    /// _totalSharesSupply != _totalSharesOutstanding\\n    function __calcPerformance(\\n        address _comptrollerProxy,\\n        uint256 _totalSharesSupply,\\n        uint256 _totalSharesOutstanding,\\n        uint256 _prevAggregateValueDue,\\n        FeeInfo memory feeInfo,\\n        uint256 _gav\\n    ) private view returns (uint256 nextAggregateValueDue_, int256 sharesDue_) {\\n        // Use the 'shares supply net shares outstanding' for performance calcs.\\n        // Cannot be 0, as _totalSharesSupply != _totalSharesOutstanding\\n        uint256 netSharesSupply = _totalSharesSupply.sub(_totalSharesOutstanding);\\n        uint256 sharePriceWithoutPerformance = _gav.mul(SHARE_UNIT).div(netSharesSupply);\\n\\n        // If gross share price has not changed, can exit early\\n        uint256 prevSharePrice = feeInfo.lastSharePrice;\\n        if (sharePriceWithoutPerformance == prevSharePrice) {\\n            return (_prevAggregateValueDue, 0);\\n        }\\n\\n        nextAggregateValueDue_ = __calcAggregateValueDue(\\n            netSharesSupply,\\n            sharePriceWithoutPerformance,\\n            prevSharePrice,\\n            _prevAggregateValueDue,\\n            feeInfo.rate,\\n            feeInfo.highWaterMark\\n        );\\n\\n        sharesDue_ = __calcSharesDue(\\n            _comptrollerProxy,\\n            netSharesSupply,\\n            _gav,\\n            nextAggregateValueDue_\\n        );\\n\\n        return (nextAggregateValueDue_, sharesDue_);\\n    }\\n\\n    /// @dev Helper to calculate sharesDue during settlement.\\n    /// Validated:\\n    /// _netSharesSupply > 0\\n    /// _gav > 0\\n    function __calcSharesDue(\\n        address _comptrollerProxy,\\n        uint256 _netSharesSupply,\\n        uint256 _gav,\\n        uint256 _nextAggregateValueDue\\n    ) private view returns (int256 sharesDue_) {\\n        // _nextAggregateValueDue should never be greater than _gav, as the max fee rate is 100%\\n        uint256 sharesDueForAggregateValueDue = _nextAggregateValueDue.mul(_netSharesSupply).div(\\n            _gav.sub(_nextAggregateValueDue)\\n        );\\n\\n        // Shares due is the +/- diff or the total shares outstanding already minted\\n        return\\n            int256(sharesDueForAggregateValueDue).sub(\\n                int256(\\n                    FeeManager(FEE_MANAGER).getFeeSharesOutstandingForFund(\\n                        _comptrollerProxy,\\n                        address(this)\\n                    )\\n                )\\n            );\\n    }\\n\\n    /// @dev Helper to calculate the max of two uint values\\n    function __calcUint256Max(uint256 _a, uint256 _b) private pure returns (uint256) {\\n        if (_a >= _b) {\\n            return _a;\\n        }\\n\\n        return _b;\\n    }\\n\\n    /// @dev Helper to settle the fee and update performance state.\\n    /// Validated:\\n    /// _gav > 0\\n    function __settleAndUpdatePerformance(\\n        address _comptrollerProxy,\\n        address _vaultProxy,\\n        uint256 _gav\\n    ) private returns (int256 sharesDue_) {\\n        ERC20 sharesTokenContract = ERC20(_vaultProxy);\\n\\n        uint256 totalSharesSupply = sharesTokenContract.totalSupply();\\n        if (totalSharesSupply == 0) {\\n            return 0;\\n        }\\n\\n        uint256 totalSharesOutstanding = sharesTokenContract.balanceOf(_vaultProxy);\\n        if (totalSharesOutstanding == totalSharesSupply) {\\n            return 0;\\n        }\\n\\n        FeeInfo storage feeInfo = comptrollerProxyToFeeInfo[_comptrollerProxy];\\n        uint256 prevAggregateValueDue = feeInfo.aggregateValueDue;\\n\\n        uint256 nextAggregateValueDue;\\n        (nextAggregateValueDue, sharesDue_) = __calcPerformance(\\n            _comptrollerProxy,\\n            totalSharesSupply,\\n            totalSharesOutstanding,\\n            prevAggregateValueDue,\\n            feeInfo,\\n            _gav\\n        );\\n        if (nextAggregateValueDue == prevAggregateValueDue) {\\n            return 0;\\n        }\\n\\n        // Update fee state\\n        feeInfo.aggregateValueDue = nextAggregateValueDue;\\n\\n        emit PerformanceUpdated(\\n            _comptrollerProxy,\\n            prevAggregateValueDue,\\n            nextAggregateValueDue,\\n            sharesDue_\\n        );\\n\\n        return sharesDue_;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the feeInfo for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy contract of the fund\\n    /// @return feeInfo_ The feeInfo\\n    function getFeeInfoForFund(address _comptrollerProxy)\\n        external\\n        view\\n        returns (FeeInfo memory feeInfo_)\\n    {\\n        return comptrollerProxyToFeeInfo[_comptrollerProxy];\\n    }\\n}\\n\",\"keccak256\":\"0x820278788aabf2179c25e6f9180f9793c8d08184f8828dd3d13e11a63c82b1d1\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/fees/utils/FeeBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../IFee.sol\\\";\\n\\n/// @title FeeBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Abstract base contract for all fees\\nabstract contract FeeBase is IFee {\\n    address internal immutable FEE_MANAGER;\\n\\n    modifier onlyFeeManager {\\n        require(msg.sender == FEE_MANAGER, \\\"Only the FeeManger can make this call\\\");\\n        _;\\n    }\\n\\n    constructor(address _feeManager) public {\\n        FEE_MANAGER = _feeManager;\\n    }\\n\\n    /// @notice Allows Fee to run logic during fund activation\\n    /// @dev Unimplemented by default, may be overrode.\\n    function activateForFund(address, address) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Gets the recipient of the fee for a given fund\\n    /// @dev address(0) signifies the VaultProxy owner.\\n    /// Returns address(0) by default, can be overridden by fee.\\n    function getRecipientForFund(address)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (address recipient_)\\n    {\\n        return address(0);\\n    }\\n\\n    /// @notice Runs payout logic for a fee that utilizes shares outstanding as its settlement type\\n    /// @dev Returns false by default, can be overridden by fee\\n    function payout(address, address) external virtual override returns (bool) {\\n        return false;\\n    }\\n\\n    /// @notice Update fee state after all settlement has occurred during a given fee hook\\n    /// @dev Unimplemented by default, can be overridden by fee\\n    function update(\\n        address,\\n        address,\\n        IFeeManager.FeeHook,\\n        bytes calldata,\\n        uint256\\n    ) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Gets whether the fee updates and requires GAV on a particular hook\\n    /// @return updates_ True if the fee updates on the _hook\\n    /// @return usesGav_ True if the fee uses GAV during update() for the _hook\\n    /// @dev Returns false values by default, can be overridden by fee\\n    function updatesOnHook(IFeeManager.FeeHook)\\n        external\\n        view\\n        virtual\\n        override\\n        returns (bool updates_, bool usesGav_)\\n    {\\n        return (false, false);\\n    }\\n\\n    /// @notice Helper to parse settlement arguments from encoded data for PreBuyShares fee hook\\n    function __decodePreBuySharesSettlementData(bytes memory _settlementData)\\n        internal\\n        pure\\n        returns (address buyer_, uint256 investmentAmount_)\\n    {\\n        return abi.decode(_settlementData, (address, uint256));\\n    }\\n\\n    /// @notice Helper to parse settlement arguments from encoded data for PreRedeemShares fee hook\\n    function __decodePreRedeemSharesSettlementData(bytes memory _settlementData)\\n        internal\\n        pure\\n        returns (\\n            address redeemer_,\\n            uint256 sharesQuantity_,\\n            bool forSpecificAssets_\\n        )\\n    {\\n        return abi.decode(_settlementData, (address, uint256, bool));\\n    }\\n\\n    /// @notice Helper to parse settlement arguments from encoded data for PostBuyShares fee hook\\n    function __decodePostBuySharesSettlementData(bytes memory _settlementData)\\n        internal\\n        pure\\n        returns (\\n            address buyer_,\\n            uint256 investmentAmount_,\\n            uint256 sharesIssued_\\n        )\\n    {\\n        return abi.decode(_settlementData, (address, uint256, uint256));\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `FEE_MANAGER` variable\\n    /// @return feeManager_ The `FEE_MANAGER` variable value\\n    function getFeeManager() external view returns (address feeManager_) {\\n        return FEE_MANAGER;\\n    }\\n}\\n\",\"keccak256\":\"0x73bd381de7da4bd7e8bdb9adac4bdf5be2af13b758f16c5d64c709b158b1927a\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/fees/utils/SettableFeeRecipientBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title SettableFeeRecipientBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A base contract to set and get a fee recipient for the inheriting fee\\nabstract contract SettableFeeRecipientBase {\\n    event RecipientSetForFund(address indexed comptrollerProxy, address indexed recipient);\\n\\n    mapping(address => address) private comptrollerProxyToRecipient;\\n\\n    /// @dev Helper to set a fee recipient\\n    function __setRecipientForFund(address _comptrollerProxy, address _recipient) internal {\\n        comptrollerProxyToRecipient[_comptrollerProxy] = _recipient;\\n\\n        emit RecipientSetForFund(_comptrollerProxy, _recipient);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the recipient of the fee for a given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\\n    /// @return recipient_ The recipient\\n    /// @dev address(0) signifies the VaultProxy owner\\n    function getRecipientForFund(address _comptrollerProxy)\\n        public\\n        view\\n        virtual\\n        returns (address recipient_)\\n    {\\n        return comptrollerProxyToRecipient[_comptrollerProxy];\\n    }\\n}\\n\",\"keccak256\":\"0xb3b4b3cd13141871c912310ce1dace2e94f89eee7a52b95d4df9e4642a958f4d\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/fee-manager/fees/utils/UpdatableFeeRecipientBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../../../core/fund/comptroller/ComptrollerLib.sol\\\";\\nimport \\\"../../../../core/fund/vault/VaultLib.sol\\\";\\nimport \\\"./SettableFeeRecipientBase.sol\\\";\\n\\n/// @title UpdatableFeeRecipientBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A base contract that provides an updatable fee recipient for the inheriting fee\\nabstract contract UpdatableFeeRecipientBase is SettableFeeRecipientBase {\\n    /// @notice Sets the fee recipient for the given fund\\n    /// @param _comptrollerProxy The ComptrollerProxy contract for the fund\\n    /// @param _recipient The fee recipient\\n    function setRecipientForFund(address _comptrollerProxy, address _recipient) external {\\n        require(\\n            msg.sender ==\\n                VaultLib(payable(ComptrollerLib(_comptrollerProxy).getVaultProxy())).getOwner(),\\n            \\\"__setRecipientForFund: Only vault owner callable\\\"\\n        );\\n\\n        __setRecipientForFund(_comptrollerProxy, _recipient);\\n    }\\n}\\n\",\"keccak256\":\"0xac875e8923b29be8e697be04177b56d3f75d0ef4a56bc0cec2d2583efd802064\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/policy-manager/IPolicyManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\n/// @title PolicyManager Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for the PolicyManager\\ninterface IPolicyManager {\\n    // When updating PolicyHook, also update these functions in PolicyManager:\\n    // 1. __getAllPolicyHooks()\\n    // 2. __policyHookRestrictsCurrentInvestorActions()\\n    enum PolicyHook {\\n        PostBuyShares,\\n        PostCallOnIntegration,\\n        PreTransferShares,\\n        RedeemSharesForSpecificAssets,\\n        AddTrackedAssets,\\n        RemoveTrackedAssets,\\n        CreateExternalPosition,\\n        PostCallOnExternalPosition,\\n        RemoveExternalPosition,\\n        ReactivateExternalPosition\\n    }\\n\\n    function validatePolicies(\\n        address,\\n        PolicyHook,\\n        bytes calldata\\n    ) external;\\n}\\n\",\"keccak256\":\"0x1ed5fff925cdfa8808a65aa4c1e45813d87c1f462fc6740be670065ed2f6fd32\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/utils/ExtensionBase.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../utils/FundDeployerOwnerMixin.sol\\\";\\nimport \\\"../IExtension.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title ExtensionBase Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Base class for an extension\\nabstract contract ExtensionBase is IExtension, FundDeployerOwnerMixin {\\n    event ValidatedVaultProxySetForFund(\\n        address indexed comptrollerProxy,\\n        address indexed vaultProxy\\n    );\\n\\n    mapping(address => address) internal comptrollerProxyToVaultProxy;\\n\\n    modifier onlyFundDeployer() {\\n        console.log(\\\"ExtensionBase:onlyFundDeployer:msg.sender: %s\\\", msg.sender);\\n        require(msg.sender == getFundDeployer(), \\\"Only the FundDeployer can make this call\\\");\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public FundDeployerOwnerMixin(_fundDeployer) {}\\n\\n    /// @notice Allows extension to run logic during fund activation\\n    /// @dev Unimplemented by default, may be overridden.\\n    function activateForFund(bool) external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Allows extension to run logic during fund deactivation (destruct)\\n    /// @dev Unimplemented by default, may be overridden.\\n    function deactivateForFund() external virtual override {\\n        return;\\n    }\\n\\n    /// @notice Receives calls from ComptrollerLib.callOnExtension()\\n    /// and dispatches the appropriate action\\n    /// @dev Unimplemented by default, may be overridden.\\n    function receiveCallFromComptroller(\\n        address,\\n        uint256,\\n        bytes calldata\\n    ) external virtual override {\\n        revert(\\\"receiveCallFromComptroller: Unimplemented for Extension\\\");\\n    }\\n\\n    /// @notice Allows extension to run logic during fund configuration\\n    /// @dev Unimplemented by default, may be overridden.\\n    function setConfigForFund(\\n        address,\\n        address,\\n        bytes calldata\\n    ) external virtual override {\\n        return;\\n    }\\n\\n    /// @dev Helper to store the validated ComptrollerProxy-VaultProxy relation\\n    function __setValidatedVaultProxy(address _comptrollerProxy, address _vaultProxy) internal {\\n        comptrollerProxyToVaultProxy[_comptrollerProxy] = _vaultProxy;\\n\\n        emit ValidatedVaultProxySetForFund(_comptrollerProxy, _vaultProxy);\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the verified VaultProxy for a given ComptrollerProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @return vaultProxy_ The VaultProxy of the fund\\n    function getVaultProxyForFund(address _comptrollerProxy)\\n        public\\n        view\\n        returns (address vaultProxy_)\\n    {\\n        return comptrollerProxyToVaultProxy[_comptrollerProxy];\\n    }\\n}\\n\",\"keccak256\":\"0xfa5be0de484120542267f255b148bdbd0ef5490073d23388d67a567c50cf616c\",\"license\":\"GPL-3.0\"},\"contracts/release/extensions/utils/PermissionedVaultActionMixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../../core/fund/comptroller/IComptroller.sol\\\";\\nimport \\\"../../core/fund/vault/IVault.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title PermissionedVaultActionMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract for extensions that can make permissioned vault calls\\nabstract contract PermissionedVaultActionMixin {\\n    /// @notice Adds an external position to active external positions\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _externalPosition The external position to be added\\n    function __addExternalPosition(address _comptrollerProxy, address _externalPosition) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.AddExternalPosition,\\n            abi.encode(_externalPosition)\\n        );\\n    }\\n\\n    /// @notice Adds a tracked asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to add\\n    function __addTrackedAsset(address _comptrollerProxy, address _asset) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.AddTrackedAsset,\\n            abi.encode(_asset)\\n        );\\n    }\\n\\n    /// @notice Grants an allowance to a spender to use a fund's asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset for which to grant an allowance\\n    /// @param _target The spender of the allowance\\n    /// @param _amount The amount of the allowance\\n    function __approveAssetSpender(\\n        address _comptrollerProxy,\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.ApproveAssetSpender,\\n            abi.encode(_asset, _target, _amount)\\n        );\\n    }\\n\\n    /// @notice Burns fund shares for a particular account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _target The account for which to burn shares\\n    /// @param _amount The amount of shares to burn\\n    function __burnShares(\\n        address _comptrollerProxy,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.BurnShares,\\n            abi.encode(_target, _amount)\\n        );\\n    }\\n\\n    /// @notice Executes a callOnExternalPosition\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _data The encoded data for the call\\n    function __callOnExternalPosition(address _comptrollerProxy, bytes memory _data) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.CallOnExternalPosition,\\n            _data\\n        );\\n    }\\n\\n    /// @notice Mints fund shares to a particular account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _target The account to which to mint shares\\n    /// @param _amount The amount of shares to mint\\n    function __mintShares(\\n        address _comptrollerProxy,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.MintShares,\\n            abi.encode(_target, _amount)\\n        );\\n    }\\n\\n    /// @notice Removes an external position from the vaultProxy\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _externalPosition The ExternalPosition to remove\\n    function __removeExternalPosition(address _comptrollerProxy, address _externalPosition)\\n        internal\\n    {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.RemoveExternalPosition,\\n            abi.encode(_externalPosition)\\n        );\\n    }\\n\\n    /// @notice Removes a tracked asset\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to remove\\n    function __removeTrackedAsset(address _comptrollerProxy, address _asset) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.RemoveTrackedAsset,\\n            abi.encode(_asset)\\n        );\\n    }\\n\\n    /// @notice Transfers fund shares from one account to another\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _from The account from which to transfer shares\\n    /// @param _to The account to which to transfer shares\\n    /// @param _amount The amount of shares to transfer\\n    function __transferShares(\\n        address _comptrollerProxy,\\n        address _from,\\n        address _to,\\n        uint256 _amount\\n    ) internal {\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.TransferShares,\\n            abi.encode(_from, _to, _amount)\\n        );\\n    }\\n\\n    /// @notice Withdraws an asset from the VaultProxy to a given account\\n    /// @param _comptrollerProxy The ComptrollerProxy of the fund\\n    /// @param _asset The asset to withdraw\\n    /// @param _target The account to which to withdraw the asset\\n    /// @param _amount The amount of asset to withdraw\\n    function __withdrawAssetTo(\\n        address _comptrollerProxy,\\n        address _asset,\\n        address _target,\\n        uint256 _amount\\n    ) internal {\\n        console.log(\\\"__preProcessCoI:__withdrawAssetTo for _asset  %s\\\", _asset);\\n        console.log(\\\"__preProcessCoI:__withdrawAssetTo for _target  %s\\\", _target);\\n        console.log(\\\"__preProcessCoI:__withdrawAssetTo for _amount  %d\\\", _amount);\\n        console.log(\\n            \\\"__preProcessCoI:IVault.VaultAction.WithdrawAssetTo   %d\\\",\\n            uint256(IVault.VaultAction.WithdrawAssetTo)\\n        );\\n        IComptroller(_comptrollerProxy).permissionedVaultAction(\\n            IVault.VaultAction.WithdrawAssetTo,\\n            abi.encode(_asset, _target, _amount)\\n        );\\n        console.log(\\\"__preProcessCoI: after permissionedVaultAction   %d\\\", _amount);\\n    }\\n}\\n\",\"keccak256\":\"0x8f788c78779bdeb6c3d2069387da49536e6e7fa19fb44ebffc9abb8ff3d3c47e\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/asset-finality/IAssetFinalityResolver.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IAssetFinalityResolver Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IAssetFinalityResolver {\\n    function finalizeAssets(address, address[] calldata) external;\\n}\\n\",\"keccak256\":\"0x897894f9b2d6e9f85918ddd80ecb2bbaa07d8afac1cfead2fad37ac67dc1c6b4\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/gas-relayer/GasRelayRecipientMixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"../../utils/beacon-proxy/IBeaconProxyFactory.sol\\\";\\nimport \\\"./IGasRelayPaymaster.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title GasRelayRecipientMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin that enables receiving GSN-relayed calls\\n/// @dev IMPORTANT: Do not use storage var in this contract,\\n/// unless it is no longer inherited by the VaultLib\\nabstract contract GasRelayRecipientMixin {\\n    address internal immutable GAS_RELAY_PAYMASTER_FACTORY;\\n\\n    constructor(address _gasRelayPaymasterFactory) internal {\\n        GAS_RELAY_PAYMASTER_FACTORY = _gasRelayPaymasterFactory;\\n    }\\n\\n    /// @dev Helper to parse the canonical sender of a tx based on whether it has been relayed\\n    function __msgSender() internal view returns (address payable canonicalSender_) {\\n        if (msg.data.length >= 24 && msg.sender == getGasRelayTrustedForwarder()) {\\n            assembly {\\n                canonicalSender_ := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n\\n            return canonicalSender_;\\n        }\\n\\n        return msg.sender;\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `GAS_RELAY_PAYMASTER_FACTORY` variable\\n    /// @return gasRelayPaymasterFactory_ The `GAS_RELAY_PAYMASTER_FACTORY` variable value\\n    function getGasRelayPaymasterFactory()\\n        public\\n        view\\n        returns (address gasRelayPaymasterFactory_)\\n    {\\n        return GAS_RELAY_PAYMASTER_FACTORY;\\n    }\\n\\n    /// @notice Gets the trusted forwarder for GSN relaying\\n    /// @return trustedForwarder_ The trusted forwarder\\n    function getGasRelayTrustedForwarder() public view returns (address trustedForwarder_) {\\n        return\\n            IGasRelayPaymaster(\\n                IBeaconProxyFactory(getGasRelayPaymasterFactory()).getCanonicalLib()\\n            )\\n                .trustedForwarder();\\n    }\\n}\\n\",\"keccak256\":\"0xa5741fbd96f87cc20c961d8dfa43937f8a83dfdbdb93b542e789c89698ddd418\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/gas-relayer/IGasRelayPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"../../interfaces/IGsnPaymaster.sol\\\";\\n\\n/// @title IGasRelayPaymaster Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGasRelayPaymaster is IGsnPaymaster {\\n    function deposit() external;\\n\\n    function withdrawBalance() external;\\n}\\n\",\"keccak256\":\"0xb8b05029aca9eb89ff33c9cc3f97f6d096a5d8185a5ddcdec7cb1a92e4927b01\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/gas-relayer/IGasRelayPaymasterDepositor.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IGasRelayPaymasterDepositor Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGasRelayPaymasterDepositor {\\n    function pullWethForGasRelayer(uint256) external;\\n}\\n\",\"keccak256\":\"0xcbfbcc963988ba5ca56e5e54ea8fc7fcdf4a3fd903a73b139d9bef63c18ef196\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/protocol-fees/IProtocolFeeTracker.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IProtocolFeeTracker Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IProtocolFeeTracker {\\n    function initializeForVault(address) external;\\n\\n    function payFee() external returns (uint256);\\n}\\n\",\"keccak256\":\"0x232b347f83457439064add7369bfe1930c7cb56f15930bb87d640e909c15e447\",\"license\":\"GPL-3.0\"},\"contracts/release/infrastructure/value-interpreter/IValueInterpreter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IValueInterpreter interface\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice Interface for ValueInterpreter\\ninterface IValueInterpreter {\\n    function calcCanonicalAssetValue(\\n        address,\\n        uint256,\\n        address\\n    ) external returns (uint256);\\n\\n    function calcCanonicalAssetsTotalValue(\\n        address[] calldata,\\n        uint256[] calldata,\\n        address\\n    ) external returns (uint256);\\n\\n    function isSupportedAsset(address) external view returns (bool);\\n\\n    function isSupportedDerivativeAsset(address) external view returns (bool);\\n\\n    function isSupportedPrimitiveAsset(address) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x6838a22b0357f3c5f437c1e54b8f63c7df42b41e3b25d56c5017eb75a857a794\",\"license\":\"GPL-3.0\"},\"contracts/release/interfaces/IGsnForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IGsnForwarder interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnForwarder {\\n    struct ForwardRequest {\\n        address from;\\n        address to;\\n        uint256 value;\\n        uint256 gas;\\n        uint256 nonce;\\n        bytes data;\\n        uint256 validUntil;\\n    }\\n}\\n\",\"keccak256\":\"0xdf725d6209efe494c5f56c1f3d2cc8c64f0785b4b62fa9869bee3d85d8d9e030\",\"license\":\"GPL-3.0\"},\"contracts/release/interfaces/IGsnPaymaster.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnTypes.sol\\\";\\n\\n/// @title IGsnPaymaster interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnPaymaster {\\n    struct GasAndDataLimits {\\n        uint256 acceptanceBudget;\\n        uint256 preRelayedCallGasLimit;\\n        uint256 postRelayedCallGasLimit;\\n        uint256 calldataSizeLimit;\\n    }\\n\\n    function getGasAndDataLimits() external view returns (GasAndDataLimits memory limits);\\n\\n    function getHubAddr() external view returns (address);\\n\\n    function getRelayHubDeposit() external view returns (uint256);\\n\\n    function preRelayedCall(\\n        IGsnTypes.RelayRequest calldata relayRequest,\\n        bytes calldata signature,\\n        bytes calldata approvalData,\\n        uint256 maxPossibleGas\\n    ) external returns (bytes memory context, bool rejectOnRecipientRevert);\\n\\n    function postRelayedCall(\\n        bytes calldata context,\\n        bool success,\\n        uint256 gasUseWithoutPost,\\n        IGsnTypes.RelayData calldata relayData\\n    ) external;\\n\\n    function trustedForwarder() external view returns (address);\\n\\n    function versionPaymaster() external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x2b6990c5f1721a994774d431c41563970e9400971df9ba0ff91ead265427272c\",\"license\":\"GPL-3.0\"},\"contracts/release/interfaces/IGsnTypes.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\npragma experimental ABIEncoderV2;\\n\\nimport \\\"./IGsnForwarder.sol\\\";\\n\\n/// @title IGsnTypes Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IGsnTypes {\\n    struct RelayData {\\n        uint256 gasPrice;\\n        uint256 pctRelayFee;\\n        uint256 baseRelayFee;\\n        address relayWorker;\\n        address paymaster;\\n        address forwarder;\\n        bytes paymasterData;\\n        uint256 clientId;\\n    }\\n\\n    struct RelayRequest {\\n        IGsnForwarder.ForwardRequest request;\\n        RelayData relayData;\\n    }\\n}\\n\",\"keccak256\":\"0xa5e951206789bd818be825058792b233858a9c58ca25d451b3691917a0ce3714\",\"license\":\"GPL-3.0\"},\"contracts/release/interfaces/IWETH.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title WETH Interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IWETH {\\n    function deposit() external payable;\\n\\n    function withdraw(uint256) external;\\n}\\n\",\"keccak256\":\"0x85b5e76c50599abed5b16555065e4809b25fd0e6f75a63cf72269c1545e96b96\",\"license\":\"GPL-3.0\"},\"contracts/release/utils/AddressArrayLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title AddressArray Library\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A library to extend the address array data type\\nlibrary AddressArrayLib {\\n    /////////////\\n    // STORAGE //\\n    /////////////\\n\\n    /// @dev Helper to remove an item from a storage array\\n    function removeStorageItem(address[] storage _self, address _itemToRemove)\\n        internal\\n        returns (bool removed_)\\n    {\\n        uint256 itemCount = _self.length;\\n        for (uint256 i; i < itemCount; i++) {\\n            if (_self[i] == _itemToRemove) {\\n                if (i < itemCount - 1) {\\n                    _self[i] = _self[itemCount - 1];\\n                }\\n                _self.pop();\\n                removed_ = true;\\n                break;\\n            }\\n        }\\n\\n        return removed_;\\n    }\\n\\n    ////////////\\n    // MEMORY //\\n    ////////////\\n\\n    /// @dev Helper to add an item to an array. Does not assert uniqueness of the new item.\\n    function addItem(address[] memory _self, address _itemToAdd)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        nextArray_ = new address[](_self.length + 1);\\n        for (uint256 i; i < _self.length; i++) {\\n            nextArray_[i] = _self[i];\\n        }\\n        nextArray_[_self.length] = _itemToAdd;\\n\\n        return nextArray_;\\n    }\\n\\n    /// @dev Helper to add an item to an array, only if it is not already in the array.\\n    function addUniqueItem(address[] memory _self, address _itemToAdd)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        if (contains(_self, _itemToAdd)) {\\n            return _self;\\n        }\\n\\n        return addItem(_self, _itemToAdd);\\n    }\\n\\n    /// @dev Helper to verify if an array contains a particular value\\n    function contains(address[] memory _self, address _target)\\n        internal\\n        pure\\n        returns (bool doesContain_)\\n    {\\n        for (uint256 i; i < _self.length; i++) {\\n            if (_target == _self[i]) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n\\n    /// @dev Helper to merge the unique items of a second array.\\n    /// Does not consider uniqueness of either array, only relative uniqueness.\\n    /// Preserves ordering.\\n    function mergeArray(address[] memory _self, address[] memory _arrayToMerge)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        uint256 newUniqueItemCount;\\n        for (uint256 i; i < _arrayToMerge.length; i++) {\\n            if (!contains(_self, _arrayToMerge[i])) {\\n                newUniqueItemCount++;\\n            }\\n        }\\n\\n        if (newUniqueItemCount == 0) {\\n            return _self;\\n        }\\n\\n        nextArray_ = new address[](_self.length + newUniqueItemCount);\\n        for (uint256 i; i < _self.length; i++) {\\n            nextArray_[i] = _self[i];\\n        }\\n        uint256 nextArrayIndex = _self.length;\\n        for (uint256 i; i < _arrayToMerge.length; i++) {\\n            if (!contains(_self, _arrayToMerge[i])) {\\n                nextArray_[nextArrayIndex] = _arrayToMerge[i];\\n                nextArrayIndex++;\\n            }\\n        }\\n\\n        return nextArray_;\\n    }\\n\\n    /// @dev Helper to verify if array is a set of unique values.\\n    /// Does not assert length > 0.\\n    function isUniqueSet(address[] memory _self) internal pure returns (bool isUnique_) {\\n        if (_self.length <= 1) {\\n            return true;\\n        }\\n\\n        uint256 arrayLength = _self.length;\\n        for (uint256 i; i < arrayLength; i++) {\\n            for (uint256 j = i + 1; j < arrayLength; j++) {\\n                if (_self[i] == _self[j]) {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    /// @dev Helper to remove items from an array. Removes all matching occurrences of each item.\\n    /// Does not assert uniqueness of either array.\\n    function removeItems(address[] memory _self, address[] memory _itemsToRemove)\\n        internal\\n        pure\\n        returns (address[] memory nextArray_)\\n    {\\n        if (_itemsToRemove.length == 0) {\\n            return _self;\\n        }\\n\\n        bool[] memory indexesToRemove = new bool[](_self.length);\\n        uint256 remainingItemsCount = _self.length;\\n        for (uint256 i; i < _self.length; i++) {\\n            if (contains(_itemsToRemove, _self[i])) {\\n                indexesToRemove[i] = true;\\n                remainingItemsCount--;\\n            }\\n        }\\n\\n        if (remainingItemsCount == _self.length) {\\n            nextArray_ = _self;\\n        } else if (remainingItemsCount > 0) {\\n            nextArray_ = new address[](remainingItemsCount);\\n            uint256 nextArrayIndex;\\n            for (uint256 i; i < _self.length; i++) {\\n                if (!indexesToRemove[i]) {\\n                    nextArray_[nextArrayIndex] = _self[i];\\n                    nextArrayIndex++;\\n                }\\n            }\\n        }\\n\\n        return nextArray_;\\n    }\\n}\\n\",\"keccak256\":\"0x23809cb635aee1cd1aad36952627ce55739cf0bea3408819a0eddee2932936e7\",\"license\":\"GPL-3.0\"},\"contracts/release/utils/FundDeployerOwnerMixin.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"../core/fund-deployer/IFundDeployer.sol\\\";\\nimport \\\"hardhat/console.sol\\\";\\n\\n/// @title FundDeployerOwnerMixin Contract\\n/// @author Enzyme Council <security@enzyme.finance>\\n/// @notice A mixin contract that defers ownership to the owner of FundDeployer\\nabstract contract FundDeployerOwnerMixin {\\n    address internal immutable FUND_DEPLOYER;\\n\\n    modifier onlyFundDeployerOwner() {\\n        require(\\n            msg.sender == getOwner(),\\n            \\\"onlyFundDeployerOwner: Only the FundDeployer owner can call this function\\\"\\n        );\\n        _;\\n    }\\n\\n    constructor(address _fundDeployer) public {\\n        FUND_DEPLOYER = _fundDeployer;\\n    }\\n\\n    /// @notice Gets the owner of this contract\\n    /// @return owner_ The owner\\n    /// @dev Ownership is deferred to the owner of the FundDeployer contract\\n    function getOwner() public view returns (address owner_) {\\n        return IFundDeployer(FUND_DEPLOYER).getOwner();\\n    }\\n\\n    ///////////////////\\n    // STATE GETTERS //\\n    ///////////////////\\n\\n    /// @notice Gets the `FUND_DEPLOYER` variable\\n    /// @return fundDeployer_ The `FUND_DEPLOYER` variable value\\n    function getFundDeployer() public view returns (address fundDeployer_) {\\n        console.log(\\\"FundDeployerOwnerMixin:getFundDeployer:%s\\\", FUND_DEPLOYER);\\n        return FUND_DEPLOYER;\\n    }\\n}\\n\",\"keccak256\":\"0x1c5b05b4bcf81d2242ddfe965f793eae2b9b7115cfc48c164323552fc4bbca08\",\"license\":\"GPL-3.0\"},\"contracts/release/utils/beacon-proxy/IBeacon.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeacon interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeacon {\\n    function getCanonicalLib() external view returns (address);\\n}\\n\",\"keccak256\":\"0x27a585523828a67a1a7c84eadd22b3056e8ffc51ab71992fd97c9ffb4239eeb2\",\"license\":\"GPL-3.0\"},\"contracts/release/utils/beacon-proxy/IBeaconProxyFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0\\n\\n/*\\n    This file is part of the Enzyme Protocol.\\n\\n    (c) Enzyme Council <council@enzyme.finance>\\n\\n    For the full license information, please view the LICENSE\\n    file that was distributed with this source code.\\n*/\\n\\nimport \\\"./IBeacon.sol\\\";\\n\\npragma solidity 0.6.12;\\n\\n/// @title IBeaconProxyFactory interface\\n/// @author Enzyme Council <security@enzyme.finance>\\ninterface IBeaconProxyFactory is IBeacon {\\n    function deployProxy(bytes memory _constructData) external returns (address proxy_);\\n\\n    function setCanonicalLib(address _canonicalLib) external;\\n}\\n\",\"keccak256\":\"0x747e53725f5dbe419893ea447df4f33a3b25d99aae5b724aa1b9778cec1a26bc\",\"license\":\"GPL-3.0\"},\"hardhat/console.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >= 0.4.22 <0.9.0;\\n\\nlibrary console {\\n\\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\\n\\n\\tfunction _sendLogPayload(bytes memory payload) private view {\\n\\t\\tuint256 payloadLength = payload.length;\\n\\t\\taddress consoleAddress = CONSOLE_ADDRESS;\\n\\t\\tassembly {\\n\\t\\t\\tlet payloadStart := add(payload, 32)\\n\\t\\t\\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\\n\\t\\t}\\n\\t}\\n\\n\\tfunction log() internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log()\\\"));\\n\\t}\\n\\n\\tfunction logInt(int p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(int)\\\", p0));\\n\\t}\\n\\n\\tfunction logUint(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction logString(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction logBool(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction logAddress(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes(bytes memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes1(bytes1 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes1)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes2(bytes2 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes2)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes3(bytes3 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes3)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes4(bytes4 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes4)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes5(bytes5 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes5)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes6(bytes6 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes6)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes7(bytes7 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes7)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes8(bytes8 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes8)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes9(bytes9 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes9)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes10(bytes10 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes10)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes11(bytes11 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes11)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes12(bytes12 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes12)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes13(bytes13 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes13)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes14(bytes14 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes14)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes15(bytes15 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes15)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes16(bytes16 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes16)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes17(bytes17 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes17)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes18(bytes18 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes18)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes19(bytes19 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes19)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes20(bytes20 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes20)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes21(bytes21 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes21)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes22(bytes22 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes22)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes23(bytes23 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes23)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes24(bytes24 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes24)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes25(bytes25 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes25)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes26(bytes26 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes26)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes27(bytes27 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes27)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes28(bytes28 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes28)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes29(bytes29 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes29)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes30(bytes30 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes30)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes31(bytes31 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes31)\\\", p0));\\n\\t}\\n\\n\\tfunction logBytes32(bytes32 p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bytes32)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint)\\\", p0));\\n\\t}\\n\\n\\tfunction log(string memory p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string)\\\", p0));\\n\\t}\\n\\n\\tfunction log(bool p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool)\\\", p0));\\n\\t}\\n\\n\\tfunction log(address p0) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address)\\\", p0));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(address p0, address p1) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address)\\\", p0, p1));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address)\\\", p0, p1, p2));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(uint p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(uint,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(string,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(bool p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(bool,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, uint p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,uint,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,string,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, bool p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,bool,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, uint p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,uint,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,string,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, bool p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,bool,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, uint p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,uint)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,string)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, bool p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,bool)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n\\tfunction log(address p0, address p1, address p2, address p3) internal view {\\n\\t\\t_sendLogPayload(abi.encodeWithSignature(\\\"log(address,address,address,address)\\\", p0, p1, p2, p3));\\n\\t}\\n\\n}\\n\",\"keccak256\":\"0x72b6a1d297cd3b033d7c2e4a7e7864934bb767db6453623f1c3082c6534547f4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b50604051620024c4380380620024c483398101604081905262000034916200005d565b60601b6001600160601b031916608052620000b2565b8051620000578162000098565b92915050565b6000602082840312156200007057600080fd5b60006200007e84846200004a565b949350505050565b60006001600160a01b03821662000057565b620000a38162000086565b8114620000af57600080fd5b50565b60805160601c6123d6620000ee600039806102d0528061068b52806107a8528061095a5280610bc85280610cf2528061158352506123d66000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c806362780b3c1161007157806362780b3c14610160578063877fd473146101805780638c55f80f146101a0578063b78b4813146101b3578063e337a91f146101c6578063f2d63826146101d9576100b4565b806305be5783146100b95780630f5f6b4f146100e2578063233faf5f146100f75780633146d0581461010a578063320f0ddd1461011d57806341892d7e1461013e575b600080fd5b6100cc6100c7366004611884565b6101e1565b6040516100d99190611f87565b60405180910390f35b6100f56100f03660046119d6565b6102c5565b005b6100f5610105366004611947565b610680565b6100f561011836600461190d565b61079d565b61013061012b366004611a2b565b6108f0565b6040516100d9929190611f95565b61015161014c366004611947565b61094b565b6040516100d993929190611fc1565b61017361016e366004611884565b610a00565b6040516100d99190611f5e565b61019361018e366004611884565b610a11565b6040516100d991906120f9565b6100f56101ae36600461190d565b610a9c565b6100cc6101c136600461190d565b610bbb565b6101306101d4366004611a2b565b610ce6565b610173610cf0565b60006101eb61179d565b506001600160a01b0382166000908152600160208181526040808420815160e081018352815461ffff811682526001600160401b036201000082048116958301869052600160501b82048116948301859052600160901b909104166060820152938101546080850152600281015460a08501526003015460c084015291929091610276904290610d14565b90508181101561028c57600093505050506102c0565b600082828161029757fe5b06905060006102a64283610d14565b90508085606001516001600160401b031610955050505050505b919050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146103165760405162461bcd60e51b815260040161030d90612079565b60405180910390fd5b61033760405180606001604052806023815260200161234160239139610d3c565b61037682828080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610d8292505050565b6000808061038684860186611a49565b9250925092506103b2604051806060016040528060288152602001612265602891398461ffff16610dc5565b6103dd6040518060600160405280602a81526020016122c2602a9139836001600160401b0316610dc5565b6103ff6040518060600160405280602a81526020016122ec602a913982610e0a565b60008361ffff16116104235760405162461bcd60e51b815260040161030d906120a9565b6127108361ffff1611156104495760405162461bcd60e51b815260040161030d90612029565b6000826001600160401b0316116104725760405162461bcd60e51b815260040161030d90612039565b6104936040518060600160405280602b8152602001612316602b9139610d3c565b6040518060e001604052808461ffff168152602001836001600160401b0316815260200160006001600160401b0316815260200160006001600160401b031681526020016000815260200160008152602001600081525060016000886001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548161ffff021916908361ffff16021790555060208201518160000160026101000a8154816001600160401b0302191690836001600160401b03160217905550604082015181600001600a6101000a8154816001600160401b0302191690836001600160401b0316021790555060608201518160000160126101000a8154816001600160401b0302191690836001600160401b031602179055506080820151816001015560a0820151816002015560c082015181600301559050506105fb6040518060600160405280603d8152602001612364603d9139610d3c565b856001600160a01b03167f9f856f74192181b265e61298e386477299c53e0cb24be55a84416f2af4ba4a618484604051610636929190612107565b60405180910390a261065f60405180606001604052806035815260200161228d60359139610d3c565b6001600160a01b03811615610678576106788682610e4f565b505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106c85760405162461bcd60e51b815260040161030d90612079565b6001600160a01b0386166000908152600160209081526040808320600201548151601f8701849004840281018401909252858252929161072a918a918a918a918a908a90819084018382808284376000920191909152508a9250610ea6915050565b90508181141561073b575050610678565b6001600160a01b03881660008181526001602052604090819020600201839055517f040fdaa9ed9dd9e4588f1f96145d5517471e7b518fb5d56d8504eb839f50b6539061078b9085908590612130565b60405180910390a25050505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146107e55760405162461bcd60e51b815260040161030d90612079565b6001600160a01b0382166000818152600160205260408082209051635a0b830960e11b815290929063b417061290610821908490600401611f87565b602060405180830381600087803b15801561083b57600080fd5b505af115801561084f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108739190611a8c565b6001830181905560028301819055825467ffffffffffffffff60501b1916600160501b426001600160401b0316021783556040519091506001600160a01b038516907f67286096839b70891eb51e1532e51d6a709d69c808d1b7e24abcb24a39167d05906108e2908490612122565b60405180910390a250505050565b60008060015b83600381111561090257fe5b14806109195750600383600381111561091757fe5b145b8061092f5750600083600381111561092d57fe5b145b1561093f57506001905080610946565b5060009050805b915091565b60008080336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146109975760405162461bcd60e51b815260040161030d90612079565b836109aa575060009150819050806109f4565b60006109b78a8a87611159565b9050806109cf576000806000935093509350506109f4565b60008113156109e757600493506000925090506109f4565b6005935060009250820390505b96509650969350505050565b6000610a0b82611388565b92915050565b610a1961179d565b506001600160a01b0316600090815260016020818152604092839020835160e081018552815461ffff811682526001600160401b03620100008204811694830194909452600160501b8104841695820195909552600160901b9094049091166060840152908101546080830152600281015460a08301526003015460c082015290565b816001600160a01b031663c98091876040518163ffffffff1660e01b815260040160206040518083038186803b158015610ad557600080fd5b505afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d91906118a2565b6001600160a01b031663893d20e86040518163ffffffff1660e01b815260040160206040518083038186803b158015610b4557600080fd5b505afa158015610b59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b7d91906118a2565b6001600160a01b0316336001600160a01b031614610bad5760405162461bcd60e51b815260040161030d906120e9565b610bb78282610e4f565b5050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c055760405162461bcd60e51b815260040161030d90612079565b610c0e836101e1565b610c1a57506000610a0b565b6001600160a01b03831660009081526001602081905260408220805467ffffffffffffffff60901b1916600160901b426001600160401b03160217815590810154600282015491929091610c6e90836113a6565b60038401549091508015610c8457600060038501555b82821115610c9457600184018290555b866001600160a01b03167f807c2c73192f2d30961a7d01ec8dc57115a4cd9f9bd0434331beacb916c6a8cc848484604051610cd19392919061214b565b60405180910390a25060019695505050505050565b60008060026108f6565b7f000000000000000000000000000000000000000000000000000000000000000090565b600082821115610d365760405162461bcd60e51b815260040161030d90612059565b50900390565b610d7f81604051602401610d509190611fb0565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526113bc565b50565b610d7f81604051602401610d969190611fb0565b60408051601f198184030181529190526020810180516001600160e01b03166305f3bfab60e11b1790526113bc565b610bb78282604051602401610ddb929190612009565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526113bc565b610bb78282604051602401610e20929190611fe9565b60408051601f198184030181529190526020810180516001600160e01b031663319af33360e01b1790526113bc565b6001600160a01b0382811660008181526020819052604080822080546001600160a01b0319169486169485179055517fa11fc98cfb391622348acc16de92f0efb77d55f71a6e9fa18bfef387ae8d19ce9190a35050565b600080866001600160a01b031663e269c3d66040518163ffffffff1660e01b815260040160206040518083038186803b158015610ee257600080fd5b505afa158015610ef6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1a91906118a2565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610f5257600080fd5b505afa158015610f66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8a9190611aaa565b60ff16600a0a905082610f9e579050611150565b60008690506000816001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610fde57600080fd5b505afa158015610ff2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110169190611a8c565b905060006110a0836001600160a01b03166370a082318b6040518263ffffffff1660e01b81526004016110499190611f5e565b60206040518083038186803b15801561106157600080fd5b505afa158015611075573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110999190611a8c565b8390610d14565b9050806110b35783945050505050611150565b8560038960038111156110c257fe5b14156111325760006110d3896113dd565b5091506110e290508382610d14565b9250826110f757859650505050505050611150565b600061110d856111078b85611403565b9061143d565b90506111198382610d14565b92508261112f5786975050505050505050611150565b50505b6111488261110783670de0b6b3a7640000611403565b955050505050505b95945050505050565b6000808390506000816001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561119a57600080fd5b505afa1580156111ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d29190611a8c565b9050806111e457600092505050611381565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190611213908990600401611f5e565b60206040518083038186803b15801561122b57600080fd5b505afa15801561123f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112639190611a8c565b9050818114156112795760009350505050611381565b6001600160a01b03871660009081526001602081815260408084206003810154825160e081018452825461ffff811682526001600160401b03620100008204811696830196909652600160501b8104861694820194909452600160901b9093049093166060830152928301546080820152600283015460a082015260c0810182905291929091611311908b908790879086908d61146f565b975090508181141561132c5760009650505050505050611381565b808360030181905550896001600160a01b03167f74a80d6cce2a8c3a25bdba0cd5533d238d76eb996790fb2d4544372cc7f4e35683838a6040516113729392919061214b565b60405180910390a25050505050505b9392505050565b6001600160a01b039081166000908152602081905260409020541690565b60008183106113b6575081610a0b565b50919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b6000806000838060200190518101906113f691906118c0565b9250925092509193909250565b60008261141257506000610a0b565b8282028284828161141f57fe5b04146113815760405162461bcd60e51b815260040161030d90612099565b600080821161145e5760405162461bcd60e51b815260040161030d90612069565b81838161146757fe5b049392505050565b6000808061147d8888610d14565b905060006114978261110787670de0b6b3a7640000611403565b60a0870151909150808214156114b657876000945094505050506114e4565b6114d08383838b8b6000015161ffff168c608001516114ef565b94506114de8b848888611562565b93505050505b965096945050505050565b60008061152b670de0b6b3a76400006115258a61151f61150f888c6113a6565b611519898e6113a6565b90611632565b90611678565b906116e3565b9050600061153f6127106115258488611678565b905061155560006115508884611747565b61178d565b9998505050505050505050565b60008061157c6115728585610d14565b6111078588611403565b90506116267f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663aa051c2c88306040518363ffffffff1660e01b81526004016115cf929190611f6c565b60206040518083038186803b1580156115e757600080fd5b505afa1580156115fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161f9190611a8c565b8290611632565b9150505b949350505050565b60008183038183128015906116475750838113155b8061165c575060008312801561165c57508381135b6113815760405162461bcd60e51b815260040161030d906120c9565b60008261168757506000610a0b565b8260001914801561169b5750600160ff1b82145b156116b85760405162461bcd60e51b815260040161030d906120b9565b828202828482816116c557fe5b05146113815760405162461bcd60e51b815260040161030d906120b9565b6000816117025760405162461bcd60e51b815260040161030d906120d9565b816000191480156117165750600160ff1b83145b156117335760405162461bcd60e51b815260040161030d90612089565b600082848161173e57fe5b05949350505050565b600082820181831280159061175c5750838112155b80611771575060008312801561177157508381125b6113815760405162461bcd60e51b815260040161030d90612049565b60008183126113b6575081610a0b565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b8035610a0b81612216565b8051610a0b81612216565b8051610a0b8161222a565b60008083601f84011261180c57600080fd5b5081356001600160401b0381111561182357600080fd5b60208301915083600182028301111561183b57600080fd5b9250929050565b8035610a0b81612233565b8035610a0b81612240565b8035610a0b81612249565b8051610a0b81612249565b8035610a0b81612252565b8051610a0b8161225b565b60006020828403121561189657600080fd5b600061162a84846117d9565b6000602082840312156118b457600080fd5b600061162a84846117e4565b6000806000606084860312156118d557600080fd5b60006118e186866117e4565b93505060206118f286828701611863565b9250506040611903868287016117ef565b9150509250925092565b6000806040838503121561192057600080fd5b600061192c85856117d9565b925050602061193d858286016117d9565b9150509250929050565b60008060008060008060a0878903121561196057600080fd5b600061196c89896117d9565b965050602061197d89828a016117d9565b955050604061198e89828a01611842565b94505060608701356001600160401b038111156119aa57600080fd5b6119b689828a016117fa565b935093505060806119c989828a01611858565b9150509295509295509295565b6000806000604084860312156119eb57600080fd5b60006119f786866117d9565b93505060208401356001600160401b03811115611a1357600080fd5b611a1f868287016117fa565b92509250509250925092565b600060208284031215611a3d57600080fd5b600061162a8484611842565b600080600060608486031215611a5e57600080fd5b6000611a6a868661184d565b9350506020611a7b8682870161186e565b9250506040611903868287016117d9565b600060208284031215611a9e57600080fd5b600061162a8484611863565b600060208284031215611abc57600080fd5b600061162a8484611879565b611ad181612173565b82525050565b611ad18161217e565b6000611aeb82612166565b611af5818561216a565b9350611b058185602086016121d6565b611b0e81612202565b9093019392505050565b611ad1816121b5565b611ad18161218d565b6000611b3760258361216a565b7f61646446756e6453657474696e67733a2066656552617465206d617820657863815264195959195960da1b602082015260400192915050565b6000611b7e60318361216a565b7f61646446756e6453657474696e67733a20666565506572696f64206d75737420815270062652067726561746572207468616e203607c1b602082015260400192915050565b6000611bd160218361216a565b7f5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611c14601e8361216a565b7f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815260200192915050565b6000611c4d601a8361216a565b7f536166654d6174683a206469766973696f6e206279207a65726f000000000000815260200192915050565b6000611c8660258361216a565b7f4f6e6c7920746865204665654d616e6765722063616e206d616b6520746869738152640818d85b1b60da1b602082015260400192915050565b6000611ccd60218361216a565b7f5369676e6564536166654d6174683a206469766973696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611d1060218361216a565b7f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611d53602f8361216a565b7f61646446756e6453657474696e67733a2066656552617465206d75737420626581526e02067726561746572207468616e203608c1b602082015260400192915050565b6000611da460278361216a565b7f5369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f815266766572666c6f7760c81b602082015260400192915050565b6000611ded60248361216a565b7f5369676e6564536166654d6174683a207375627472616374696f6e206f766572815263666c6f7760e01b602082015260400192915050565b6000611e3360208361216a565b7f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f815260200192915050565b6000611e6c60308361216a565b7f5f5f736574526563697069656e74466f7246756e643a204f6e6c79207661756c81526f74206f776e65722063616c6c61626c6560801b602082015260400192915050565b805160e0830190611ec28482611f3a565b506020820151611ed56020850182611f55565b506040820151611ee86040850182611f55565b506060820151611efb6060850182611f55565b506080820151611f0e6080850182611b21565b5060a0820151611f2160a0850182611b21565b5060c0820151611f3460c0850182611b21565b50505050565b611ad181612190565b611ad1816121c0565b611ad1816121cb565b611ad1816121a3565b60208101610a0b8284611ac8565b60408101611f7a8285611ac8565b6113816020830184611ac8565b60208101610a0b8284611ad7565b60408101611fa38285611ad7565b6113816020830184611ad7565b602080825281016113818184611ae0565b60608101611fcf8286611b18565b611fdc6020830185611ac8565b61162a6040830184611b21565b60408082528101611ffa8185611ae0565b90506113816020830184611ac8565b6040808252810161201a8185611ae0565b90506113816020830184611b21565b60208082528101610a0b81611b2a565b60208082528101610a0b81611b71565b60208082528101610a0b81611bc4565b60208082528101610a0b81611c07565b60208082528101610a0b81611c40565b60208082528101610a0b81611c79565b60208082528101610a0b81611cc0565b60208082528101610a0b81611d03565b60208082528101610a0b81611d46565b60208082528101610a0b81611d97565b60208082528101610a0b81611de0565b60208082528101610a0b81611e26565b60208082528101610a0b81611e5f565b60e08101610a0b8284611eb1565b604081016121158285611f43565b6113816020830184611f4c565b60208101610a0b8284611b21565b6040810161213e8285611b21565b6113816020830184611b21565b606081016121598286611b21565b611fdc6020830185611b21565b5190565b90815260200190565b6000610a0b82612197565b151590565b806102c08161220c565b90565b61ffff1690565b6001600160a01b031690565b6001600160401b031690565b60ff1690565b6000610a0b82612183565b6000610a0b82612190565b6000610a0b826121a3565b60005b838110156121f15781810151838201526020016121d9565b83811115611f345750506000910152565b601f01601f191690565b60068110610d7f57fe5b61221f81612173565b8114610d7f57600080fd5b61221f8161217e565b60048110610d7f57600080fd5b61221f81612190565b61221f8161218d565b61221f816121a3565b61221f816121af56fe506572666f726d6163654665653a61646446756e6453657474696e67733a666565526174653a2564506572666f726d6163654665653a61646446756e6453657474696e67732061667465722046756e6453657474696e67734164646564506572666f726d6163654665653a61646446756e6453657474696e67733a666565506572696f643a2564506572666f726d6163654665653a61646446756e6453657474696e67733a726563697069656e743a2573506572666f726d6163654665653a61646446756e6453657474696e67732061667265207265717569726573506572666f726d6163654665653a61646446756e6453657474696e67733a626567696e506572666f726d6163654665653a61646446756e6453657474696e677320616674657220636f6d7074726f6c6c657250726f7879546f466565496e666fa2646970667358221220b54d9817090331458172caab21e8eb9283e63bf40cdda2b770ce8e2be36a698a64736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100b45760003560e01c806362780b3c1161007157806362780b3c14610160578063877fd473146101805780638c55f80f146101a0578063b78b4813146101b3578063e337a91f146101c6578063f2d63826146101d9576100b4565b806305be5783146100b95780630f5f6b4f146100e2578063233faf5f146100f75780633146d0581461010a578063320f0ddd1461011d57806341892d7e1461013e575b600080fd5b6100cc6100c7366004611884565b6101e1565b6040516100d99190611f87565b60405180910390f35b6100f56100f03660046119d6565b6102c5565b005b6100f5610105366004611947565b610680565b6100f561011836600461190d565b61079d565b61013061012b366004611a2b565b6108f0565b6040516100d9929190611f95565b61015161014c366004611947565b61094b565b6040516100d993929190611fc1565b61017361016e366004611884565b610a00565b6040516100d99190611f5e565b61019361018e366004611884565b610a11565b6040516100d991906120f9565b6100f56101ae36600461190d565b610a9c565b6100cc6101c136600461190d565b610bbb565b6101306101d4366004611a2b565b610ce6565b610173610cf0565b60006101eb61179d565b506001600160a01b0382166000908152600160208181526040808420815160e081018352815461ffff811682526001600160401b036201000082048116958301869052600160501b82048116948301859052600160901b909104166060820152938101546080850152600281015460a08501526003015460c084015291929091610276904290610d14565b90508181101561028c57600093505050506102c0565b600082828161029757fe5b06905060006102a64283610d14565b90508085606001516001600160401b031610955050505050505b919050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146103165760405162461bcd60e51b815260040161030d90612079565b60405180910390fd5b61033760405180606001604052806023815260200161234160239139610d3c565b61037682828080601f016020809104026020016040519081016040528093929190818152602001838380828437600092019190915250610d8292505050565b6000808061038684860186611a49565b9250925092506103b2604051806060016040528060288152602001612265602891398461ffff16610dc5565b6103dd6040518060600160405280602a81526020016122c2602a9139836001600160401b0316610dc5565b6103ff6040518060600160405280602a81526020016122ec602a913982610e0a565b60008361ffff16116104235760405162461bcd60e51b815260040161030d906120a9565b6127108361ffff1611156104495760405162461bcd60e51b815260040161030d90612029565b6000826001600160401b0316116104725760405162461bcd60e51b815260040161030d90612039565b6104936040518060600160405280602b8152602001612316602b9139610d3c565b6040518060e001604052808461ffff168152602001836001600160401b0316815260200160006001600160401b0316815260200160006001600160401b031681526020016000815260200160008152602001600081525060016000886001600160a01b03166001600160a01b0316815260200190815260200160002060008201518160000160006101000a81548161ffff021916908361ffff16021790555060208201518160000160026101000a8154816001600160401b0302191690836001600160401b03160217905550604082015181600001600a6101000a8154816001600160401b0302191690836001600160401b0316021790555060608201518160000160126101000a8154816001600160401b0302191690836001600160401b031602179055506080820151816001015560a0820151816002015560c082015181600301559050506105fb6040518060600160405280603d8152602001612364603d9139610d3c565b856001600160a01b03167f9f856f74192181b265e61298e386477299c53e0cb24be55a84416f2af4ba4a618484604051610636929190612107565b60405180910390a261065f60405180606001604052806035815260200161228d60359139610d3c565b6001600160a01b03811615610678576106788682610e4f565b505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146106c85760405162461bcd60e51b815260040161030d90612079565b6001600160a01b0386166000908152600160209081526040808320600201548151601f8701849004840281018401909252858252929161072a918a918a918a918a908a90819084018382808284376000920191909152508a9250610ea6915050565b90508181141561073b575050610678565b6001600160a01b03881660008181526001602052604090819020600201839055517f040fdaa9ed9dd9e4588f1f96145d5517471e7b518fb5d56d8504eb839f50b6539061078b9085908590612130565b60405180910390a25050505050505050565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146107e55760405162461bcd60e51b815260040161030d90612079565b6001600160a01b0382166000818152600160205260408082209051635a0b830960e11b815290929063b417061290610821908490600401611f87565b602060405180830381600087803b15801561083b57600080fd5b505af115801561084f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108739190611a8c565b6001830181905560028301819055825467ffffffffffffffff60501b1916600160501b426001600160401b0316021783556040519091506001600160a01b038516907f67286096839b70891eb51e1532e51d6a709d69c808d1b7e24abcb24a39167d05906108e2908490612122565b60405180910390a250505050565b60008060015b83600381111561090257fe5b14806109195750600383600381111561091757fe5b145b8061092f5750600083600381111561092d57fe5b145b1561093f57506001905080610946565b5060009050805b915091565b60008080336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146109975760405162461bcd60e51b815260040161030d90612079565b836109aa575060009150819050806109f4565b60006109b78a8a87611159565b9050806109cf576000806000935093509350506109f4565b60008113156109e757600493506000925090506109f4565b6005935060009250820390505b96509650969350505050565b6000610a0b82611388565b92915050565b610a1961179d565b506001600160a01b0316600090815260016020818152604092839020835160e081018552815461ffff811682526001600160401b03620100008204811694830194909452600160501b8104841695820195909552600160901b9094049091166060840152908101546080830152600281015460a08301526003015460c082015290565b816001600160a01b031663c98091876040518163ffffffff1660e01b815260040160206040518083038186803b158015610ad557600080fd5b505afa158015610ae9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b0d91906118a2565b6001600160a01b031663893d20e86040518163ffffffff1660e01b815260040160206040518083038186803b158015610b4557600080fd5b505afa158015610b59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b7d91906118a2565b6001600160a01b0316336001600160a01b031614610bad5760405162461bcd60e51b815260040161030d906120e9565b610bb78282610e4f565b5050565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c055760405162461bcd60e51b815260040161030d90612079565b610c0e836101e1565b610c1a57506000610a0b565b6001600160a01b03831660009081526001602081905260408220805467ffffffffffffffff60901b1916600160901b426001600160401b03160217815590810154600282015491929091610c6e90836113a6565b60038401549091508015610c8457600060038501555b82821115610c9457600184018290555b866001600160a01b03167f807c2c73192f2d30961a7d01ec8dc57115a4cd9f9bd0434331beacb916c6a8cc848484604051610cd19392919061214b565b60405180910390a25060019695505050505050565b60008060026108f6565b7f000000000000000000000000000000000000000000000000000000000000000090565b600082821115610d365760405162461bcd60e51b815260040161030d90612059565b50900390565b610d7f81604051602401610d509190611fb0565b60408051601f198184030181529190526020810180516001600160e01b031663104c13eb60e21b1790526113bc565b50565b610d7f81604051602401610d969190611fb0565b60408051601f198184030181529190526020810180516001600160e01b03166305f3bfab60e11b1790526113bc565b610bb78282604051602401610ddb929190612009565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526113bc565b610bb78282604051602401610e20929190611fe9565b60408051601f198184030181529190526020810180516001600160e01b031663319af33360e01b1790526113bc565b6001600160a01b0382811660008181526020819052604080822080546001600160a01b0319169486169485179055517fa11fc98cfb391622348acc16de92f0efb77d55f71a6e9fa18bfef387ae8d19ce9190a35050565b600080866001600160a01b031663e269c3d66040518163ffffffff1660e01b815260040160206040518083038186803b158015610ee257600080fd5b505afa158015610ef6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1a91906118a2565b6001600160a01b031663313ce5676040518163ffffffff1660e01b815260040160206040518083038186803b158015610f5257600080fd5b505afa158015610f66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f8a9190611aaa565b60ff16600a0a905082610f9e579050611150565b60008690506000816001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b158015610fde57600080fd5b505afa158015610ff2573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110169190611a8c565b905060006110a0836001600160a01b03166370a082318b6040518263ffffffff1660e01b81526004016110499190611f5e565b60206040518083038186803b15801561106157600080fd5b505afa158015611075573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110999190611a8c565b8390610d14565b9050806110b35783945050505050611150565b8560038960038111156110c257fe5b14156111325760006110d3896113dd565b5091506110e290508382610d14565b9250826110f757859650505050505050611150565b600061110d856111078b85611403565b9061143d565b90506111198382610d14565b92508261112f5786975050505050505050611150565b50505b6111488261110783670de0b6b3a7640000611403565b955050505050505b95945050505050565b6000808390506000816001600160a01b03166318160ddd6040518163ffffffff1660e01b815260040160206040518083038186803b15801561119a57600080fd5b505afa1580156111ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111d29190611a8c565b9050806111e457600092505050611381565b6040516370a0823160e01b81526000906001600160a01b038416906370a0823190611213908990600401611f5e565b60206040518083038186803b15801561122b57600080fd5b505afa15801561123f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112639190611a8c565b9050818114156112795760009350505050611381565b6001600160a01b03871660009081526001602081815260408084206003810154825160e081018452825461ffff811682526001600160401b03620100008204811696830196909652600160501b8104861694820194909452600160901b9093049093166060830152928301546080820152600283015460a082015260c0810182905291929091611311908b908790879086908d61146f565b975090508181141561132c5760009650505050505050611381565b808360030181905550896001600160a01b03167f74a80d6cce2a8c3a25bdba0cd5533d238d76eb996790fb2d4544372cc7f4e35683838a6040516113729392919061214b565b60405180910390a25050505050505b9392505050565b6001600160a01b039081166000908152602081905260409020541690565b60008183106113b6575081610a0b565b50919050565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b6000806000838060200190518101906113f691906118c0565b9250925092509193909250565b60008261141257506000610a0b565b8282028284828161141f57fe5b04146113815760405162461bcd60e51b815260040161030d90612099565b600080821161145e5760405162461bcd60e51b815260040161030d90612069565b81838161146757fe5b049392505050565b6000808061147d8888610d14565b905060006114978261110787670de0b6b3a7640000611403565b60a0870151909150808214156114b657876000945094505050506114e4565b6114d08383838b8b6000015161ffff168c608001516114ef565b94506114de8b848888611562565b93505050505b965096945050505050565b60008061152b670de0b6b3a76400006115258a61151f61150f888c6113a6565b611519898e6113a6565b90611632565b90611678565b906116e3565b9050600061153f6127106115258488611678565b905061155560006115508884611747565b61178d565b9998505050505050505050565b60008061157c6115728585610d14565b6111078588611403565b90506116267f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663aa051c2c88306040518363ffffffff1660e01b81526004016115cf929190611f6c565b60206040518083038186803b1580156115e757600080fd5b505afa1580156115fb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161f9190611a8c565b8290611632565b9150505b949350505050565b60008183038183128015906116475750838113155b8061165c575060008312801561165c57508381135b6113815760405162461bcd60e51b815260040161030d906120c9565b60008261168757506000610a0b565b8260001914801561169b5750600160ff1b82145b156116b85760405162461bcd60e51b815260040161030d906120b9565b828202828482816116c557fe5b05146113815760405162461bcd60e51b815260040161030d906120b9565b6000816117025760405162461bcd60e51b815260040161030d906120d9565b816000191480156117165750600160ff1b83145b156117335760405162461bcd60e51b815260040161030d90612089565b600082848161173e57fe5b05949350505050565b600082820181831280159061175c5750838112155b80611771575060008312801561177157508381125b6113815760405162461bcd60e51b815260040161030d90612049565b60008183126113b6575081610a0b565b6040805160e081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c081019190915290565b8035610a0b81612216565b8051610a0b81612216565b8051610a0b8161222a565b60008083601f84011261180c57600080fd5b5081356001600160401b0381111561182357600080fd5b60208301915083600182028301111561183b57600080fd5b9250929050565b8035610a0b81612233565b8035610a0b81612240565b8035610a0b81612249565b8051610a0b81612249565b8035610a0b81612252565b8051610a0b8161225b565b60006020828403121561189657600080fd5b600061162a84846117d9565b6000602082840312156118b457600080fd5b600061162a84846117e4565b6000806000606084860312156118d557600080fd5b60006118e186866117e4565b93505060206118f286828701611863565b9250506040611903868287016117ef565b9150509250925092565b6000806040838503121561192057600080fd5b600061192c85856117d9565b925050602061193d858286016117d9565b9150509250929050565b60008060008060008060a0878903121561196057600080fd5b600061196c89896117d9565b965050602061197d89828a016117d9565b955050604061198e89828a01611842565b94505060608701356001600160401b038111156119aa57600080fd5b6119b689828a016117fa565b935093505060806119c989828a01611858565b9150509295509295509295565b6000806000604084860312156119eb57600080fd5b60006119f786866117d9565b93505060208401356001600160401b03811115611a1357600080fd5b611a1f868287016117fa565b92509250509250925092565b600060208284031215611a3d57600080fd5b600061162a8484611842565b600080600060608486031215611a5e57600080fd5b6000611a6a868661184d565b9350506020611a7b8682870161186e565b9250506040611903868287016117d9565b600060208284031215611a9e57600080fd5b600061162a8484611863565b600060208284031215611abc57600080fd5b600061162a8484611879565b611ad181612173565b82525050565b611ad18161217e565b6000611aeb82612166565b611af5818561216a565b9350611b058185602086016121d6565b611b0e81612202565b9093019392505050565b611ad1816121b5565b611ad18161218d565b6000611b3760258361216a565b7f61646446756e6453657474696e67733a2066656552617465206d617820657863815264195959195960da1b602082015260400192915050565b6000611b7e60318361216a565b7f61646446756e6453657474696e67733a20666565506572696f64206d75737420815270062652067726561746572207468616e203607c1b602082015260400192915050565b6000611bd160218361216a565b7f5369676e6564536166654d6174683a206164646974696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611c14601e8361216a565b7f536166654d6174683a207375627472616374696f6e206f766572666c6f770000815260200192915050565b6000611c4d601a8361216a565b7f536166654d6174683a206469766973696f6e206279207a65726f000000000000815260200192915050565b6000611c8660258361216a565b7f4f6e6c7920746865204665654d616e6765722063616e206d616b6520746869738152640818d85b1b60da1b602082015260400192915050565b6000611ccd60218361216a565b7f5369676e6564536166654d6174683a206469766973696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611d1060218361216a565b7f536166654d6174683a206d756c7469706c69636174696f6e206f766572666c6f8152607760f81b602082015260400192915050565b6000611d53602f8361216a565b7f61646446756e6453657474696e67733a2066656552617465206d75737420626581526e02067726561746572207468616e203608c1b602082015260400192915050565b6000611da460278361216a565b7f5369676e6564536166654d6174683a206d756c7469706c69636174696f6e206f815266766572666c6f7760c81b602082015260400192915050565b6000611ded60248361216a565b7f5369676e6564536166654d6174683a207375627472616374696f6e206f766572815263666c6f7760e01b602082015260400192915050565b6000611e3360208361216a565b7f5369676e6564536166654d6174683a206469766973696f6e206279207a65726f815260200192915050565b6000611e6c60308361216a565b7f5f5f736574526563697069656e74466f7246756e643a204f6e6c79207661756c81526f74206f776e65722063616c6c61626c6560801b602082015260400192915050565b805160e0830190611ec28482611f3a565b506020820151611ed56020850182611f55565b506040820151611ee86040850182611f55565b506060820151611efb6060850182611f55565b506080820151611f0e6080850182611b21565b5060a0820151611f2160a0850182611b21565b5060c0820151611f3460c0850182611b21565b50505050565b611ad181612190565b611ad1816121c0565b611ad1816121cb565b611ad1816121a3565b60208101610a0b8284611ac8565b60408101611f7a8285611ac8565b6113816020830184611ac8565b60208101610a0b8284611ad7565b60408101611fa38285611ad7565b6113816020830184611ad7565b602080825281016113818184611ae0565b60608101611fcf8286611b18565b611fdc6020830185611ac8565b61162a6040830184611b21565b60408082528101611ffa8185611ae0565b90506113816020830184611ac8565b6040808252810161201a8185611ae0565b90506113816020830184611b21565b60208082528101610a0b81611b2a565b60208082528101610a0b81611b71565b60208082528101610a0b81611bc4565b60208082528101610a0b81611c07565b60208082528101610a0b81611c40565b60208082528101610a0b81611c79565b60208082528101610a0b81611cc0565b60208082528101610a0b81611d03565b60208082528101610a0b81611d46565b60208082528101610a0b81611d97565b60208082528101610a0b81611de0565b60208082528101610a0b81611e26565b60208082528101610a0b81611e5f565b60e08101610a0b8284611eb1565b604081016121158285611f43565b6113816020830184611f4c565b60208101610a0b8284611b21565b6040810161213e8285611b21565b6113816020830184611b21565b606081016121598286611b21565b611fdc6020830185611b21565b5190565b90815260200190565b6000610a0b82612197565b151590565b806102c08161220c565b90565b61ffff1690565b6001600160a01b031690565b6001600160401b031690565b60ff1690565b6000610a0b82612183565b6000610a0b82612190565b6000610a0b826121a3565b60005b838110156121f15781810151838201526020016121d9565b83811115611f345750506000910152565b601f01601f191690565b60068110610d7f57fe5b61221f81612173565b8114610d7f57600080fd5b61221f8161217e565b60048110610d7f57600080fd5b61221f81612190565b61221f8161218d565b61221f816121a3565b61221f816121af56fe506572666f726d6163654665653a61646446756e6453657474696e67733a666565526174653a2564506572666f726d6163654665653a61646446756e6453657474696e67732061667465722046756e6453657474696e67734164646564506572666f726d6163654665653a61646446756e6453657474696e67733a666565506572696f643a2564506572666f726d6163654665653a61646446756e6453657474696e67733a726563697069656e743a2573506572666f726d6163654665653a61646446756e6453657474696e67732061667265207265717569726573506572666f726d6163654665653a61646446756e6453657474696e67733a626567696e506572666f726d6163654665653a61646446756e6453657474696e677320616674657220636f6d7074726f6c6c657250726f7879546f466565496e666fa2646970667358221220b54d9817090331458172caab21e8eb9283e63bf40cdda2b770ce8e2be36a698a64736f6c634300060c0033",
  "devdoc": {
    "author": "Enzyme Council <security@enzyme.finance>",
    "details": "This contract assumes that all shares in the VaultProxy are shares outstanding, which is fine for this release. Even if they are not, they are still shares that are only claimable by the fund owner.",
    "kind": "dev",
    "methods": {
      "activateForFund(address,address)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund"
        }
      },
      "addFundSettings(address,bytes)": {
        "details": "`highWaterMark`, `lastSharePrice`, and `activated` are set during activation",
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund",
          "_settingsData": "Encoded settings to apply to the fee for a fund"
        }
      },
      "getFeeInfoForFund(address)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy contract of the fund"
        },
        "returns": {
          "feeInfo_": "The feeInfo"
        }
      },
      "getFeeManager()": {
        "returns": {
          "feeManager_": "The `FEE_MANAGER` variable value"
        }
      },
      "getRecipientForFund(address)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy contract for the fund"
        },
        "returns": {
          "recipient_": "The recipient"
        }
      },
      "payout(address,address)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund"
        },
        "returns": {
          "isPayable_": "True if shares outstanding can be paid out"
        }
      },
      "payoutAllowed(address)": {
        "details": "Payout is allowed if fees have not yet been settled in a crystallization period, and at least 1 crystallization period has passed since activation",
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund"
        },
        "returns": {
          "payoutAllowed_": "True if the fee payment is due"
        }
      },
      "setRecipientForFund(address,address)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy contract for the fund",
          "_recipient": "The fee recipient"
        }
      },
      "settle(address,address,uint8,bytes,uint256)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund",
          "_gav": "The GAV of the fund",
          "_vaultProxy": "The VaultProxy of the fund"
        },
        "returns": {
          "_1": "(unused) The payer of shares due",
          "settlementType_": "The type of settlement",
          "sharesDue_": "The amount of shares due"
        }
      },
      "settlesOnHook(uint8)": {
        "params": {
          "_hook": "The FeeHook"
        },
        "returns": {
          "settles_": "True if the fee settles on the _hook",
          "usesGav_": "True if the fee uses GAV during settle() for the _hook"
        }
      },
      "update(address,address,uint8,bytes,uint256)": {
        "params": {
          "_comptrollerProxy": "The ComptrollerProxy of the fund",
          "_gav": "The GAV of the fund",
          "_hook": "The FeeHook being executed",
          "_settlementData": "Encoded args to use in calculating the settlement",
          "_vaultProxy": "The VaultProxy of the fund"
        }
      },
      "updatesOnHook(uint8)": {
        "params": {
          "_hook": "The FeeHook"
        },
        "returns": {
          "updates_": "True if the fee updates on the _hook",
          "usesGav_": "True if the fee uses GAV during update() for the _hook"
        }
      }
    },
    "title": "PerformanceFee Contract",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "activateForFund(address,address)": {
        "notice": "Activates the fee for a fund"
      },
      "addFundSettings(address,bytes)": {
        "notice": "Add the initial fee settings for a fund"
      },
      "getFeeInfoForFund(address)": {
        "notice": "Gets the feeInfo for a given fund"
      },
      "getFeeManager()": {
        "notice": "Gets the `FEE_MANAGER` variable"
      },
      "getRecipientForFund(address)": {
        "notice": "Gets the recipient of the fee for a given fund"
      },
      "payout(address,address)": {
        "notice": "Checks whether the shares outstanding for the fee can be paid out, and updates the info for the fee's last payout"
      },
      "payoutAllowed(address)": {
        "notice": "Checks whether the shares outstanding can be paid out"
      },
      "setRecipientForFund(address,address)": {
        "notice": "Sets the fee recipient for the given fund"
      },
      "settle(address,address,uint8,bytes,uint256)": {
        "notice": "Settles the fee and calculates shares due"
      },
      "settlesOnHook(uint8)": {
        "notice": "Gets whether the fee settles and requires GAV on a particular hook"
      },
      "update(address,address,uint8,bytes,uint256)": {
        "notice": "Updates the fee state after all fees have finished settle()"
      },
      "updatesOnHook(uint8)": {
        "notice": "Gets whether the fee updates and requires GAV on a particular hook"
      }
    },
    "notice": "A performance-based fee with configurable rate and crystallization period, using a high watermark",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 20879,
        "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
        "label": "comptrollerProxyToRecipient",
        "offset": 0,
        "slot": "0",
        "type": "t_mapping(t_address,t_address)"
      },
      {
        "astId": 19051,
        "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
        "label": "comptrollerProxyToFeeInfo",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_struct(FeeInfo)19039_storage)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_address)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => address)",
        "numberOfBytes": "32",
        "value": "t_address"
      },
      "t_mapping(t_address,t_struct(FeeInfo)19039_storage)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => struct PerformanceFee.FeeInfo)",
        "numberOfBytes": "32",
        "value": "t_struct(FeeInfo)19039_storage"
      },
      "t_struct(FeeInfo)19039_storage": {
        "encoding": "inplace",
        "label": "struct PerformanceFee.FeeInfo",
        "members": [
          {
            "astId": 19026,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "rate",
            "offset": 0,
            "slot": "0",
            "type": "t_uint16"
          },
          {
            "astId": 19028,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "period",
            "offset": 2,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 19030,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "activated",
            "offset": 10,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 19032,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "lastPaid",
            "offset": 18,
            "slot": "0",
            "type": "t_uint64"
          },
          {
            "astId": 19034,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "highWaterMark",
            "offset": 0,
            "slot": "1",
            "type": "t_uint256"
          },
          {
            "astId": 19036,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "lastSharePrice",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 19038,
            "contract": "contracts/release/extensions/fee-manager/fees/PerformanceFee.sol:PerformanceFee",
            "label": "aggregateValueDue",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          }
        ],
        "numberOfBytes": "128"
      },
      "t_uint16": {
        "encoding": "inplace",
        "label": "uint16",
        "numberOfBytes": "2"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint64": {
        "encoding": "inplace",
        "label": "uint64",
        "numberOfBytes": "8"
      }
    }
  }
}